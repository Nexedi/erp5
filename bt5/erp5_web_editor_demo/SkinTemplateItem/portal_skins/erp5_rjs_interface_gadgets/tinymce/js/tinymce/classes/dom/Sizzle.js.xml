<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268372.51</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Sizzle.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Sizzle.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 *\n
 * @ignore-file\n
 */\n
\n
/*jshint bitwise:false, expr:true, noempty:false, sub:true, eqnull:true, latedef:false, maxlen:255 */\n
/*eslint-disable */\n
\n
/**\n
 * Sizzle CSS Selector Engine v@VERSION\n
 * http://sizzlejs.com/\n
 *\n
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n
 * Released under the MIT license\n
 * http://jquery.org/license\n
 *\n
 * Date: @DATE\n
 */\n
define("tinymce/dom/Sizzle", [], function() {\n
var i,\n
\tsupport,\n
\tExpr,\n
\tgetText,\n
\tisXML,\n
\ttokenize,\n
\tcompile,\n
\tselect,\n
\toutermostContext,\n
\tsortInput,\n
\thasDuplicate,\n
\n
\t// Local document vars\n
\tsetDocument,\n
\tdocument,\n
\tdocElem,\n
\tdocumentIsHTML,\n
\trbuggyQSA,\n
\trbuggyMatches,\n
\tmatches,\n
\tcontains,\n
\n
\t// Instance-specific data\n
\texpando = "sizzle" + -(new Date()),\n
\tpreferredDoc = window.document,\n
\tdirruns = 0,\n
\tdone = 0,\n
\tclassCache = createCache(),\n
\ttokenCache = createCache(),\n
\tcompilerCache = createCache(),\n
\tsortOrder = function( a, b ) {\n
\t\tif ( a === b ) {\n
\t\t\thasDuplicate = true;\n
\t\t}\n
\t\treturn 0;\n
\t},\n
\n
\t// General-purpose constants\n
\tstrundefined = typeof undefined,\n
\tMAX_NEGATIVE = 1 << 31,\n
\n
\t// Instance methods\n
\thasOwn = ({}).hasOwnProperty,\n
\tarr = [],\n
\tpop = arr.pop,\n
\tpush_native = arr.push,\n
\tpush = arr.push,\n
\tslice = arr.slice,\n
\t// Use a stripped-down indexOf if we can\'t use a native one\n
\tindexOf = arr.indexOf || function( elem ) {\n
\t\tvar i = 0,\n
\t\t\tlen = this.length;\n
\t\tfor ( ; i < len; i++ ) {\n
\t\t\tif ( this[i] === elem ) {\n
\t\t\t\treturn i;\n
\t\t\t}\n
\t\t}\n
\t\treturn -1;\n
\t},\n
\n
\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n
\n
\t// Regular expressions\n
\n
\t// http://www.w3.org/TR/css3-selectors/#whitespace\n
\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n
\n
\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n
\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n
\n
\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n
\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n
\t\t// Operator (capture 2)\n
\t\t"*([*^$|!~]?=)" + whitespace +\n
\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n
\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n
\t\t"*\\\\]",\n
\n
\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n
\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n
\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n
\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n
\t\t// 2. simple (capture 6)\n
\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n
\t\t// 3. anything else (capture 2)\n
\t\t".*" +\n
\t\t")\\\\)|)",\n
\n
\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n
\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n
\n
\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n
\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n
\n
\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n
\n
\trpseudo = new RegExp( pseudos ),\n
\tridentifier = new RegExp( "^" + identifier + "$" ),\n
\n
\tmatchExpr = {\n
\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n
\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n
\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n
\t\t"ATTR": new RegExp( "^" + attributes ),\n
\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n
\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n
\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n
\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n
\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n
\t\t// For use in libraries implementing .is()\n
\t\t// We use this for POS matching in `select`\n
\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n
\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n
\t},\n
\n
\trinputs = /^(?:input|select|textarea|button)$/i,\n
\trheader = /^h\\d$/i,\n
\n
\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n
\n
\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n
\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n
\n
\trsibling = /[+~]/,\n
\trescape = /\'|\\\\/g,\n
\n
\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n
\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n
\tfunescape = function( _, escaped, escapedWhitespace ) {\n
\t\tvar high = "0x" + escaped - 0x10000;\n
\t\t// NaN means non-codepoint\n
\t\t// Support: Firefox<24\n
\t\t// Workaround erroneous numeric interpretation of +"0x"\n
\t\treturn high !== high || escapedWhitespace ?\n
\t\t\tescaped :\n
\t\t\thigh < 0 ?\n
\t\t\t\t// BMP codepoint\n
\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n
\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n
\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n
\t};\n
\n
// Optimize for push.apply( _, NodeList )\n
try {\n
\tpush.apply(\n
\t\t(arr = slice.call( preferredDoc.childNodes )),\n
\t\tpreferredDoc.childNodes\n
\t);\n
\t// Support: Android<4.0\n
\t// Detect silently failing push.apply\n
\tarr[ preferredDoc.childNodes.length ].nodeType;\n
} catch ( e ) {\n
\tpush = { apply: arr.length ?\n
\n
\t\t// Leverage slice if possible\n
\t\tfunction( target, els ) {\n
\t\t\tpush_native.apply( target, slice.call(els) );\n
\t\t} :\n
\n
\t\t// Support: IE<9\n
\t\t// Otherwise append directly\n
\t\tfunction( target, els ) {\n
\t\t\tvar j = target.length,\n
\t\t\t\ti = 0;\n
\t\t\t// Can\'t trust NodeList.length\n
\t\t\twhile ( (target[j++] = els[i++]) ) {}\n
\t\t\ttarget.length = j - 1;\n
\t\t}\n
\t};\n
}\n
\n
function Sizzle( selector, context, results, seed ) {\n
\tvar match, elem, m, nodeType,\n
\t\t// QSA vars\n
\t\ti, groups, old, nid, newContext, newSelector;\n
\n
\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n
\t\tsetDocument( context );\n
\t}\n
\n
\tcontext = context || document;\n
\tresults = results || [];\n
\n
\tif ( !selector || typeof selector !== "string" ) {\n
\t\treturn results;\n
\t}\n
\n
\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n
\t\treturn [];\n
\t}\n
\n
\tif ( documentIsHTML && !seed ) {\n
\n
\t\t// Shortcuts\n
\t\tif ( (match = rquickExpr.exec( selector )) ) {\n
\t\t\t// Speed-up: Sizzle("#ID")\n
\t\t\tif ( (m = match[1]) ) {\n
\t\t\t\tif ( nodeType === 9 ) {\n
\t\t\t\t\telem = context.getElementById( m );\n
\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n
\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n
\t\t\t\t\tif ( elem && elem.parentNode ) {\n
\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n
\t\t\t\t\t\t// by name instead of ID\n
\t\t\t\t\t\tif ( elem.id === m ) {\n
\t\t\t\t\t\t\tresults.push( elem );\n
\t\t\t\t\t\t\treturn results;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\treturn results;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// Context is not a document\n
\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n
\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n
\t\t\t\t\t\tresults.push( elem );\n
\t\t\t\t\t\treturn results;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t// Speed-up: Sizzle("TAG")\n
\t\t\t} else if ( match[2] ) {\n
\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n
\t\t\t\treturn results;\n
\n
\t\t\t// Speed-up: Sizzle(".CLASS")\n
\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n
\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n
\t\t\t\treturn results;\n
\t\t\t}\n
\t\t}\n
\n
\t\t// QSA path\n
\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n
\t\t\tnid = old = expando;\n
\t\t\tnewContext = context;\n
\t\t\tnewSelector = nodeType === 9 && selector;\n
\n
\t\t\t// qSA works strangely on Element-rooted queries\n
\t\t\t// We can work around this by specifying an extra ID on the root\n
\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n
\t\t\t// IE 8 doesn\'t work on object elements\n
\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {\n
\t\t\t\tgroups = tokenize( selector );\n
\n
\t\t\t\tif ( (old = context.getAttribute("id")) ) {\n
\t\t\t\t\tnid = old.replace( rescape, "\\\\$&" );\n
\t\t\t\t} else {\n
\t\t\t\t\tcontext.setAttribute( "id", nid );\n
\t\t\t\t}\n
\t\t\t\tnid = "[id=\'" + nid + "\'] ";\n
\n
\t\t\t\ti = groups.length;\n
\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n
\t\t\t\t}\n
\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n
\t\t\t\tnewSelector = groups.join(",");\n
\t\t\t}\n
\n
\t\t\tif ( newSelector ) {\n
\t\t\t\ttry {\n
\t\t\t\t\tpush.apply( results,\n
\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n
\t\t\t\t\t);\n
\t\t\t\t\treturn results;\n
\t\t\t\t} catch(qsaError) {\n
\t\t\t\t} finally {\n
\t\t\t\t\tif ( !old ) {\n
\t\t\t\t\t\tcontext.removeAttribute("id");\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\t// All others\n
\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n
}\n
\n
/**\n
 * Create key-value caches of limited size\n
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n
 *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n
 *\tdeleting the oldest entry\n
 */\n
function createCache() {\n
\tvar keys = [];\n
\n
\tfunction cache( key, value ) {\n
\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n
\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n
\t\t\t// Only keep the most recent entries\n
\t\t\tdelete cache[ keys.shift() ];\n
\t\t}\n
\t\treturn (cache[ key + " " ] = value);\n
\t}\n
\treturn cache;\n
}\n
\n
/**\n
 * Mark a function for special use by Sizzle\n
 * @param {Function} fn The function to mark\n
 */\n
function markFunction( fn ) {\n
\tfn[ expando ] = true;\n
\treturn fn;\n
}\n
\n
/**\n
 * Support testing using an element\n
 * @param {Function} fn Passed the created div and expects a boolean result\n
 */\n
function assert( fn ) {\n
\tvar div = document.createElement("div");\n
\n
\ttry {\n
\t\treturn !!fn( div );\n
\t} catch (e) {\n
\t\treturn false;\n
\t} finally {\n
\t\t// Remove from its parent by default\n
\t\tif ( div.parentNode ) {\n
\t\t\tdiv.parentNode.removeChild( div );\n
\t\t}\n
\t\t// release memory in IE\n
\t\tdiv = null;\n
\t}\n
}\n
\n
/**\n
 * Adds the same handler for all of the specified attrs\n
 * @param {String} attrs Pipe-separated list of attributes\n
 * @param {Function} handler The method that will be applied\n
 */\n
function addHandle( attrs, handler ) {\n
\tvar arr = attrs.split("|"),\n
\t\ti = attrs.length;\n
\n
\twhile ( i-- ) {\n
\t\tExpr.attrHandle[ arr[i] ] = handler;\n
\t}\n
}\n
\n
/**\n
 * Checks document order of two siblings\n
 * @param {Element} a\n
 * @param {Element} b\n
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n
 */\n
function siblingCheck( a, b ) {\n
\tvar cur = b && a,\n
\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n
\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n
\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n
\n
\t// Use IE sourceIndex if available on both nodes\n
\tif ( diff ) {\n
\t\treturn diff;\n
\t}\n
\n
\t// Check if b follows a\n
\tif ( cur ) {\n
\t\twhile ( (cur = cur.nextSibling) ) {\n
\t\t\tif ( cur === b ) {\n
\t\t\t\treturn -1;\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\treturn a ? 1 : -1;\n
}\n
\n
/**\n
 * Returns a function to use in pseudos for input types\n
 * @param {String} type\n
 */\n
function createInputPseudo( type ) {\n
\treturn function( elem ) {\n
\t\tvar name = elem.nodeName.toLowerCase();\n
\t\treturn name === "input" && elem.type === type;\n
\t};\n
}\n
\n
/**\n
 * Returns a function to use in pseudos for buttons\n
 * @param {String} type\n
 */\n
function createButtonPseudo( type ) {\n
\treturn function( elem ) {\n
\t\tvar name = elem.nodeName.toLowerCase();\n
\t\treturn (name === "input" || name === "button") && elem.type === type;\n
\t};\n
}\n
\n
/**\n
 * Returns a function to use in pseudos for positionals\n
 * @param {Function} fn\n
 */\n
function createPositionalPseudo( fn ) {\n
\treturn markFunction(function( argument ) {\n
\t\targument = +argument;\n
\t\treturn markFunction(function( seed, matches ) {\n
\t\t\tvar j,\n
\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n
\t\t\t\ti = matchIndexes.length;\n
\n
\t\t\t// Match elements found at the specified indexes\n
\t\t\twhile ( i-- ) {\n
\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n
\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\t});\n
}\n
\n
/**\n
 * Checks a node for validity as a Sizzle context\n
 * @param {Element|Object=} context\n
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n
 */\n
function testContext( context ) {\n
\treturn context && typeof context.getElementsByTagName !== strundefined && context;\n
}\n
\n
// Expose support vars for convenience\n
support = Sizzle.support = {};\n
\n
/**\n
 * Detects XML nodes\n
 * @param {Element|Object} elem An element or a document\n
 * @returns {Boolean} True iff elem is a non-HTML XML node\n
 */\n
isXML = Sizzle.isXML = function( elem ) {\n
\t// documentElement is verified for cases where it doesn\'t yet exist\n
\t// (such as loading iframes in IE - #4833)\n
\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n
\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n
};\n
\n
/**\n
 * Sets document-related variables once based on the current document\n
 * @param {Element|Object} [doc] An element or document object to use to set the document\n
 * @returns {Object} Returns the current document\n
 */\n
setDocument = Sizzle.setDocument = function( node ) {\n
\tvar hasCompare,\n
\t\tdoc = node ? node.ownerDocument || node : preferredDoc,\n
\t\tparent = doc.defaultView;\n
\n
\t// If no document and documentElement is available, return\n
\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n
\t\treturn document;\n
\t}\n
\n
\t// Set our document\n
\tdocument = doc;\n
\tdocElem = doc.documentElement;\n
\n
\t// Support tests\n
\tdocumentIsHTML = !isXML( doc );\n
\n
\t// Support: IE>8\n
\t// If iframe document is assigned to "document" variable and if iframe has been reloaded,\n
\t// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936\n
\t// IE6-8 do not support the defaultView property so parent will be undefined\n
\tif ( parent && parent !== parent.top ) {\n
\t\t// IE11 does not have attachEvent, so all must suffer\n
\t\tif ( parent.addEventListener ) {\n
\t\t\tparent.addEventListener( "unload", function() {\n
\t\t\t\tsetDocument();\n
\t\t\t}, false );\n
\t\t} else if ( parent.attachEvent ) {\n
\t\t\tparent.attachEvent( "onunload", function() {\n
\t\t\t\tsetDocument();\n
\t\t\t});\n
\t\t}\n
\t}\n
\n
\t/* Attributes\n
\t---------------------------------------------------------------------- */\n
\n
\t// Support: IE<8\n
\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n
\tsupport.attributes = assert(function( div ) {\n
\t\tdiv.className = "i";\n
\t\treturn !div.getAttribute("className");\n
\t});\n
\n
\t/* getElement(s)By*\n
\t---------------------------------------------------------------------- */\n
\n
\t// Check if getElementsByTagName("*") returns only elements\n
\tsupport.getElementsByTagName = assert(function( div ) {\n
\t\tdiv.appendChild( doc.createComment("") );\n
\t\treturn !div.getElementsByTagName("*").length;\n
\t});\n
\n
\t// Support: IE<9\n
\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n
\n
\t// Support: IE<10\n
\t// Check if getElementById returns elements by name\n
\t// The broken getElementById methods don\'t pick up programatically-set names,\n
\t// so use a roundabout getElementsByName test\n
\tsupport.getById = assert(function( div ) {\n
\t\tdocElem.appendChild( div ).id = expando;\n
\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n
\t});\n
\n
\t// ID find and filter\n
\tif ( support.getById ) {\n
\t\tExpr.find["ID"] = function( id, context ) {\n
\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n
\t\t\t\tvar m = context.getElementById( id );\n
\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n
\t\t\t\t// nodes that are no longer in the document #6963\n
\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n
\t\t\t}\n
\t\t};\n
\t\tExpr.filter["ID"] = function( id ) {\n
\t\t\tvar attrId = id.replace( runescape, funescape );\n
\t\t\treturn function( elem ) {\n
\t\t\t\treturn elem.getAttribute("id") === attrId;\n
\t\t\t};\n
\t\t};\n
\t} else {\n
\t\t// Support: IE6/7\n
\t\t// getElementById is not reliable as a find shortcut\n
\t\tdelete Expr.find["ID"];\n
\n
\t\tExpr.filter["ID"] =  function( id ) {\n
\t\t\tvar attrId = id.replace( runescape, funescape );\n
\t\t\treturn function( elem ) {\n
\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");\n
\t\t\t\treturn node && node.value === attrId;\n
\t\t\t};\n
\t\t};\n
\t}\n
\n
\t// Tag\n
\tExpr.find["TAG"] = support.getElementsByTagName ?\n
\t\tfunction( tag, context ) {\n
\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n
\t\t\t\treturn context.getElementsByTagName( tag );\n
\t\t\t}\n
\t\t} :\n
\t\tfunction( tag, context ) {\n
\t\t\tvar elem,\n
\t\t\t\ttmp = [],\n
\t\t\t\ti = 0,\n
\t\t\t\tresults = context.getElementsByTagName( tag );\n
\n
\t\t\t// Filter out possible comments\n
\t\t\tif ( tag === "*" ) {\n
\t\t\t\twhile ( (elem = results[i++]) ) {\n
\t\t\t\t\tif ( elem.nodeType === 1 ) {\n
\t\t\t\t\t\ttmp.push( elem );\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn tmp;\n
\t\t\t}\n
\t\t\treturn results;\n
\t\t};\n
\n
\t// Class\n
\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n
\t\tif ( documentIsHTML ) {\n
\t\t\treturn context.getElementsByClassName( className );\n
\t\t}\n
\t};\n
\n
\t/* QSA/matchesSelector\n
\t---------------------------------------------------------------------- */\n
\n
\t// QSA and matchesSelector support\n
\n
\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n
\trbuggyMatches = [];\n
\n
\t// qSa(:focus) reports false when true (Chrome 21)\n
\t// We allow this because of a bug in IE8/9 that throws an error\n
\t// whenever `document.activeElement` is accessed on an iframe\n
\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n
\t// See http://bugs.jquery.com/ticket/13378\n
\trbuggyQSA = [];\n
\n
\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n
\t\t// Build QSA regex\n
\t\t// Regex strategy adopted from Diego Perini\n
\t\tassert(function( div ) {\n
\t\t\t// Select is set to empty string on purpose\n
\t\t\t// This is to test IE\'s treatment of not explicitly\n
\t\t\t// setting a boolean content attribute,\n
\t\t\t// since its presence should be enough\n
\t\t\t// http://bugs.jquery.com/ticket/12359\n
\t\t\tdiv.innerHTML = "<select msallowcapture=\'\'><option selected=\'\'></option></select>";\n
\n
\t\t\t// Support: IE8, Opera 11-12.16\n
\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n
\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n
\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n
\t\t\tif ( div.querySelectorAll("[msallowcapture^=\'\']").length ) {\n
\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n
\t\t\t}\n
\n
\t\t\t// Support: IE8\n
\t\t\t// Boolean attributes and "value" are not treated correctly\n
\t\t\tif ( !div.querySelectorAll("[selected]").length ) {\n
\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n
\t\t\t}\n
\n
\t\t\t// Webkit/Opera - :checked should return selected option elements\n
\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n
\t\t\t// IE8 throws error here and will not see later tests\n
\t\t\tif ( !div.querySelectorAll(":checked").length ) {\n
\t\t\t\trbuggyQSA.push(":checked");\n
\t\t\t}\n
\t\t});\n
\n
\t\tassert(function( div ) {\n
\t\t\t// Support: Windows 8 Native Apps\n
\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n
\t\t\tvar input = doc.createElement("input");\n
\t\t\tinput.setAttribute( "type", "hidden" );\n
\t\t\tdiv.appendChild( input ).setAttribute( "name", "D" );\n
\n
\t\t\t// Support: IE8\n
\t\t\t// Enforce case-sensitivity of name attribute\n
\t\t\tif ( div.querySelectorAll("[name=d]").length ) {\n
\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n
\t\t\t}\n
\n
\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n
\t\t\t// IE8 throws error here and will not see later tests\n
\t\t\tif ( !div.querySelectorAll(":enabled").length ) {\n
\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n
\t\t\t}\n
\n
\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n
\t\t\tdiv.querySelectorAll("*,:x");\n
\t\t\trbuggyQSA.push(",.*:");\n
\t\t});\n
\t}\n
\n
\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n
\t\tdocElem.webkitMatchesSelector ||\n
\t\tdocElem.mozMatchesSelector ||\n
\t\tdocElem.oMatchesSelector ||\n
\t\tdocElem.msMatchesSelector) )) ) {\n
\n
\t\tassert(function( div ) {\n
\t\t\t// Check to see if it\'s possible to do matchesSelector\n
\t\t\t// on a disconnected node (IE 9)\n
\t\t\tsupport.disconnectedMatch = matches.call( div, "div" );\n
\n
\t\t\t// This should fail with an exception\n
\t\t\t// Gecko does not error, returns false instead\n
\t\t\tmatches.call( div, "[s!=\'\']:x" );\n
\t\t\trbuggyMatches.push( "!=", pseudos );\n
\t\t});\n
\t}\n
\n
\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n
\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n
\n
\t/* Contains\n
\t---------------------------------------------------------------------- */\n
\thasCompare = rnative.test( docElem.compareDocumentPosition );\n
\n
\t// Element contains another\n
\t// Purposefully does not implement inclusive descendent\n
\t// As in, an element does not contain itself\n
\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n
\t\tfunction( a, b ) {\n
\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n
\t\t\t\tbup = b && b.parentNode;\n
\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n
\t\t\t\tadown.contains ?\n
\t\t\t\t\tadown.contains( bup ) :\n
\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n
\t\t\t));\n
\t\t} :\n
\t\tfunction( a, b ) {\n
\t\t\tif ( b ) {\n
\t\t\t\twhile ( (b = b.parentNode) ) {\n
\t\t\t\t\tif ( b === a ) {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn false;\n
\t\t};\n
\n
\t/* Sorting\n
\t---------------------------------------------------------------------- */\n
\n
\t// Document order sorting\n
\tsortOrder = hasCompare ?\n
\tfunction( a, b ) {\n
\n
\t\t// Flag for duplicate removal\n
\t\tif ( a === b ) {\n
\t\t\thasDuplicate = true;\n
\t\t\treturn 0;\n
\t\t}\n
\n
\t\t// Sort on method existence if only one input has compareDocumentPosition\n
\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n
\t\tif ( compare ) {\n
\t\t\treturn compare;\n
\t\t}\n
\n
\t\t// Calculate position if both inputs belong to the same document\n
\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n
\t\t\ta.compareDocumentPosition( b ) :\n
\n
\t\t\t// Otherwise we know they are disconnected\n
\t\t\t1;\n
\n
\t\t// Disconnected nodes\n
\t\tif ( compare & 1 ||\n
\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n
\n
\t\t\t// Choose the first element that is related to our preferred document\n
\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n
\t\t\t\treturn -1;\n
\t\t\t}\n
\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n
\t\t\t\treturn 1;\n
\t\t\t}\n
\n
\t\t\t// Maintain original order\n
\t\t\treturn sortInput ?\n
\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n
\t\t\t\t0;\n
\t\t}\n
\n
\t\treturn compare & 4 ? -1 : 1;\n
\t} :\n
\tfunction( a, b ) {\n
\t\t// Exit early if the nodes are identical\n
\t\tif ( a === b ) {\n
\t\t\thasDuplicate = true;\n
\t\t\treturn 0;\n
\t\t}\n
\n
\t\tvar cur,\n
\t\t\ti = 0,\n
\t\t\taup = a.parentNode,\n
\t\t\tbup = b.parentNode,\n
\t\t\tap = [ a ],\n
\t\t\tbp = [ b ];\n
\n
\t\t// Parentless nodes are either documents or disconnected\n
\t\tif ( !aup || !bup ) {\n
\t\t\treturn a === doc ? -1 :\n
\t\t\t\tb === doc ? 1 :\n
\t\t\t\taup ? -1 :\n
\t\t\t\tbup ? 1 :\n
\t\t\t\tsortInput ?\n
\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n
\t\t\t\t0;\n
\n
\t\t// If the nodes are siblings, we can do a quick check\n
\t\t} else if ( aup === bup ) {\n
\t\t\treturn siblingCheck( a, b );\n
\t\t}\n
\n
\t\t// Otherwise we need full lists of their ancestors for comparison\n
\t\tcur = a;\n
\t\twhile ( (cur = cur.parentNode) ) {\n
\t\t\tap.unshift( cur );\n
\t\t}\n
\t\tcur = b;\n
\t\twhile ( (cur = cur.parentNode) ) {\n
\t\t\tbp.unshift( cur );\n
\t\t}\n
\n
\t\t// Walk down the tree looking for a discrepancy\n
\t\twhile ( ap[i] === bp[i] ) {\n
\t\t\ti++;\n
\t\t}\n
\n
\t\treturn i ?\n
\t\t\t// Do a sibling check if the nodes have a common ancestor\n
\t\t\tsiblingCheck( ap[i], bp[i] ) :\n
\n
\t\t\t// Otherwise nodes in our document sort first\n
\t\t\tap[i] === preferredDoc ? -1 :\n
\t\t\tbp[i] === preferredDoc ? 1 :\n
\t\t\t0;\n
\t};\n
\n
\treturn doc;\n
};\n
\n
Sizzle.matches = function( expr, elements ) {\n
\treturn Sizzle( expr, null, null, elements );\n
};\n
\n
Sizzle.matchesSelector = function( elem, expr ) {\n
\t// Set document vars if needed\n
\tif ( ( elem.ownerDocument || elem ) !== document ) {\n
\t\tsetDocument( elem );\n
\t}\n
\n
\t// Make sure that attribute selectors are quoted\n
\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n
\n
\tif ( support.matchesSelector && documentIsHTML &&\n
\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n
\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n
\n
\t\ttry {\n
\t\t\tvar ret = matches.call( elem, expr );\n
\n
\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n
\t\t\tif ( ret || support.disconnectedMatch ||\n
\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n
\t\t\t\t\t// fragment in IE 9\n
\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n
\t\t\t\treturn ret;\n
\t\t\t}\n
\t\t} catch(e) {}\n
\t}\n
\n
\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n
};\n
\n
Sizzle.contains = function( context, elem ) {\n
\t// Set document vars if needed\n
\tif ( ( context.ownerDocument || context ) !== document ) {\n
\t\tsetDocument( context );\n
\t}\n
\treturn contains( context, elem );\n
};\n
\n
Sizzle.attr = function( elem, name ) {\n
\t// Set document vars if needed\n
\tif ( ( elem.ownerDocument || elem ) !== document ) {\n
\t\tsetDocument( elem );\n
\t}\n
\n
\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n
\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n
\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n
\t\t\tfn( elem, name, !documentIsHTML ) :\n
\t\t\tundefined;\n
\n
\treturn val !== undefined ?\n
\t\tval :\n
\t\tsupport.attributes || !documentIsHTML ?\n
\t\t\telem.getAttribute( name ) :\n
\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n
\t\t\t\tval.value :\n
\t\t\t\tnull;\n
};\n
\n
Sizzle.error = function( msg ) {\n
\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n
};\n
\n
/**\n
 * Document sorting and removing duplicates\n
 * @param {ArrayLike} results\n
 */\n
Sizzle.uniqueSort = function( results ) {\n
\tvar elem,\n
\t\tduplicates = [],\n
\t\tj = 0,\n
\t\ti = 0;\n
\n
\t// Unless we *know* we can detect duplicates, assume their presence\n
\thasDuplicate = !support.detectDuplicates;\n
\tsortInput = !support.sortStable && results.slice( 0 );\n
\tresults.sort( sortOrder );\n
\n
\tif ( hasDuplicate ) {\n
\t\twhile ( (elem = results[i++]) ) {\n
\t\t\tif ( elem === results[ i ] ) {\n
\t\t\t\tj = duplicates.push( i );\n
\t\t\t}\n
\t\t}\n
\t\twhile ( j-- ) {\n
\t\t\tresults.splice( duplicates[ j ], 1 );\n
\t\t}\n
\t}\n
\n
\t// Clear input after sorting to release objects\n
\t// See https://github.com/jquery/sizzle/pull/225\n
\tsortInput = null;\n
\n
\treturn results;\n
};\n
\n
/**\n
 * Utility function for retrieving the text value of an array of DOM nodes\n
 * @param {Array|Element} elem\n
 */\n
getText = Sizzle.getText = function( elem ) {\n
\tvar node,\n
\t\tret = "",\n
\t\ti = 0,\n
\t\tnodeType = elem.nodeType;\n
\n
\tif ( !nodeType ) {\n
\t\t// If no nodeType, this is expected to be an array\n
\t\twhile ( (node = elem[i++]) ) {\n
\t\t\t// Do not traverse comment nodes\n
\t\t\tret += getText( node );\n
\t\t}\n
\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n
\t\t// Use textContent for elements\n
\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n
\t\tif ( typeof elem.textContent === "string" ) {\n
\t\t\treturn elem.textContent;\n
\t\t} else {\n
\t\t\t// Traverse its children\n
\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n
\t\t\t\tret += getText( elem );\n
\t\t\t}\n
\t\t}\n
\t} else if ( nodeType === 3 || nodeType === 4 ) {\n
\t\treturn elem.nodeValue;\n
\t}\n
\t// Do not include comment or processing instruction nodes\n
\n
\treturn ret;\n
};\n
\n
Expr = Sizzle.selectors = {\n
\n
\t// Can be adjusted by the user\n
\tcacheLength: 50,\n
\n
\tcreatePseudo: markFunction,\n
\n
\tmatch: matchExpr,\n
\n
\tattrHandle: {},\n
\n
\tfind: {},\n
\n
\trelative: {\n
\t\t">": { dir: "parentNode", first: true },\n
\t\t" ": { dir: "parentNode" },\n
\t\t"+": { dir: "previousSibling", first: true },\n
\t\t"~": { dir: "previousSibling" }\n
\t},\n
\n
\tpreFilter: {\n
\t\t"ATTR": function( match ) {\n
\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n
\n
\t\t\t// Move the given value to match[3] whether quoted or unquoted\n
\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n
\n
\t\t\tif ( match[2] === "~=" ) {\n
\t\t\t\tmatch[3] = " " + match[3] + " ";\n
\t\t\t}\n
\n
\t\t\treturn match.slice( 0, 4 );\n
\t\t},\n
\n
\t\t"CHILD": function( match ) {\n
\t\t\t/* matches from matchExpr["CHILD"]\n
\t\t\t\t1 type (only|nth|...)\n
\t\t\t\t2 what (child|of-type)\n
\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n
\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n
\t\t\t\t5 sign of xn-component\n
\t\t\t\t6 x of xn-component\n
\t\t\t\t7 sign of y-component\n
\t\t\t\t8 y of y-component\n
\t\t\t*/\n
\t\t\tmatch[1] = match[1].toLowerCase();\n
\n
\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n
\t\t\t\t// nth-* requires argument\n
\t\t\t\tif ( !match[3] ) {\n
\t\t\t\t\tSizzle.error( match[0] );\n
\t\t\t\t}\n
\n
\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n
\t\t\t\t// remember that false/true cast respectively to 0/1\n
\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n
\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n
\n
\t\t\t// other types prohibit arguments\n
\t\t\t} else if ( match[3] ) {\n
\t\t\t\tSizzle.error( match[0] );\n
\t\t\t}\n
\n
\t\t\treturn match;\n
\t\t},\n
\n
\t\t"PSEUDO": function( match ) {\n
\t\t\tvar excess,\n
\t\t\t\tunquoted = !match[6] && match[2];\n
\n
\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n
\t\t\t\treturn null;\n
\t\t\t}\n
\n
\t\t\t// Accept quoted arguments as-is\n
\t\t\tif ( match[3] ) {\n
\t\t\t\tmatch[2] = match[4] || match[5] || "";\n
\n
\t\t\t// Strip excess characters from unquoted arguments\n
\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n
\t\t\t\t// Get excess from tokenize (recursively)\n
\t\t\t\t(excess = tokenize( unquoted, true )) &&\n
\t\t\t\t// advance to the next closing parenthesis\n
\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n
\n
\t\t\t\t// excess is a negative index\n
\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n
\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n
\t\t\t}\n
\n
\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n
\t\t\treturn match.slice( 0, 3 );\n
\t\t}\n
\t},\n
\n
\tfilter: {\n
\n
\t\t"TAG": function( nodeNameSelector ) {\n
\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n
\t\t\treturn nodeNameSelector === "*" ?\n
\t\t\t\tfunction() { return true; } :\n
\t\t\t\tfunction( elem ) {\n
\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n
\t\t\t\t};\n
\t\t},\n
\n
\t\t"CLASS": function( className ) {\n
\t\t\tvar pattern = classCache[ className + " " ];\n
\n
\t\t\treturn pattern ||\n
\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n
\t\t\t\tclassCache( className, function( elem ) {\n
\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );\n
\t\t\t\t});\n
\t\t},\n
\n
\t\t"ATTR": function( name, operator, check ) {\n
\t\t\treturn function( elem ) {\n
\t\t\t\tvar result = Sizzle.attr( elem, name );\n
\n
\t\t\t\tif ( result == null ) {\n
\t\t\t\t\treturn operator === "!=";\n
\t\t\t\t}\n
\t\t\t\tif ( !operator ) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\tresult += "";\n
\n
\t\t\t\treturn operator === "=" ? result === check :\n
\t\t\t\t\toperator === "!=" ? result !== check :\n
\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n
\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n
\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n
\t\t\t\t\toperator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :\n
\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n
\t\t\t\t\tfalse;\n
\t\t\t};\n
\t\t},\n
\n
\t\t"CHILD": function( type, what, argument, first, last ) {\n
\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n
\t\t\t\tforward = type.slice( -4 ) !== "last",\n
\t\t\t\tofType = what === "of-type";\n
\n
\t\t\treturn first === 1 && last === 0 ?\n
\n
\t\t\t\t// Shortcut for :nth-*(n)\n
\t\t\t\tfunction( elem ) {\n
\t\t\t\t\treturn !!elem.parentNode;\n
\t\t\t\t} :\n
\n
\t\t\t\tfunction( elem, context, xml ) {\n
\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n
\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n
\t\t\t\t\t\tparent = elem.parentNode,\n
\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n
\t\t\t\t\t\tuseCache = !xml && !ofType;\n
\n
\t\t\t\t\tif ( parent ) {\n
\n
\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n
\t\t\t\t\t\tif ( simple ) {\n
\t\t\t\t\t\t\twhile ( dir ) {\n
\t\t\t\t\t\t\t\tnode = elem;\n
\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n
\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n
\t\t\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n
\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n
\n
\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n
\t\t\t\t\t\tif ( forward && useCache ) {\n
\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n
\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n
\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n
\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n
\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n
\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n
\n
\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n
\n
\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n
\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n
\n
\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n
\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n
\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Use previously-cached element index if available\n
\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n
\t\t\t\t\t\t\tdiff = cache[1];\n
\n
\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n
\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n
\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n
\n
\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n
\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n
\t\t\t\t\t\t\t\t\tif ( useCache ) {\n
\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n
\t\t\t\t\t\tdiff -= last;\n
\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\t\t},\n
\n
\t\t"PSEUDO": function( pseudo, argument ) {\n
\t\t\t// pseudo-class names are case-insensitive\n
\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n
\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n
\t\t\t// Remember that setFilters inherits from pseudos\n
\t\t\tvar args,\n
\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n
\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n
\n
\t\t\t// The user may use createPseudo to indicate that\n
\t\t\t// arguments are needed to create the filter function\n
\t\t\t// just as Sizzle does\n
\t\t\tif ( fn[ expando ] ) {\n
\t\t\t\treturn fn( argument );\n
\t\t\t}\n
\n
\t\t\t// But maintain support for old signatures\n
\t\t\tif ( fn.length > 1 ) {\n
\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n
\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n
\t\t\t\t\tmarkFunction(function( seed, matches ) {\n
\t\t\t\t\t\tvar idx,\n
\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n
\t\t\t\t\t\t\ti = matched.length;\n
\t\t\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n
\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}) :\n
\t\t\t\t\tfunction( elem ) {\n
\t\t\t\t\t\treturn fn( elem, 0, args );\n
\t\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\treturn fn;\n
\t\t}\n
\t},\n
\n
\tpseudos: {\n
\t\t// Potentially complex pseudos\n
\t\t"not": markFunction(function( selector ) {\n
\t\t\t// Trim the selector passed to compile\n
\t\t\t// to avoid treating leading and trailing\n
\t\t\t// spaces as combinators\n
\t\t\tvar input = [],\n
\t\t\t\tresults = [],\n
\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n
\n
\t\t\treturn matcher[ expando ] ?\n
\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n
\t\t\t\t\tvar elem,\n
\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n
\t\t\t\t\t\ti = seed.length;\n
\n
\t\t\t\t\t// Match elements unmatched by `matcher`\n
\t\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n
\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}) :\n
\t\t\t\tfunction( elem, context, xml ) {\n
\t\t\t\t\tinput[0] = elem;\n
\t\t\t\t\tmatcher( input, null, xml, results );\n
\t\t\t\t\treturn !results.pop();\n
\t\t\t\t};\n
\t\t}),\n
\n
\t\t"has": markFunction(function( selector ) {\n
\t\t\treturn function( elem ) {\n
\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n
\t\t\t};\n
\t\t}),\n
\n
\t\t"contains": markFunction(function( text ) {\n
\t\t\ttext = text.replace( runescape, funescape );\n
\t\t\treturn function( elem ) {\n
\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n
\t\t\t};\n
\t\t}),\n
\n
\t\t// "Whether an element is represented by a :lang() selector\n
\t\t// is based solely on the element\'s language value\n
\t\t// being equal to the identifier C,\n
\t\t// or beginning with the identifier C immediately followed by "-".\n
\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n
\t\t// The identifier C does not have to be a valid language name."\n
\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n
\t\t"lang": markFunction( function( lang ) {\n
\t\t\t// lang value must be a valid identifier\n
\t\t\tif ( !ridentifier.test(lang || "") ) {\n
\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n
\t\t\t}\n
\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n
\t\t\treturn function( elem ) {\n
\t\t\t\tvar elemLang;\n
\t\t\t\tdo {\n
\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n
\t\t\t\t\t\telem.lang :\n
\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n
\n
\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n
\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n
\t\t\t\t\t}\n
\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n
\t\t\t\treturn false;\n
\t\t\t};\n
\t\t}),\n
\n
\t\t// Miscellaneous\n
\t\t"target": function( elem ) {\n
\t\t\tvar hash = window.location && window.location.hash;\n
\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n
\t\t},\n
\n
\t\t"root": function( elem ) {\n
\t\t\treturn elem === docElem;\n
\t\t},\n
\n
\t\t"focus": function( elem ) {\n
\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n
\t\t},\n
\n
\t\t// Boolean properties\n
\t\t"enabled": function( elem ) {\n
\t\t\treturn elem.disabled === false;\n
\t\t},\n
\n
\t\t"disabled": function( elem ) {\n
\t\t\treturn elem.disabled === true;\n
\t\t},\n
\n
\t\t"checked": function( elem ) {\n
\t\t\t// In CSS3, :checked should return both checked and selected elements\n
\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n
\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n
\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n
\t\t},\n
\n
\t\t"selected": function( elem ) {\n
\t\t\t// Accessing this property makes selected-by-default\n
\t\t\t// options in Safari work properly\n
\t\t\tif ( elem.parentNode ) {\n
\t\t\t\telem.parentNode.selectedIndex;\n
\t\t\t}\n
\n
\t\t\treturn elem.selected === true;\n
\t\t},\n
\n
\t\t// Contents\n
\t\t"empty": function( elem ) {\n
\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n
\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n
\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n
\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n
\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n
\t\t\t\tif ( elem.nodeType < 6 ) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn true;\n
\t\t},\n
\n
\t\t"parent": function( elem ) {\n
\t\t\treturn !Expr.pseudos["empty"]( elem );\n
\t\t},\n
\n
\t\t// Element/input types\n
\t\t"header": function( elem ) {\n
\t\t\treturn rheader.test( elem.nodeName );\n
\t\t},\n
\n
\t\t"input": function( elem ) {\n
\t\t\treturn rinputs.test( elem.nodeName );\n
\t\t},\n
\n
\t\t"button": function( elem ) {\n
\t\t\tvar name = elem.nodeName.toLowerCase();\n
\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n
\t\t},\n
\n
\t\t"text": function( elem ) {\n
\t\t\tvar attr;\n
\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n
\t\t\t\telem.type === "text" &&\n
\n
\t\t\t\t// Support: IE<8\n
\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n
\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n
\t\t},\n
\n
\t\t// Position-in-collection\n
\t\t"first": createPositionalPseudo(function() {\n
\t\t\treturn [ 0 ];\n
\t\t}),\n
\n
\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n
\t\t\treturn [ length - 1 ];\n
\t\t}),\n
\n
\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n
\t\t\treturn [ argument < 0 ? argument + length : argument ];\n
\t\t}),\n
\n
\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n
\t\t\tvar i = 0;\n
\t\t\tfor ( ; i < length; i += 2 ) {\n
\t\t\t\tmatchIndexes.push( i );\n
\t\t\t}\n
\t\t\treturn matchIndexes;\n
\t\t}),\n
\n
\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n
\t\t\tvar i = 1;\n
\t\t\tfor ( ; i < length; i += 2 ) {\n
\t\t\t\tmatchIndexes.push( i );\n
\t\t\t}\n
\t\t\treturn matchIndexes;\n
\t\t}),\n
\n
\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n
\t\t\tvar i = argument < 0 ? argument + length : argument;\n
\t\t\tfor ( ; --i >= 0; ) {\n
\t\t\t\tmatchIndexes.push( i );\n
\t\t\t}\n
\t\t\treturn matchIndexes;\n
\t\t}),\n
\n
\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n
\t\t\tvar i = argument < 0 ? argument + length : argument;\n
\t\t\tfor ( ; ++i < length; ) {\n
\t\t\t\tmatchIndexes.push( i );\n
\t\t\t}\n
\t\t\treturn matchIndexes;\n
\t\t})\n
\t}\n
};\n
\n
Expr.pseudos["nth"] = Expr.pseudos["eq"];\n
\n
// Add button/input type pseudos\n
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n
\tExpr.pseudos[ i ] = createInputPseudo( i );\n
}\n
for ( i in { submit: true, reset: true } ) {\n
\tExpr.pseudos[ i ] = createButtonPseudo( i );\n
}\n
\n
// Easy API for creating new setFilters\n
function setFilters() {}\n
setFilters.prototype = Expr.filters = Expr.pseudos;\n
Expr.setFilters = new setFilters();\n
\n
tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n
\tvar matched, match, tokens, type,\n
\t\tsoFar, groups, preFilters,\n
\t\tcached = tokenCache[ selector + " " ];\n
\n
\tif ( cached ) {\n
\t\treturn parseOnly ? 0 : cached.slice( 0 );\n
\t}\n
\n
\tsoFar = selector;\n
\tgroups = [];\n
\tpreFilters = Expr.preFilter;\n
\n
\twhile ( soFar ) {\n
\n
\t\t// Comma and first run\n
\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n
\t\t\tif ( match ) {\n
\t\t\t\t// Don\'t consume trailing commas as valid\n
\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n
\t\t\t}\n
\t\t\tgroups.push( (tokens = []) );\n
\t\t}\n
\n
\t\tmatched = false;\n
\n
\t\t// Combinators\n
\t\tif ( (match = rcombinators.exec( soFar )) ) {\n
\t\t\tmatched = match.shift();\n
\t\t\ttokens.push({\n
\t\t\t\tvalue: matched,\n
\t\t\t\t// Cast descendant combinators to space\n
\t\t\t\ttype: match[0].replace( rtrim, " " )\n
\t\t\t});\n
\t\t\tsoFar = soFar.slice( matched.length );\n
\t\t}\n
\n
\t\t// Filters\n
\t\tfor ( type in Expr.filter ) {\n
\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n
\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n
\t\t\t\tmatched = match.shift();\n
\t\t\t\ttokens.push({\n
\t\t\t\t\tvalue: matched,\n
\t\t\t\t\ttype: type,\n
\t\t\t\t\tmatches: match\n
\t\t\t\t});\n
\t\t\t\tsoFar = soFar.slice( matched.length );\n
\t\t\t}\n
\t\t}\n
\n
\t\tif ( !matched ) {\n
\t\t\tbreak;\n
\t\t}\n
\t}\n
\n
\t// Return the length of the invalid excess\n
\t// if we\'re just parsing\n
\t// Otherwise, throw an error or return tokens\n
\treturn parseOnly ?\n
\t\tsoFar.length :\n
\t\tsoFar ?\n
\t\t\tSizzle.error( selector ) :\n
\t\t\t// Cache the tokens\n
\t\t\ttokenCache( selector, groups ).slice( 0 );\n
};\n
\n
function toSelector( tokens ) {\n
\tvar i = 0,\n
\t\tlen = tokens.length,\n
\t\tselector = "";\n
\tfor ( ; i < len; i++ ) {\n
\t\tselector += tokens[i].value;\n
\t}\n
\treturn selector;\n
}\n
\n
function addCombinator( matcher, combinator, base ) {\n
\tvar dir = combinator.dir,\n
\t\tcheckNonElements = base && dir === "parentNode",\n
\t\tdoneName = done++;\n
\n
\treturn combinator.first ?\n
\t\t// Check against closest ancestor/preceding element\n
\t\tfunction( elem, context, xml ) {\n
\t\t\twhile ( (elem = elem[ dir ]) ) {\n
\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n
\t\t\t\t\treturn matcher( elem, context, xml );\n
\t\t\t\t}\n
\t\t\t}\n
\t\t} :\n
\n
\t\t// Check against all ancestor/preceding elements\n
\t\tfunction( elem, context, xml ) {\n
\t\t\tvar oldCache, outerCache,\n
\t\t\t\tnewCache = [ dirruns, doneName ];\n
\n
\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from dir caching\n
\t\t\tif ( xml ) {\n
\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n
\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n
\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n
\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n
\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n
\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n
\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n
\n
\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n
\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n
\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n
\n
\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n
\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n
\t\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
}\n
\n
function elementMatcher( matchers ) {\n
\treturn matchers.length > 1 ?\n
\t\tfunction( elem, context, xml ) {\n
\t\t\tvar i = matchers.length;\n
\t\t\twhile ( i-- ) {\n
\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn true;\n
\t\t} :\n
\t\tmatchers[0];\n
}\n
\n
function multipleContexts( selector, contexts, results ) {\n
\tvar i = 0,\n
\t\tlen = contexts.length;\n
\tfor ( ; i < len; i++ ) {\n
\t\tSizzle( selector, contexts[i], results );\n
\t}\n
\treturn results;\n
}\n
\n
function condense( unmatched, map, filter, context, xml ) {\n
\tvar elem,\n
\t\tnewUnmatched = [],\n
\t\ti = 0,\n
\t\tlen = unmatched.length,\n
\t\tmapped = map != null;\n
\n
\tfor ( ; i < len; i++ ) {\n
\t\tif ( (elem = unmatched[i]) ) {\n
\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n
\t\t\t\tnewUnmatched.push( elem );\n
\t\t\t\tif ( mapped ) {\n
\t\t\t\t\tmap.push( i );\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\treturn newUnmatched;\n
}\n
\n
function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n
\tif ( postFilter && !postFilter[ expando ] ) {\n
\t\tpostFilter = setMatcher( postFilter );\n
\t}\n
\tif ( postFinder && !postFinder[ expando ] ) {\n
\t\tpostFinder = setMatcher( postFinder, postSelector );\n
\t}\n
\treturn markFunction(function( seed, results, context, xml ) {\n
\t\tvar temp, i, elem,\n
\t\t\tpreMap = [],\n
\t\t\tpostMap = [],\n
\t\t\tpreexisting = results.length,\n
\n
\t\t\t// Get initial elements from seed or context\n
\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n
\n
\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n
\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n
\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n
\t\t\t\telems,\n
\n
\t\t\tmatcherOut = matcher ?\n
\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n
\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n
\n
\t\t\t\t\t// ...intermediate processing is necessary\n
\t\t\t\t\t[] :\n
\n
\t\t\t\t\t// ...otherwise use results directly\n
\t\t\t\t\tresults :\n
\t\t\t\tmatcherIn;\n
\n
\t\t// Find primary matches\n
\t\tif ( matcher ) {\n
\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n
\t\t}\n
\n
\t\t// Apply postFilter\n
\t\tif ( postFilter ) {\n
\t\t\ttemp = condense( matcherOut, postMap );\n
\t\t\tpostFilter( temp, [], context, xml );\n
\n
\t\t\t// Un-match failing elements by moving them back to matcherIn\n
\t\t\ti = temp.length;\n
\t\t\twhile ( i-- ) {\n
\t\t\t\tif ( (elem = temp[i]) ) {\n
\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tif ( seed ) {\n
\t\t\tif ( postFinder || preFilter ) {\n
\t\t\t\tif ( postFinder ) {\n
\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n
\t\t\t\t\ttemp = [];\n
\t\t\t\t\ti = matcherOut.length;\n
\t\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n
\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n
\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n
\t\t\t\t}\n
\n
\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n
\t\t\t\ti = matcherOut.length;\n
\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n
\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n
\n
\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t// Add elements to results, through postFinder if defined\n
\t\t} else {\n
\t\t\tmatcherOut = condense(\n
\t\t\t\tmatcherOut === results ?\n
\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n
\t\t\t\t\tmatcherOut\n
\t\t\t);\n
\t\t\tif ( postFinder ) {\n
\t\t\t\tpostFinder( null, results, matcherOut, xml );\n
\t\t\t} else {\n
\t\t\t\tpush.apply( results, matcherOut );\n
\t\t\t}\n
\t\t}\n
\t});\n
}\n
\n
function matcherFromTokens( tokens ) {\n
\tvar checkContext, matcher, j,\n
\t\tlen = tokens.length,\n
\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n
\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n
\t\ti = leadingRelative ? 1 : 0,\n
\n
\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n
\t\tmatchContext = addCombinator( function( elem ) {\n
\t\t\treturn elem === checkContext;\n
\t\t}, implicitRelative, true ),\n
\t\tmatchAnyContext = addCombinator( function( elem ) {\n
\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n
\t\t}, implicitRelative, true ),\n
\t\tmatchers = [ function( elem, context, xml ) {\n
\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n
\t\t\t\t(checkContext = context).nodeType ?\n
\t\t\t\t\tmatchContext( elem, context, xml ) :\n
\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n
\t\t} ];\n
\n
\tfor ( ; i < len; i++ ) {\n
\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n
\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n
\t\t} else {\n
\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n
\n
\t\t\t// Return special upon seeing a positional matcher\n
\t\t\tif ( matcher[ expando ] ) {\n
\t\t\t\t// Find the next relative operator (if any) for proper handling\n
\t\t\t\tj = ++i;\n
\t\t\t\tfor ( ; j < len; j++ ) {\n
\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t\treturn setMatcher(\n
\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n
\t\t\t\t\ti > 1 && toSelector(\n
\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n
\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n
\t\t\t\t\t).replace( rtrim, "$1" ),\n
\t\t\t\t\tmatcher,\n
\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n
\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n
\t\t\t\t\tj < len && toSelector( tokens )\n
\t\t\t\t);\n
\t\t\t}\n
\t\t\tmatchers.push( matcher );\n
\t\t}\n
\t}\n
\n
\treturn elementMatcher( matchers );\n
}\n
\n
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n
\tvar bySet = setMatchers.length > 0,\n
\t\tbyElement = elementMatchers.length > 0,\n
\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n
\t\t\tvar elem, j, matcher,\n
\t\t\t\tmatchedCount = 0,\n
\t\t\t\ti = "0",\n
\t\t\t\tunmatched = seed && [],\n
\t\t\t\tsetMatched = [],\n
\t\t\t\tcontextBackup = outermostContext,\n
\t\t\t\t// We must always have either seed elements or outermost context\n
\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n
\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n
\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n
\t\t\t\tlen = elems.length;\n
\n
\t\t\tif ( outermost ) {\n
\t\t\t\toutermostContext = context !== document && context;\n
\t\t\t}\n
\n
\t\t\t// Add elements passing elementMatchers directly to results\n
\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be "00" below\n
\t\t\t// Support: IE<9, Safari\n
\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n
\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n
\t\t\t\tif ( byElement && elem ) {\n
\t\t\t\t\tj = 0;\n
\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n
\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n
\t\t\t\t\t\t\tresults.push( elem );\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t\tif ( outermost ) {\n
\t\t\t\t\t\tdirruns = dirrunsUnique;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Track unmatched elements for set filters\n
\t\t\t\tif ( bySet ) {\n
\t\t\t\t\t// They will have gone through all possible matchers\n
\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n
\t\t\t\t\t\tmatchedCount--;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Lengthen the array for every element, matched or not\n
\t\t\t\t\tif ( seed ) {\n
\t\t\t\t\t\tunmatched.push( elem );\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Apply set filters to unmatched elements\n
\t\t\tmatchedCount += i;\n
\t\t\tif ( bySet && i !== matchedCount ) {\n
\t\t\t\tj = 0;\n
\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n
\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n
\t\t\t\t}\n
\n
\t\t\t\tif ( seed ) {\n
\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n
\t\t\t\t\tif ( matchedCount > 0 ) {\n
\t\t\t\t\t\twhile ( i-- ) {\n
\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n
\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Discard index placeholder values to get only actual matches\n
\t\t\t\t\tsetMatched = condense( setMatched );\n
\t\t\t\t}\n
\n
\t\t\t\t// Add matches to results\n
\t\t\t\tpush.apply( results, setMatched );\n
\n
\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n
\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n
\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n
\n
\t\t\t\t\tSizzle.uniqueSort( results );\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Override manipulation of globals by nested matchers\n
\t\t\tif ( outermost ) {\n
\t\t\t\tdirruns = dirrunsUnique;\n
\t\t\t\toutermostContext = contextBackup;\n
\t\t\t}\n
\n
\t\t\treturn unmatched;\n
\t\t};\n
\n
\treturn bySet ?\n
\t\tmarkFunction( superMatcher ) :\n
\t\tsuperMatcher;\n
}\n
\n
compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n
\tvar i,\n
\t\tsetMatchers = [],\n
\t\telementMatchers = [],\n
\t\tcached = compilerCache[ selector + " " ];\n
\n
\tif ( !cached ) {\n
\t\t// Generate a function of recursive functions that can be used to check each element\n
\t\tif ( !match ) {\n
\t\t\tmatch = tokenize( selector );\n
\t\t}\n
\t\ti = match.length;\n
\t\twhile ( i-- ) {\n
\t\t\tcached = matcherFromTokens( match[i] );\n
\t\t\tif ( cached[ expando ] ) {\n
\t\t\t\tsetMatchers.push( cached );\n
\t\t\t} else {\n
\t\t\t\telementMatchers.push( cached );\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Cache the compiled function\n
\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n
\n
\t\t// Save selector and tokenization\n
\t\tcached.selector = selector;\n
\t}\n
\treturn cached;\n
};\n
\n
/**\n
 * A low-level selection function that works with Sizzle\'s compiled\n
 *  selector functions\n
 * @param {String|Function} selector A selector or a pre-compiled\n
 *  selector function built with Sizzle.compile\n
 * @param {Element} context\n
 * @param {Array} [results]\n
 * @param {Array} [seed] A set of elements to match against\n
 */\n
select = Sizzle.select = function( selector, context, results, seed ) {\n
\tvar i, tokens, token, type, find,\n
\t\tcompiled = typeof selector === "function" && selector,\n
\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n
\n
\tresults = results || [];\n
\n
\t// Try to minimize operations if there is no seed and only one group\n
\tif ( match.length === 1 ) {\n
\n
\t\t// Take a shortcut and set the context if the root selector is an ID\n
\t\ttokens = match[0] = match[0].slice( 0 );\n
\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n
\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n
\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n
\n
\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n
\t\t\tif ( !context ) {\n
\t\t\t\treturn results;\n
\n
\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n
\t\t\t} else if ( compiled ) {\n
\t\t\t\tcontext = context.parentNode;\n
\t\t\t}\n
\n
\t\t\tselector = selector.slice( tokens.shift().value.length );\n
\t\t}\n
\n
\t\t// Fetch a seed set for right-to-left matching\n
\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n
\t\twhile ( i-- ) {\n
\t\t\ttoken = tokens[i];\n
\n
\t\t\t// Abort if we hit a combinator\n
\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t\tif ( (find = Expr.find[ type ]) ) {\n
\t\t\t\t// Search, expanding context for leading sibling combinators\n
\t\t\t\tif ( (seed = find(\n
\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n
\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n
\t\t\t\t)) ) {\n
\n
\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n
\t\t\t\t\ttokens.splice( i, 1 );\n
\t\t\t\t\tselector = seed.length && toSelector( tokens );\n
\t\t\t\t\tif ( !selector ) {\n
\t\t\t\t\t\tpush.apply( results, seed );\n
\t\t\t\t\t\treturn results;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\t// Compile and execute a filtering function if one is not provided\n
\t// Provide `match` to avoid retokenization if we modified the selector above\n
\t( compiled || compile( selector, match ) )(\n
\t\tseed,\n
\t\tcontext,\n
\t\t!documentIsHTML,\n
\t\tresults,\n
\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n
\t);\n
\treturn results;\n
};\n
\n
// One-time assignments\n
\n
// Sort stability\n
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n
\n
// Support: Chrome 14-35+\n
// Always assume duplicates if they aren\'t passed to the comparison function\n
support.detectDuplicates = !!hasDuplicate;\n
\n
// Initialize against the default document\n
setDocument();\n
\n
// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n
// Detached nodes confoundingly follow *each other*\n
support.sortDetached = assert(function( div1 ) {\n
\t// Should return 1, but returns 4 (following)\n
\treturn div1.compareDocumentPosition( document.createElement("div") ) & 1;\n
});\n
\n
// Support: IE<8\n
// Prevent attribute/property "interpolation"\n
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n
if ( !assert(function( div ) {\n
\tdiv.innerHTML = "<a href=\'#\'></a>";\n
\treturn div.firstChild.getAttribute("href") === "#" ;\n
}) ) {\n
\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n
\t\tif ( !isXML ) {\n
\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n
\t\t}\n
\t});\n
}\n
\n
// Support: IE<9\n
// Use defaultValue in place of getAttribute("value")\n
if ( !support.attributes || !assert(function( div ) {\n
\tdiv.innerHTML = "<input/>";\n
\tdiv.firstChild.setAttribute( "value", "" );\n
\treturn div.firstChild.getAttribute( "value" ) === "";\n
}) ) {\n
\taddHandle( "value", function( elem, name, isXML ) {\n
\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n
\t\t\treturn elem.defaultValue;\n
\t\t}\n
\t});\n
}\n
\n
// Support: IE<9\n
// Use getAttributeNode to fetch booleans when getAttribute lies\n
if ( !assert(function( div ) {\n
\treturn div.getAttribute("disabled") == null;\n
}) ) {\n
\taddHandle( booleans, function( elem, name, isXML ) {\n
\t\tvar val;\n
\t\tif ( !isXML ) {\n
\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n
\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n
\t\t\t\t\tval.value :\n
\t\t\t\tnull;\n
\t\t}\n
\t});\n
}\n
\n
// EXPOSE\n
return Sizzle;\n
});\n
\n
/*eslint-enable */\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>57939</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Sizzle.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
