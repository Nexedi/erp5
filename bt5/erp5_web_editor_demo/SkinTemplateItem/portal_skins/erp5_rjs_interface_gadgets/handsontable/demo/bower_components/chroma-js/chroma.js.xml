<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272298.4</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>chroma.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// Generated by CoffeeScript 1.6.2\n
/**\n
 * @license\n
 *\n
 * chroma.js - JavaScript library for color conversions\n
 * \n
 * Copyright (c) 2011-2013, Gregor Aisch\n
 * All rights reserved.\n
 * \n
 * Redistribution and use in source and binary forms, with or without\n
 * modification, are permitted provided that the following conditions are met:\n
 * \n
 * 1. Redistributions of source code must retain the above copyright notice, this\n
 * list of conditions and the following disclaimer.\n
 * \n
 * 2. Redistributions in binary form must reproduce the above copyright notice,\n
 * this list of conditions and the following disclaimer in the documentation\n
 * and/or other materials provided with the distribution.\n
 * \n
 * 3. The name Gregor Aisch may not be used to endorse or promote products\n
 * derived from this software without specific prior written permission.\n
 * \n
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
*/\n
\n
\n
(function() {\n
  var Color, K, PITHIRD, TWOPI, X, Y, Z, bezier, brewer, chroma, clip_rgb, colors, cos, css2rgb, hex2rgb, hsi2rgb, hsl2rgb, hsv2rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, limit, luminance, luminance_x, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb_xyz, root, type, unpack, xyz_lab, xyz_rgb, _ref;\n
\n
  chroma = function(x, y, z, m) {\n
    return new Color(x, y, z, m);\n
  };\n
\n
  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {\n
    module.exports = chroma;\n
  }\n
\n
  if (typeof define === \'function\' && define.amd) {\n
    define([], function() {\n
      return chroma;\n
    });\n
  } else {\n
    root = typeof exports !== "undefined" && exports !== null ? exports : this;\n
    root.chroma = chroma;\n
  }\n
\n
  chroma.color = function(x, y, z, m) {\n
    return new Color(x, y, z, m);\n
  };\n
\n
  chroma.hsl = function(h, s, l, a) {\n
    return new Color(h, s, l, a, \'hsl\');\n
  };\n
\n
  chroma.hsv = function(h, s, v, a) {\n
    return new Color(h, s, v, a, \'hsv\');\n
  };\n
\n
  chroma.rgb = function(r, g, b, a) {\n
    return new Color(r, g, b, a, \'rgb\');\n
  };\n
\n
  chroma.hex = function(x) {\n
    return new Color(x);\n
  };\n
\n
  chroma.css = function(x) {\n
    return new Color(x);\n
  };\n
\n
  chroma.lab = function(l, a, b) {\n
    return new Color(l, a, b, \'lab\');\n
  };\n
\n
  chroma.lch = function(l, c, h) {\n
    return new Color(l, c, h, \'lch\');\n
  };\n
\n
  chroma.hsi = function(h, s, i) {\n
    return new Color(h, s, i, \'hsi\');\n
  };\n
\n
  chroma.gl = function(r, g, b, a) {\n
    return new Color(r * 255, g * 255, b * 255, a, \'gl\');\n
  };\n
\n
  chroma.interpolate = function(a, b, f, m) {\n
    if ((a == null) || (b == null)) {\n
      return \'#000\';\n
    }\n
    if (type(a) === \'string\') {\n
      a = new Color(a);\n
    }\n
    if (type(b) === \'string\') {\n
      b = new Color(b);\n
    }\n
    return a.interpolate(f, b, m);\n
  };\n
\n
  chroma.mix = chroma.interpolate;\n
\n
  chroma.contrast = function(a, b) {\n
    var l1, l2;\n
\n
    if (type(a) === \'string\') {\n
      a = new Color(a);\n
    }\n
    if (type(b) === \'string\') {\n
      b = new Color(b);\n
    }\n
    l1 = a.luminance();\n
    l2 = b.luminance();\n
    if (l1 > l2) {\n
      return (l1 + 0.05) / (l2 + 0.05);\n
    } else {\n
      return (l2 + 0.05) / (l1 + 0.05);\n
    }\n
  };\n
\n
  chroma.luminance = function(color) {\n
    return chroma(color).luminance();\n
  };\n
\n
  chroma._Color = Color;\n
\n
  /**\n
      chroma.js\n
  \n
      Copyright (c) 2011-2013, Gregor Aisch\n
      All rights reserved.\n
  \n
      Redistribution and use in source and binary forms, with or without\n
      modification, are permitted provided that the following conditions are met:\n
  \n
      * Redistributions of source code must retain the above copyright notice, this\n
        list of conditions and the following disclaimer.\n
  \n
      * Redistributions in binary form must reproduce the above copyright notice,\n
        this list of conditions and the following disclaimer in the documentation\n
        and/or other materials provided with the distribution.\n
  \n
      * The name Gregor Aisch may not be used to endorse or promote products\n
        derived from this software without specific prior written permission.\n
  \n
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
  \n
      @source: https://github.com/gka/chroma.js\n
  */\n
\n
\n
  Color = (function() {\n
    function Color() {\n
      var a, arg, args, m, me, me_rgb, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3;\n
\n
      me = this;\n
      args = [];\n
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n
        arg = arguments[_i];\n
        if (arg != null) {\n
          args.push(arg);\n
        }\n
      }\n
      if (args.length === 0) {\n
        _ref = [255, 0, 255, 1, \'rgb\'], x = _ref[0], y = _ref[1], z = _ref[2], a = _ref[3], m = _ref[4];\n
      } else if (type(args[0]) === "array") {\n
        if (args[0].length === 3) {\n
          _ref1 = args[0], x = _ref1[0], y = _ref1[1], z = _ref1[2];\n
          a = 1;\n
        } else if (args[0].length === 4) {\n
          _ref2 = args[0], x = _ref2[0], y = _ref2[1], z = _ref2[2], a = _ref2[3];\n
        } else {\n
          throw \'unknown input argument\';\n
        }\n
        m = args[1];\n
      } else if (type(args[0]) === "string") {\n
        x = args[0];\n
        m = \'hex\';\n
      } else if (type(args[0]) === "object") {\n
        _ref3 = args[0]._rgb, x = _ref3[0], y = _ref3[1], z = _ref3[2], a = _ref3[3];\n
        m = \'rgb\';\n
      } else if (args.length >= 3) {\n
        x = args[0];\n
        y = args[1];\n
        z = args[2];\n
      }\n
      if (args.length === 3) {\n
        m = \'rgb\';\n
        a = 1;\n
      } else if (args.length === 4) {\n
        if (type(args[3]) === "string") {\n
          m = args[3];\n
          a = 1;\n
        } else if (type(args[3]) === "number") {\n
          m = \'rgb\';\n
          a = args[3];\n
        }\n
      } else if (args.length === 5) {\n
        a = args[3];\n
        m = args[4];\n
      }\n
      if (a == null) {\n
        a = 1;\n
      }\n
      if (m === \'rgb\') {\n
        me._rgb = [x, y, z, a];\n
      } else if (m === \'gl\') {\n
        me._rgb = [x * 255, y * 255, z * 255, a];\n
      } else if (m === \'hsl\') {\n
        me._rgb = hsl2rgb(x, y, z);\n
        me._rgb[3] = a;\n
      } else if (m === \'hsv\') {\n
        me._rgb = hsv2rgb(x, y, z);\n
        me._rgb[3] = a;\n
      } else if (m === \'hex\') {\n
        me._rgb = hex2rgb(x);\n
      } else if (m === \'lab\') {\n
        me._rgb = lab2rgb(x, y, z);\n
        me._rgb[3] = a;\n
      } else if (m === \'lch\') {\n
        me._rgb = lch2rgb(x, y, z);\n
        me._rgb[3] = a;\n
      } else if (m === \'hsi\') {\n
        me._rgb = hsi2rgb(x, y, z);\n
        me._rgb[3] = a;\n
      }\n
      me_rgb = clip_rgb(me._rgb);\n
    }\n
\n
    Color.prototype.rgb = function() {\n
      return this._rgb.slice(0, 3);\n
    };\n
\n
    Color.prototype.rgba = function() {\n
      return this._rgb;\n
    };\n
\n
    Color.prototype.hex = function() {\n
      return rgb2hex(this._rgb);\n
    };\n
\n
    Color.prototype.toString = function() {\n
      return this.name();\n
    };\n
\n
    Color.prototype.hsl = function() {\n
      return rgb2hsl(this._rgb);\n
    };\n
\n
    Color.prototype.hsv = function() {\n
      return rgb2hsv(this._rgb);\n
    };\n
\n
    Color.prototype.lab = function() {\n
      return rgb2lab(this._rgb);\n
    };\n
\n
    Color.prototype.lch = function() {\n
      return rgb2lch(this._rgb);\n
    };\n
\n
    Color.prototype.hsi = function() {\n
      return rgb2hsi(this._rgb);\n
    };\n
\n
    Color.prototype.gl = function() {\n
      return [this._rgb[0] / 255, this._rgb[1] / 255, this._rgb[2] / 255, this._rgb[3]];\n
    };\n
\n
    Color.prototype.luminance = function() {\n
      return luminance(this._rgb);\n
    };\n
\n
    Color.prototype.name = function() {\n
      var h, k;\n
\n
      h = this.hex();\n
      for (k in chroma.colors) {\n
        if (h === chroma.colors[k]) {\n
          return k;\n
        }\n
      }\n
      return h;\n
    };\n
\n
    Color.prototype.alpha = function(alpha) {\n
      if (arguments.length) {\n
        this._rgb[3] = alpha;\n
        return this;\n
      }\n
      return this._rgb[3];\n
    };\n
\n
    Color.prototype.css = function(mode) {\n
      var hsl, me, rgb, rnd;\n
\n
      if (mode == null) {\n
        mode = \'rgb\';\n
      }\n
      me = this;\n
      rgb = me._rgb;\n
      if (mode.length === 3 && rgb[3] < 1) {\n
        mode += \'a\';\n
      }\n
      if (mode === \'rgb\') {\n
        return mode + \'(\' + rgb.slice(0, 3).join(\',\') + \')\';\n
      } else if (mode === \'rgba\') {\n
        return mode + \'(\' + rgb.join(\',\') + \')\';\n
      } else if (mode === \'hsl\' || mode === \'hsla\') {\n
        hsl = me.hsl();\n
        rnd = function(a) {\n
          return Math.round(a * 100) / 100;\n
        };\n
        hsl[0] = rnd(hsl[0]);\n
        hsl[1] = rnd(hsl[1] * 100) + \'%\';\n
        hsl[2] = rnd(hsl[2] * 100) + \'%\';\n
        if (mode.length === 4) {\n
          hsl[3] = rgb[3];\n
        }\n
        return mode + \'(\' + hsl.join(\',\') + \')\';\n
      }\n
    };\n
\n
    Color.prototype.interpolate = function(f, col, m) {\n
      /*\n
      interpolates between colors\n
      f = 0 --> me\n
      f = 1 --> col\n
      */\n
\n
      var dh, hue, hue0, hue1, lbv, lbv0, lbv1, me, res, sat, sat0, sat1, xyz0, xyz1;\n
\n
      me = this;\n
      if (m == null) {\n
        m = \'rgb\';\n
      }\n
      if (type(col) === "string") {\n
        col = new Color(col);\n
      }\n
      if (m === \'hsl\' || m === \'hsv\' || m === \'lch\' || m === \'hsi\') {\n
        if (m === \'hsl\') {\n
          xyz0 = me.hsl();\n
          xyz1 = col.hsl();\n
        } else if (m === \'hsv\') {\n
          xyz0 = me.hsv();\n
          xyz1 = col.hsv();\n
        } else if (m === \'hsi\') {\n
          xyz0 = me.hsi();\n
          xyz1 = col.hsi();\n
        } else if (m === \'lch\') {\n
          xyz0 = me.lch();\n
          xyz1 = col.lch();\n
        }\n
        if (m.substr(0, 1) === \'h\') {\n
          hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];\n
          hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];\n
        } else {\n
          lbv0 = xyz0[0], sat0 = xyz0[1], hue0 = xyz0[2];\n
          lbv1 = xyz1[0], sat1 = xyz1[1], hue1 = xyz1[2];\n
        }\n
        if (!isNaN(hue0) && !isNaN(hue1)) {\n
          if (hue1 > hue0 && hue1 - hue0 > 180) {\n
            dh = hue1 - (hue0 + 360);\n
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n
            dh = hue1 + 360 - hue0;\n
          } else {\n
            dh = hue1 - hue0;\n
          }\n
          hue = hue0 + f * dh;\n
        } else if (!isNaN(hue0)) {\n
          hue = hue0;\n
          if (lbv1 === 1 || lbv1 === 0) {\n
            sat = sat0;\n
          }\n
        } else if (!isNaN(hue1)) {\n
          hue = hue1;\n
          if (lbv0 === 1 || lbv0 === 0) {\n
            sat = sat1;\n
          }\n
        } else {\n
          hue = Number.NaN;\n
        }\n
        if (sat == null) {\n
          sat = sat0 + f * (sat1 - sat0);\n
        }\n
        lbv = lbv0 + f * (lbv1 - lbv0);\n
        if (m.substr(0, 1) === \'h\') {\n
          res = new Color(hue, sat, lbv, m);\n
        } else {\n
          res = new Color(lbv, sat, hue, m);\n
        }\n
      } else if (m === \'rgb\') {\n
        xyz0 = me._rgb;\n
        xyz1 = col._rgb;\n
        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);\n
      } else if (m === \'lab\') {\n
        xyz0 = me.lab();\n
        xyz1 = col.lab();\n
        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);\n
      } else {\n
        throw "color mode " + m + " is not supported";\n
      }\n
      res.alpha(me.alpha() + f * (col.alpha() - me.alpha()));\n
      return res;\n
    };\n
\n
    Color.prototype.premultiply = function() {\n
      var a, rgb;\n
\n
      rgb = this.rgb();\n
      a = this.alpha();\n
      return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);\n
    };\n
\n
    Color.prototype.darken = function(amount) {\n
      var lch, me;\n
\n
      if (amount == null) {\n
        amount = 20;\n
      }\n
      me = this;\n
      lch = me.lch();\n
      lch[0] -= amount;\n
      return chroma.lch(lch).alpha(me.alpha());\n
    };\n
\n
    Color.prototype.darker = function(amount) {\n
      return this.darken(amount);\n
    };\n
\n
    Color.prototype.brighten = function(amount) {\n
      if (amount == null) {\n
        amount = 20;\n
      }\n
      return this.darken(-amount);\n
    };\n
\n
    Color.prototype.brighter = function(amount) {\n
      return this.brighten(amount);\n
    };\n
\n
    Color.prototype.saturate = function(amount) {\n
      var lch, me;\n
\n
      if (amount == null) {\n
        amount = 20;\n
      }\n
      me = this;\n
      lch = me.lch();\n
      lch[1] += amount;\n
      return chroma.lch(lch).alpha(me.alpha());\n
    };\n
\n
    Color.prototype.desaturate = function(amount) {\n
      if (amount == null) {\n
        amount = 20;\n
      }\n
      return this.saturate(-amount);\n
    };\n
\n
    return Color;\n
\n
  })();\n
\n
  clip_rgb = function(rgb) {\n
    var i;\n
\n
    for (i in rgb) {\n
      if (i < 3) {\n
        if (rgb[i] < 0) {\n
          rgb[i] = 0;\n
        }\n
        if (rgb[i] > 255) {\n
          rgb[i] = 255;\n
        }\n
      } else if (i === 3) {\n
        if (rgb[i] < 0) {\n
          rgb[i] = 0;\n
        }\n
        if (rgb[i] > 1) {\n
          rgb[i] = 1;\n
        }\n
      }\n
    }\n
    return rgb;\n
  };\n
\n
  css2rgb = function(css) {\n
    var hsl, i, m, rgb, _i, _j, _k, _l;\n
\n
    if ((chroma.colors != null) && chroma.colors[css]) {\n
      return hex2rgb(chroma.colors[css]);\n
    }\n
    if (m = css.match(/rgb\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*\\)/)) {\n
      rgb = m.slice(1, 4);\n
      for (i = _i = 0; _i <= 2; i = ++_i) {\n
        rgb[i] = +rgb[i];\n
      }\n
      rgb[3] = 1;\n
    } else if (m = css.match(/rgba\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n
      rgb = m.slice(1, 5);\n
      for (i = _j = 0; _j <= 3; i = ++_j) {\n
        rgb[i] = +rgb[i];\n
      }\n
    } else if (m = css.match(/rgb\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) {\n
      rgb = m.slice(1, 4);\n
      for (i = _k = 0; _k <= 2; i = ++_k) {\n
        rgb[i] = Math.round(rgb[i] * 2.55);\n
      }\n
      rgb[3] = 1;\n
    } else if (m = css.match(/rgba\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n
      rgb = m.slice(1, 5);\n
      for (i = _l = 0; _l <= 2; i = ++_l) {\n
        rgb[i] = Math.round(rgb[i] * 2.55);\n
      }\n
      rgb[3] = +rgb[3];\n
    } else if (m = css.match(/hsl\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) {\n
      hsl = m.slice(1, 4);\n
      hsl[1] *= 0.01;\n
      hsl[2] *= 0.01;\n
      rgb = hsl2rgb(hsl);\n
      rgb[3] = 1;\n
    } else if (m = css.match(/hsla\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n
      hsl = m.slice(1, 4);\n
      hsl[1] *= 0.01;\n
      hsl[2] *= 0.01;\n
      rgb = hsl2rgb(hsl);\n
      rgb[3] = +m[4];\n
    }\n
    return rgb;\n
  };\n
\n
  hex2rgb = function(hex) {\n
    var a, b, g, r, rgb, u;\n
\n
    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {\n
      if (hex.length === 4 || hex.length === 7) {\n
        hex = hex.substr(1);\n
      }\n
      if (hex.length === 3) {\n
        hex = hex.split("");\n
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n
      }\n
      u = parseInt(hex, 16);\n
      r = u >> 16;\n
      g = u >> 8 & 0xFF;\n
      b = u & 0xFF;\n
      return [r, g, b, 1];\n
    }\n
    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {\n
      if (hex.length === 9) {\n
        hex = hex.substr(1);\n
      }\n
      u = parseInt(hex, 16);\n
      r = u >> 24 & 0xFF;\n
      g = u >> 16 & 0xFF;\n
      b = u >> 8 & 0xFF;\n
      a = u & 0xFF;\n
      return [r, g, b, a];\n
    }\n
    if (rgb = css2rgb(hex)) {\n
      return rgb;\n
    }\n
    throw "unknown color: " + hex;\n
  };\n
\n
  hsi2rgb = function(h, s, i) {\n
    /*\n
    borrowed from here:\n
    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n
    */\n
\n
    var b, g, r, _ref;\n
\n
    _ref = unpack(arguments), h = _ref[0], s = _ref[1], i = _ref[2];\n
    h /= 360;\n
    if (h < 1 / 3) {\n
      b = (1 - s) / 3;\n
      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n
      g = 1 - (b + r);\n
    } else if (h < 2 / 3) {\n
      h -= 1 / 3;\n
      r = (1 - s) / 3;\n
      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n
      b = 1 - (r + g);\n
    } else {\n
      h -= 2 / 3;\n
      g = (1 - s) / 3;\n
      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n
      r = 1 - (g + b);\n
    }\n
    r = limit(i * r * 3);\n
    g = limit(i * g * 3);\n
    b = limit(i * b * 3);\n
    return [r * 255, g * 255, b * 255];\n
  };\n
\n
  hsl2rgb = function() {\n
    var b, c, g, h, i, l, r, s, t1, t2, t3, _i, _ref, _ref1;\n
\n
    _ref = unpack(arguments), h = _ref[0], s = _ref[1], l = _ref[2];\n
    if (s === 0) {\n
      r = g = b = l * 255;\n
    } else {\n
      t3 = [0, 0, 0];\n
      c = [0, 0, 0];\n
      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n
      t1 = 2 * l - t2;\n
      h /= 360;\n
      t3[0] = h + 1 / 3;\n
      t3[1] = h;\n
      t3[2] = h - 1 / 3;\n
      for (i = _i = 0; _i <= 2; i = ++_i) {\n
        if (t3[i] < 0) {\n
          t3[i] += 1;\n
        }\n
        if (t3[i] > 1) {\n
          t3[i] -= 1;\n
        }\n
        if (6 * t3[i] < 1) {\n
          c[i] = t1 + (t2 - t1) * 6 * t3[i];\n
        } else if (2 * t3[i] < 1) {\n
          c[i] = t2;\n
        } else if (3 * t3[i] < 2) {\n
          c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;\n
        } else {\n
          c[i] = t1;\n
        }\n
      }\n
      _ref1 = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)], r = _ref1[0], g = _ref1[1], b = _ref1[2];\n
    }\n
    return [r, g, b];\n
  };\n
\n
  hsv2rgb = function() {\n
    var b, f, g, h, i, p, q, r, s, t, v, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n
\n
    _ref = unpack(arguments), h = _ref[0], s = _ref[1], v = _ref[2];\n
    v *= 255;\n
    if (s === 0) {\n
      r = g = b = v;\n
    } else {\n
      if (h === 360) {\n
        h = 0;\n
      }\n
      if (h > 360) {\n
        h -= 360;\n
      }\n
      if (h < 0) {\n
        h += 360;\n
      }\n
      h /= 60;\n
      i = Math.floor(h);\n
      f = h - i;\n
      p = v * (1 - s);\n
      q = v * (1 - s * f);\n
      t = v * (1 - s * (1 - f));\n
      switch (i) {\n
        case 0:\n
          _ref1 = [v, t, p], r = _ref1[0], g = _ref1[1], b = _ref1[2];\n
          break;\n
        case 1:\n
          _ref2 = [q, v, p], r = _ref2[0], g = _ref2[1], b = _ref2[2];\n
          break;\n
        case 2:\n
          _ref3 = [p, v, t], r = _ref3[0], g = _ref3[1], b = _ref3[2];\n
          break;\n
        case 3:\n
          _ref4 = [p, q, v], r = _ref4[0], g = _ref4[1], b = _ref4[2];\n
          break;\n
        case 4:\n
          _ref5 = [t, p, v], r = _ref5[0], g = _ref5[1], b = _ref5[2];\n
          break;\n
        case 5:\n
          _ref6 = [v, p, q], r = _ref6[0], g = _ref6[1], b = _ref6[2];\n
      }\n
    }\n
    r = Math.round(r);\n
    g = Math.round(g);\n
    b = Math.round(b);\n
    return [r, g, b];\n
  };\n
\n
  K = 18;\n
\n
  X = 0.950470;\n
\n
  Y = 1;\n
\n
  Z = 1.088830;\n
\n
  lab2lch = function() {\n
    var a, b, c, h, l, _ref;\n
\n
    _ref = unpack(arguments), l = _ref[0], a = _ref[1], b = _ref[2];\n
    c = Math.sqrt(a * a + b * b);\n
    h = Math.atan2(b, a) / Math.PI * 180;\n
    return [l, c, h];\n
  };\n
\n
  lab2rgb = function(l, a, b) {\n
    /*\n
    adapted to match d3 implementation\n
    */\n
\n
    var g, r, x, y, z, _ref, _ref1;\n
\n
    if (l !== void 0 && l.length === 3) {\n
      _ref = l, l = _ref[0], a = _ref[1], b = _ref[2];\n
    }\n
    if (l !== void 0 && l.length === 3) {\n
      _ref1 = l, l = _ref1[0], a = _ref1[1], b = _ref1[2];\n
    }\n
    y = (l + 16) / 116;\n
    x = y + a / 500;\n
    z = y - b / 200;\n
    x = lab_xyz(x) * X;\n
    y = lab_xyz(y) * Y;\n
    z = lab_xyz(z) * Z;\n
    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);\n
    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n
    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n
    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), 1];\n
  };\n
\n
  lab_xyz = function(x) {\n
    if (x > 0.206893034) {\n
      return x * x * x;\n
    } else {\n
      return (x - 4 / 29) / 7.787037;\n
    }\n
  };\n
\n
  xyz_rgb = function(r) {\n
    return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));\n
  };\n
\n
  lch2lab = function() {\n
    /*\n
    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel. These formulas were invented by David Dalrymple to obtain maximum contrast without going out of gamut if the parameters are in the range 0-1.\n
    A saturation multiplier was added by Gregor Aisch\n
    */\n
\n
    var c, h, l, _ref;\n
\n
    _ref = unpack(arguments), l = _ref[0], c = _ref[1], h = _ref[2];\n
    h = h * Math.PI / 180;\n
    return [l, Math.cos(h) * c, Math.sin(h) * c];\n
  };\n
\n
  lch2rgb = function(l, c, h) {\n
    var L, a, b, g, r, _ref, _ref1;\n
\n
    _ref = lch2lab(l, c, h), L = _ref[0], a = _ref[1], b = _ref[2];\n
    _ref1 = lab2rgb(L, a, b), r = _ref1[0], g = _ref1[1], b = _ref1[2];\n
    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];\n
  };\n
\n
  luminance = function(r, g, b) {\n
    var _ref;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    r = luminance_x(r);\n
    g = luminance_x(g);\n
    b = luminance_x(b);\n
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n
  };\n
\n
  luminance_x = function(x) {\n
    x /= 255;\n
    if (x <= 0.03928) {\n
      return x / 12.92;\n
    } else {\n
      return Math.pow((x + 0.055) / 1.055, 2.4);\n
    }\n
  };\n
\n
  rgb2hex = function() {\n
    var b, g, r, str, u, _ref;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    u = r << 16 | g << 8 | b;\n
    str = "000000" + u.toString(16);\n
    return "#" + str.substr(str.length - 6);\n
  };\n
\n
  rgb2hsi = function() {\n
    /*\n
    borrowed from here:\n
    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n
    */\n
\n
    var TWOPI, b, g, h, i, min, r, s, _ref;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    TWOPI = Math.PI * 2;\n
    r /= 255;\n
    g /= 255;\n
    b /= 255;\n
    min = Math.min(r, g, b);\n
    i = (r + g + b) / 3;\n
    s = 1 - min / i;\n
    if (s === 0) {\n
      h = 0;\n
    } else {\n
      h = ((r - g) + (r - b)) / 2;\n
      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));\n
      h = Math.acos(h);\n
      if (b > g) {\n
        h = TWOPI - h;\n
      }\n
      h /= TWOPI;\n
    }\n
    return [h * 360, s, i];\n
  };\n
\n
  rgb2hsl = function(r, g, b) {\n
    var h, l, max, min, s, _ref;\n
\n
    if (r !== void 0 && r.length >= 3) {\n
      _ref = r, r = _ref[0], g = _ref[1], b = _ref[2];\n
    }\n
    r /= 255;\n
    g /= 255;\n
    b /= 255;\n
    min = Math.min(r, g, b);\n
    max = Math.max(r, g, b);\n
    l = (max + min) / 2;\n
    if (max === min) {\n
      s = 0;\n
      h = Number.NaN;\n
    } else {\n
      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n
    }\n
    if (r === max) {\n
      h = (g - b) / (max - min);\n
    } else if (g === max) {\n
      h = 2 + (b - r) / (max - min);\n
    } else if (b === max) {\n
      h = 4 + (r - g) / (max - min);\n
    }\n
    h *= 60;\n
    if (h < 0) {\n
      h += 360;\n
    }\n
    return [h, s, l];\n
  };\n
\n
  rgb2hsv = function() {\n
    var b, delta, g, h, max, min, r, s, v, _ref;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    min = Math.min(r, g, b);\n
    max = Math.max(r, g, b);\n
    delta = max - min;\n
    v = max / 255.0;\n
    if (max === 0) {\n
      h = Number.NaN;\n
      s = 0;\n
    } else {\n
      s = delta / max;\n
      if (r === max) {\n
        h = (g - b) / delta;\n
      }\n
      if (g === max) {\n
        h = 2 + (b - r) / delta;\n
      }\n
      if (b === max) {\n
        h = 4 + (r - g) / delta;\n
      }\n
      h *= 60;\n
      if (h < 0) {\n
        h += 360;\n
      }\n
    }\n
    return [h, s, v];\n
  };\n
\n
  rgb2lab = function() {\n
    var b, g, r, x, y, z, _ref;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    r = rgb_xyz(r);\n
    g = rgb_xyz(g);\n
    b = rgb_xyz(b);\n
    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / X);\n
    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Y);\n
    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Z);\n
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];\n
  };\n
\n
  rgb_xyz = function(r) {\n
    if ((r /= 255) <= 0.04045) {\n
      return r / 12.92;\n
    } else {\n
      return Math.pow((r + 0.055) / 1.055, 2.4);\n
    }\n
  };\n
\n
  xyz_lab = function(x) {\n
    if (x > 0.008856) {\n
      return Math.pow(x, 1 / 3);\n
    } else {\n
      return 7.787037 * x + 4 / 29;\n
    }\n
  };\n
\n
  rgb2lch = function() {\n
    var a, b, g, l, r, _ref, _ref1;\n
\n
    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n
    _ref1 = rgb2lab(r, g, b), l = _ref1[0], a = _ref1[1], b = _ref1[2];\n
    return lab2lch(l, a, b);\n
  };\n
\n
  /*\n
      chroma.js\n
  \n
      Copyright (c) 2011-2013, Gregor Aisch\n
      All rights reserved.\n
  \n
      Redistribution and use in source and binary forms, with or without\n
      modification, are permitted provided that the following conditions are met:\n
  \n
      * Redistributions of source code must retain the above copyright notice, this\n
        list of conditions and the following disclaimer.\n
  \n
      * Redistributions in binary form must reproduce the above copyright notice,\n
        this list of conditions and the following disclaimer in the documentation\n
        and/or other materials provided with the distribution.\n
  \n
      * The name Gregor Aisch may not be used to endorse or promote products\n
        derived from this software without specific prior written permission.\n
  \n
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
  \n
      @source: https://github.com/gka/chroma.js\n
  */\n
\n
\n
  chroma.scale = function(colors, positions) {\n
    var classifyValue, f, getClass, getColor, resetCache, setColors, setDomain, tmap, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _numClasses, _out, _pos, _spread;\n
\n
    _mode = \'rgb\';\n
    _nacol = chroma(\'#ccc\');\n
    _spread = 0;\n
    _fixed = false;\n
    _domain = [0, 1];\n
    _colors = [];\n
    _out = false;\n
    _pos = [];\n
    _min = 0;\n
    _max = 1;\n
    _correctLightness = false;\n
    _numClasses = 0;\n
    _colorCache = {};\n
    setColors = function(colors, positions) {\n
      var c, col, _i, _j, _ref, _ref1, _ref2;\n
\n
      if (colors == null) {\n
        colors = [\'#ddd\', \'#222\'];\n
      }\n
      if ((colors != null) && type(colors) === \'string\' && (((_ref = chroma.brewer) != null ? _ref[colors] : void 0) != null)) {\n
        colors = chroma.brewer[colors];\n
      }\n
      if (type(colors) === \'array\') {\n
        colors = colors.slice(0);\n
        for (c = _i = 0, _ref1 = colors.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; c = 0 <= _ref1 ? ++_i : --_i) {\n
          col = colors[c];\n
          if (type(col) === "string") {\n
            colors[c] = chroma(col);\n
          }\n
        }\n
        if (positions != null) {\n
          _pos = positions;\n
        } else {\n
          _pos = [];\n
          for (c = _j = 0, _ref2 = colors.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; c = 0 <= _ref2 ? ++_j : --_j) {\n
            _pos.push(c / (colors.length - 1));\n
          }\n
        }\n
      }\n
      resetCache();\n
      return _colors = colors;\n
    };\n
    setDomain = function(domain) {\n
      if (domain == null) {\n
        domain = [];\n
      }\n
      /*\n
      # use this if you want to display a limited number of data classes\n
      # possible methods are "equalinterval", "quantiles", "custom"\n
      */\n
\n
      _domain = domain;\n
      _min = domain[0];\n
      _max = domain[domain.length - 1];\n
      resetCache();\n
      if (domain.length === 2) {\n
        return _numClasses = 0;\n
      } else {\n
        return _numClasses = domain.length - 1;\n
      }\n
    };\n
    getClass = function(value) {\n
      var i, n;\n
\n
      if (_domain != null) {\n
        n = _domain.length - 1;\n
        i = 0;\n
        while (i < n && value >= _domain[i]) {\n
          i++;\n
        }\n
        return i - 1;\n
      }\n
      return 0;\n
    };\n
    tmap = function(t) {\n
      return t;\n
    };\n
    classifyValue = function(value) {\n
      var i, maxc, minc, n, val;\n
\n
      val = value;\n
      if (_domain.length > 2) {\n
        n = _domain.length - 1;\n
        i = getClass(value);\n
        minc = _domain[0] + (_domain[1] - _domain[0]) * (0 + _spread * 0.5);\n
        maxc = _domain[n - 1] + (_domain[n] - _domain[n - 1]) * (1 - _spread * 0.5);\n
        val = _min + ((_domain[i] + (_domain[i + 1] - _domain[i]) * 0.5 - minc) / (maxc - minc)) * (_max - _min);\n
      }\n
      return val;\n
    };\n
    getColor = function(val, bypassMap) {\n
      var c, col, f0, i, k, p, t, _i, _ref;\n
\n
      if (bypassMap == null) {\n
        bypassMap = false;\n
      }\n
      if (isNaN(val)) {\n
        return _nacol;\n
      }\n
      if (!bypassMap) {\n
        if (_domain.length > 2) {\n
          c = getClass(val);\n
          t = c / (_numClasses - 1);\n
        } else {\n
          t = f0 = (val - _min) / (_max - _min);\n
          t = Math.min(1, Math.max(0, t));\n
        }\n
      } else {\n
        t = val;\n
      }\n
      if (!bypassMap) {\n
        t = tmap(t);\n
      }\n
      k = Math.floor(t * 10000);\n
      if (_colorCache[k]) {\n
        col = _colorCache[k];\n
      } else {\n
        if (type(_colors) === \'array\') {\n
          for (i = _i = 0, _ref = _pos.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n
            p = _pos[i];\n
            if (t <= p) {\n
              col = _colors[i];\n
              break;\n
            }\n
            if (t >= p && i === _pos.length - 1) {\n
              col = _colors[i];\n
              break;\n
            }\n
            if (t > p && t < _pos[i + 1]) {\n
              t = (t - p) / (_pos[i + 1] - p);\n
              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);\n
              break;\n
            }\n
          }\n
        } else if (type(_colors) === \'function\') {\n
          col = _colors(t);\n
        }\n
        _colorCache[k] = col;\n
      }\n
      return col;\n
    };\n
    resetCache = function() {\n
      return _colorCache = {};\n
    };\n
    setColors(colors, positions);\n
    f = function(v) {\n
      var c;\n
\n
      c = getColor(v);\n
      if (_out && c[_out]) {\n
        return c[_out]();\n
      } else {\n
        return c;\n
      }\n
    };\n
    f.domain = function(domain, classes, mode, key) {\n
      var d;\n
\n
      if (mode == null) {\n
        mode = \'e\';\n
      }\n
      if (!arguments.length) {\n
        return _domain;\n
      }\n
      if (classes != null) {\n
        d = chroma.analyze(domain, key);\n
        if (classes === 0) {\n
          domain = [d.min, d.max];\n
        } else {\n
          domain = chroma.limits(d, mode, classes);\n
        }\n
      }\n
      setDomain(domain);\n
      return f;\n
    };\n
    f.mode = function(_m) {\n
      if (!arguments.length) {\n
        return _mode;\n
      }\n
      _mode = _m;\n
      resetCache();\n
      return f;\n
    };\n
    f.range = function(colors, _pos) {\n
      setColors(colors, _pos);\n
      return f;\n
    };\n
    f.out = function(_o) {\n
      _out = _o;\n
      return f;\n
    };\n
    f.spread = function(val) {\n
      if (!arguments.length) {\n
        return _spread;\n
      }\n
      _spread = val;\n
      return f;\n
    };\n
    f.correctLightness = function(v) {\n
      if (!arguments.length) {\n
        return _correctLightness;\n
      }\n
      _correctLightness = v;\n
      resetCache();\n
      if (_correctLightness) {\n
        tmap = function(t) {\n
          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;\n
\n
          L0 = getColor(0, true).lab()[0];\n
          L1 = getColor(1, true).lab()[0];\n
          pol = L0 > L1;\n
          L_actual = getColor(t, true).lab()[0];\n
          L_ideal = L0 + (L1 - L0) * t;\n
          L_diff = L_actual - L_ideal;\n
          t0 = 0;\n
          t1 = 1;\n
          max_iter = 20;\n
          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n
            (function() {\n
              if (pol) {\n
                L_diff *= -1;\n
              }\n
              if (L_diff < 0) {\n
                t0 = t;\n
                t += (t1 - t) * 0.5;\n
              } else {\n
                t1 = t;\n
                t += (t0 - t) * 0.5;\n
              }\n
              L_actual = getColor(t, true).lab()[0];\n
              return L_diff = L_actual - L_ideal;\n
            })();\n
          }\n
          return t;\n
        };\n
      } else {\n
        tmap = function(t) {\n
          return t;\n
        };\n
      }\n
      return f;\n
    };\n
    f.colors = function(out) {\n
      var i, samples, _i, _j, _len, _ref;\n
\n
      if (out == null) {\n
        out = \'hex\';\n
      }\n
      colors = [];\n
      samples = [];\n
      if (_domain.length > 2) {\n
        for (i = _i = 1, _ref = _domain.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {\n
          samples.push((_domain[i - 1] + _domain[i]) * 0.5);\n
        }\n
      } else {\n
        samples = _domain;\n
      }\n
      for (_j = 0, _len = samples.length; _j < _len; _j++) {\n
        i = samples[_j];\n
        colors.push(f(i)[out]());\n
      }\n
      return colors;\n
    };\n
    return f;\n
  };\n
\n
  if ((_ref = chroma.scales) == null) {\n
    chroma.scales = {};\n
  }\n
\n
  chroma.scales.cool = function() {\n
    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);\n
  };\n
\n
  chroma.scales.hot = function() {\n
    return chroma.scale([\'#000\', \'#f00\', \'#ff0\', \'#fff\'], [0, .25, .75, 1]).mode(\'rgb\');\n
  };\n
\n
  /*\n
      chroma.js\n
  \n
      Copyright (c) 2011-2013, Gregor Aisch\n
      All rights reserved.\n
  \n
      Redistribution and use in source and binary forms, with or without\n
      modification, are permitted provided that the following conditions are met:\n
  \n
      * Redistributions of source code must retain the above copyright notice, this\n
        list of conditions and the following disclaimer.\n
  \n
      * Redistributions in binary form must reproduce the above copyright notice,\n
        this list of conditions and the following disclaimer in the documentation\n
        and/or other materials provided with the distribution.\n
  \n
      * The name Gregor Aisch may not be used to endorse or promote products\n
        derived from this software without specific prior written permission.\n
  \n
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
  \n
      @source: https://github.com/gka/chroma.js\n
  */\n
\n
\n
  chroma.analyze = function(data, key, filter) {\n
    var add, k, r, val, visit, _i, _len;\n
\n
    r = {\n
      min: Number.MAX_VALUE,\n
      max: Number.MAX_VALUE * -1,\n
      sum: 0,\n
      values: [],\n
      count: 0\n
    };\n
    if (filter == null) {\n
      filter = function() {\n
        return true;\n
      };\n
    }\n
    add = function(val) {\n
      if ((val != null) && !isNaN(val)) {\n
        r.values.push(val);\n
        r.sum += val;\n
        if (val < r.min) {\n
          r.min = val;\n
        }\n
        if (val > r.max) {\n
          r.max = val;\n
        }\n
        r.count += 1;\n
      }\n
    };\n
    visit = function(val, k) {\n
      if (filter(val, k)) {\n
        if ((key != null) && type(key) === \'function\') {\n
          return add(key(val));\n
        } else if ((key != null) && type(key) === \'string\' || type(key) === \'number\') {\n
          return add(val[key]);\n
        } else {\n
          return add(val);\n
        }\n
      }\n
    };\n
    if (type(data) === \'array\') {\n
      for (_i = 0, _len = data.length; _i < _len; _i++) {\n
        val = data[_i];\n
        visit(val);\n
      }\n
    } else {\n
      for (k in data) {\n
        val = data[k];\n
        visit(val, k);\n
      }\n
    }\n
    r.domain = [r.min, r.max];\n
    r.limits = function(mode, num) {\n
      return chroma.limits(r, mode, num);\n
    };\n
    return r;\n
  };\n
\n
  chroma.limits = function(data, mode, num) {\n
    var assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max, max_log, min, min_log, mindist, n, nb_iters, newCentroids, p, pb, pr, repeat, sum, tmpKMeansBreaks, value, values, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w;\n
\n
    if (mode == null) {\n
      mode = \'equal\';\n
    }\n
    if (num == null) {\n
      num = 7;\n
    }\n
    if (data.values == null) {\n
      data = chroma.analyze(data);\n
    }\n
    min = data.min;\n
    max = data.max;\n
    sum = data.sum;\n
    values = data.values.sort(function(a, b) {\n
      return a - b;\n
    });\n
    limits = [];\n
    if (mode.substr(0, 1) === \'c\') {\n
      limits.push(min);\n
      limits.push(max);\n
    }\n
    if (mode.substr(0, 1) === \'e\') {\n
      limits.push(min);\n
      for (i = _i = 1, _ref1 = num - 1; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {\n
        limits.push(min + (i / num) * (max - min));\n
      }\n
      limits.push(max);\n
    } else if (mode.substr(0, 1) === \'l\') {\n
      if (min <= 0) {\n
        throw \'Logarithmic scales are only possible for values > 0\';\n
      }\n
      min_log = Math.LOG10E * Math.log(min);\n
      max_log = Math.LOG10E * Math.log(max);\n
      limits.push(min);\n
      for (i = _j = 1, _ref2 = num - 1; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 1 <= _ref2 ? ++_j : --_j) {\n
        limits.push(Math.pow(10, min_log + (i / num) * (max_log - min_log)));\n
      }\n
      limits.push(max);\n
    } else if (mode.substr(0, 1) === \'q\') {\n
      limits.push(min);\n
      for (i = _k = 1, _ref3 = num - 1; 1 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 1 <= _ref3 ? ++_k : --_k) {\n
        p = values.length * i / num;\n
        pb = Math.floor(p);\n
        if (pb === p) {\n
          limits.push(values[pb]);\n
        } else {\n
          pr = p - pb;\n
          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));\n
        }\n
      }\n
      limits.push(max);\n
    } else if (mode.substr(0, 1) === \'k\') {\n
      /*\n
      implementation based on\n
      http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n
      simplified for 1-d input values\n
      */\n
\n
      n = values.length;\n
      assignments = new Array(n);\n
      clusterSizes = new Array(num);\n
      repeat = true;\n
      nb_iters = 0;\n
      centroids = null;\n
      centroids = [];\n
      centroids.push(min);\n
      for (i = _l = 1, _ref4 = num - 1; 1 <= _ref4 ? _l <= _ref4 : _l >= _ref4; i = 1 <= _ref4 ? ++_l : --_l) {\n
        centroids.push(min + (i / num) * (max - min));\n
      }\n
      centroids.push(max);\n
      while (repeat) {\n
        for (j = _m = 0, _ref5 = num - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; j = 0 <= _ref5 ? ++_m : --_m) {\n
          clusterSizes[j] = 0;\n
        }\n
        for (i = _n = 0, _ref6 = n - 1; 0 <= _ref6 ? _n <= _ref6 : _n >= _ref6; i = 0 <= _ref6 ? ++_n : --_n) {\n
          value = values[i];\n
          mindist = Number.MAX_VALUE;\n
          for (j = _o = 0, _ref7 = num - 1; 0 <= _ref7 ? _o <= _ref7 : _o >= _ref7; j = 0 <= _ref7 ? ++_o : --_o) {\n
            dist = Math.abs(centroids[j] - value);\n
            if (dist < mindist) {\n
              mindist = dist;\n
              best = j;\n
            }\n
          }\n
          clusterSizes[best]++;\n
          assignments[i] = best;\n
        }\n
        newCentroids = new Array(num);\n
        for (j = _p = 0, _ref8 = num - 1; 0 <= _ref8 ? _p <= _ref8 : _p >= _ref8; j = 0 <= _ref8 ? ++_p : --_p) {\n
          newCentroids[j] = null;\n
        }\n
        for (i = _q = 0, _ref9 = n - 1; 0 <= _ref9 ? _q <= _ref9 : _q >= _ref9; i = 0 <= _ref9 ? ++_q : --_q) {\n
          cluster = assignments[i];\n
          if (newCentroids[cluster] === null) {\n
            newCentroids[cluster] = values[i];\n
          } else {\n
            newCentroids[cluster] += values[i];\n
          }\n
        }\n
        for (j = _r = 0, _ref10 = num - 1; 0 <= _ref10 ? _r <= _ref10 : _r >= _ref10; j = 0 <= _ref10 ? ++_r : --_r) {\n
          newCentroids[j] *= 1 / clusterSizes[j];\n
        }\n
        repeat = false;\n
        for (j = _s = 0, _ref11 = num - 1; 0 <= _ref11 ? _s <= _ref11 : _s >= _ref11; j = 0 <= _ref11 ? ++_s : --_s) {\n
          if (newCentroids[j] !== centroids[i]) {\n
            repeat = true;\n
            break;\n
          }\n
        }\n
        centroids = newCentroids;\n
        nb_iters++;\n
        if (nb_iters > 200) {\n
          repeat = false;\n
        }\n
      }\n
      kClusters = {};\n
      for (j = _t = 0, _ref12 = num - 1; 0 <= _ref12 ? _t <= _ref12 : _t >= _ref12; j = 0 <= _ref12 ? ++_t : --_t) {\n
        kClusters[j] = [];\n
      }\n
      for (i = _u = 0, _ref13 = n - 1; 0 <= _ref13 ? _u <= _ref13 : _u >= _ref13; i = 0 <= _ref13 ? ++_u : --_u) {\n
        cluster = assignments[i];\n
        kClusters[cluster].push(values[i]);\n
      }\n
      tmpKMeansBreaks = [];\n
      for (j = _v = 0, _ref14 = num - 1; 0 <= _ref14 ? _v <= _ref14 : _v >= _ref14; j = 0 <= _ref14 ? ++_v : --_v) {\n
        tmpKMeansBreaks.push(kClusters[j][0]);\n
        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n
      }\n
      tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {\n
        return a - b;\n
      });\n
      limits.push(tmpKMeansBreaks[0]);\n
      for (i = _w = 1, _ref15 = tmpKMeansBreaks.length - 1; _w <= _ref15; i = _w += 2) {\n
        if (!isNaN(tmpKMeansBreaks[i])) {\n
          limits.push(tmpKMeansBreaks[i]);\n
        }\n
      }\n
    }\n
    return limits;\n
  };\n
\n
  /**\n
  \tColorBrewer colors for chroma.js\n
  \n
  \tCopyright (c) 2002 Cynthia Brewer, Mark Harrower, and The \n
  \tPennsylvania State University.\n
  \n
  \tLicensed under the Apache License, Version 2.0 (the "License"); \n
  \tyou may not use this file except in compliance with the License.\n
  \tYou may obtain a copy of the License at\t\n
  \thttp://www.apache.org/licenses/LICENSE-2.0\n
  \n
  \tUnless required by applicable law or agreed to in writing, software distributed\n
  \tunder the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR\n
  \tCONDITIONS OF ANY KIND, either express or implied. See the License for the\n
  \tspecific language governing permissions and limitations under the License.\n
  \n
      @preserve\n
  */\n
\n
\n
  chroma.brewer = brewer = {\n
    OrRd: [\'#fff7ec\', \'#fee8c8\', \'#fdd49e\', \'#fdbb84\', \'#fc8d59\', \'#ef6548\', \'#d7301f\', \'#b30000\', \'#7f0000\'],\n
    PuBu: [\'#fff7fb\', \'#ece7f2\', \'#d0d1e6\', \'#a6bddb\', \'#74a9cf\', \'#3690c0\', \'#0570b0\', \'#045a8d\', \'#023858\'],\n
    BuPu: [\'#f7fcfd\', \'#e0ecf4\', \'#bfd3e6\', \'#9ebcda\', \'#8c96c6\', \'#8c6bb1\', \'#88419d\', \'#810f7c\', \'#4d004b\'],\n
    Oranges: [\'#fff5eb\', \'#fee6ce\', \'#fdd0a2\', \'#fdae6b\', \'#fd8d3c\', \'#f16913\', \'#d94801\', \'#a63603\', \'#7f2704\'],\n
    BuGn: [\'#f7fcfd\', \'#e5f5f9\', \'#ccece6\', \'#99d8c9\', \'#66c2a4\', \'#41ae76\', \'#238b45\', \'#006d2c\', \'#00441b\'],\n
    YlOrBr: [\'#ffffe5\', \'#fff7bc\', \'#fee391\', \'#fec44f\', \'#fe9929\', \'#ec7014\', \'#cc4c02\', \'#993404\', \'#662506\'],\n
    YlGn: [\'#ffffe5\', \'#f7fcb9\', \'#d9f0a3\', \'#addd8e\', \'#78c679\', \'#41ab5d\', \'#238443\', \'#006837\', \'#004529\'],\n
    Reds: [\'#fff5f0\', \'#fee0d2\', \'#fcbba1\', \'#fc9272\', \'#fb6a4a\', \'#ef3b2c\', \'#cb181d\', \'#a50f15\', \'#67000d\'],\n
    RdPu: [\'#fff7f3\', \'#fde0dd\', \'#fcc5c0\', \'#fa9fb5\', \'#f768a1\', \'#dd3497\', \'#ae017e\', \'#7a0177\', \'#49006a\'],\n
    Greens: [\'#f7fcf5\', \'#e5f5e0\', \'#c7e9c0\', \'#a1d99b\', \'#74c476\', \'#41ab5d\', \'#238b45\', \'#006d2c\', \'#00441b\'],\n
    YlGnBu: [\'#ffffd9\', \'#edf8b1\', \'#c7e9b4\', \'#7fcdbb\', \'#41b6c4\', \'#1d91c0\', \'#225ea8\', \'#253494\', \'#081d58\'],\n
    Purples: [\'#fcfbfd\', \'#efedf5\', \'#dadaeb\', \'#bcbddc\', \'#9e9ac8\', \'#807dba\', \'#6a51a3\', \'#54278f\', \'#3f007d\'],\n
    GnBu: [\'#f7fcf0\', \'#e0f3db\', \'#ccebc5\', \'#a8ddb5\', \'#7bccc4\', \'#4eb3d3\', \'#2b8cbe\', \'#0868ac\', \'#084081\'],\n
    Greys: [\'#ffffff\', \'#f0f0f0\', \'#d9d9d9\', \'#bdbdbd\', \'#969696\', \'#737373\', \'#525252\', \'#252525\', \'#000000\'],\n
    YlOrRd: [\'#ffffcc\', \'#ffeda0\', \'#fed976\', \'#feb24c\', \'#fd8d3c\', \'#fc4e2a\', \'#e31a1c\', \'#bd0026\', \'#800026\'],\n
    PuRd: [\'#f7f4f9\', \'#e7e1ef\', \'#d4b9da\', \'#c994c7\', \'#df65b0\', \'#e7298a\', \'#ce1256\', \'#980043\', \'#67001f\'],\n
    Blues: [\'#f7fbff\', \'#deebf7\', \'#c6dbef\', \'#9ecae1\', \'#6baed6\', \'#4292c6\', \'#2171b5\', \'#08519c\', \'#08306b\'],\n
    PuBuGn: [\'#fff7fb\', \'#ece2f0\', \'#d0d1e6\', \'#a6bddb\', \'#67a9cf\', \'#3690c0\', \'#02818a\', \'#016c59\', \'#014636\'],\n
    Spectral: [\'#9e0142\', \'#d53e4f\', \'#f46d43\', \'#fdae61\', \'#fee08b\', \'#ffffbf\', \'#e6f598\', \'#abdda4\', \'#66c2a5\', \'#3288bd\', \'#5e4fa2\'],\n
    RdYlGn: [\'#a50026\', \'#d73027\', \'#f46d43\', \'#fdae61\', \'#fee08b\', \'#ffffbf\', \'#d9ef8b\', \'#a6d96a\', \'#66bd63\', \'#1a9850\', \'#006837\'],\n
    RdBu: [\'#67001f\', \'#b2182b\', \'#d6604d\', \'#f4a582\', \'#fddbc7\', \'#f7f7f7\', \'#d1e5f0\', \'#92c5de\', \'#4393c3\', \'#2166ac\', \'#053061\'],\n
    PiYG: [\'#8e0152\', \'#c51b7d\', \'#de77ae\', \'#f1b6da\', \'#fde0ef\', \'#f7f7f7\', \'#e6f5d0\', \'#b8e186\', \'#7fbc41\', \'#4d9221\', \'#276419\'],\n
    PRGn: [\'#40004b\', \'#762a83\', \'#9970ab\', \'#c2a5cf\', \'#e7d4e8\', \'#f7f7f7\', \'#d9f0d3\', \'#a6dba0\', \'#5aae61\', \'#1b7837\', \'#00441b\'],\n
    RdYlBu: [\'#a50026\', \'#d73027\', \'#f46d43\', \'#fdae61\', \'#fee090\', \'#ffffbf\', \'#e0f3f8\', \'#abd9e9\', \'#74add1\', \'#4575b4\', \'#313695\'],\n
    BrBG: [\'#543005\', \'#8c510a\', \'#bf812d\', \'#dfc27d\', \'#f6e8c3\', \'#f5f5f5\', \'#c7eae5\', \'#80cdc1\', \'#35978f\', \'#01665e\', \'#003c30\'],\n
    RdGy: [\'#67001f\', \'#b2182b\', \'#d6604d\', \'#f4a582\', \'#fddbc7\', \'#ffffff\', \'#e0e0e0\', \'#bababa\', \'#878787\', \'#4d4d4d\', \'#1a1a1a\'],\n
    PuOr: [\'#7f3b08\', \'#b35806\', \'#e08214\', \'#fdb863\', \'#fee0b6\', \'#f7f7f7\', \'#d8daeb\', \'#b2abd2\', \'#8073ac\', \'#542788\', \'#2d004b\'],\n
    Set2: [\'#66c2a5\', \'#fc8d62\', \'#8da0cb\', \'#e78ac3\', \'#a6d854\', \'#ffd92f\', \'#e5c494\', \'#b3b3b3\'],\n
    Accent: [\'#7fc97f\', \'#beaed4\', \'#fdc086\', \'#ffff99\', \'#386cb0\', \'#f0027f\', \'#bf5b17\', \'#666666\'],\n
    Set1: [\'#e41a1c\', \'#377eb8\', \'#4daf4a\', \'#984ea3\', \'#ff7f00\', \'#ffff33\', \'#a65628\', \'#f781bf\', \'#999999\'],\n
    Set3: [\'#8dd3c7\', \'#ffffb3\', \'#bebada\', \'#fb8072\', \'#80b1d3\', \'#fdb462\', \'#b3de69\', \'#fccde5\', \'#d9d9d9\', \'#bc80bd\', \'#ccebc5\', \'#ffed6f\'],\n
    Dark2: [\'#1b9e77\', \'#d95f02\', \'#7570b3\', \'#e7298a\', \'#66a61e\', \'#e6ab02\', \'#a6761d\', \'#666666\'],\n
    Paired: [\'#a6cee3\', \'#1f78b4\', \'#b2df8a\', \'#33a02c\', \'#fb9a99\', \'#e31a1c\', \'#fdbf6f\', \'#ff7f00\', \'#cab2d6\', \'#6a3d9a\', \'#ffff99\', \'#b15928\'],\n
    Pastel2: [\'#b3e2cd\', \'#fdcdac\', \'#cbd5e8\', \'#f4cae4\', \'#e6f5c9\', \'#fff2ae\', \'#f1e2cc\', \'#cccccc\'],\n
    Pastel1: [\'#fbb4ae\', \'#b3cde3\', \'#ccebc5\', \'#decbe4\', \'#fed9a6\', \'#ffffcc\', \'#e5d8bd\', \'#fddaec\', \'#f2f2f2\']\n
  };\n
\n
  /**\n
  \tX11 color names\n
  \n
  \thttp://www.w3.org/TR/css3-color/#svg-color\n
  */\n
\n
\n
  chroma.colors = colors = {\n
    indigo: "#4b0082",\n
    gold: "#ffd700",\n
    hotpink: "#ff69b4",\n
    firebrick: "#b22222",\n
    indianred: "#cd5c5c",\n
    yellow: "#ffff00",\n
    mistyrose: "#ffe4e1",\n
    darkolivegreen: "#556b2f",\n
    olive: "#808000",\n
    darkseagreen: "#8fbc8f",\n
    pink: "#ffc0cb",\n
    tomato: "#ff6347",\n
    lightcoral: "#f08080",\n
    orangered: "#ff4500",\n
    navajowhite: "#ffdead",\n
    lime: "#00ff00",\n
    palegreen: "#98fb98",\n
    darkslategrey: "#2f4f4f",\n
    greenyellow: "#adff2f",\n
    burlywood: "#deb887",\n
    seashell: "#fff5ee",\n
    mediumspringgreen: "#00fa9a",\n
    fuchsia: "#ff00ff",\n
    papayawhip: "#ffefd5",\n
    blanchedalmond: "#ffebcd",\n
    chartreuse: "#7fff00",\n
    dimgray: "#696969",\n
    black: "#000000",\n
    peachpuff: "#ffdab9",\n
    springgreen: "#00ff7f",\n
    aquamarine: "#7fffd4",\n
    white: "#ffffff",\n
    orange: "#ffa500",\n
    lightsalmon: "#ffa07a",\n
    darkslategray: "#2f4f4f",\n
    brown: "#a52a2a",\n
    ivory: "#fffff0",\n
    dodgerblue: "#1e90ff",\n
    peru: "#cd853f",\n
    lawngreen: "#7cfc00",\n
    chocolate: "#d2691e",\n
    crimson: "#dc143c",\n
    forestgreen: "#228b22",\n
    darkgrey: "#a9a9a9",\n
    lightseagreen: "#20b2aa",\n
    cyan: "#00ffff",\n
    mintcream: "#f5fffa",\n
    silver: "#c0c0c0",\n
    antiquewhite: "#faebd7",\n
    mediumorchid: "#ba55d3",\n
    skyblue: "#87ceeb",\n
    gray: "#808080",\n
    darkturquoise: "#00ced1",\n
    goldenrod: "#daa520",\n
    darkgreen: "#006400",\n
    floralwhite: "#fffaf0",\n
    darkviolet: "#9400d3",\n
    darkgray: "#a9a9a9",\n
    moccasin: "#ffe4b5",\n
    saddlebrown: "#8b4513",\n
    grey: "#808080",\n
    darkslateblue: "#483d8b",\n
    lightskyblue: "#87cefa",\n
    lightpink: "#ffb6c1",\n
    mediumvioletred: "#c71585",\n
    slategrey: "#708090",\n
    red: "#ff0000",\n
    deeppink: "#ff1493",\n
    limegreen: "#32cd32",\n
    darkmagenta: "#8b008b",\n
    palegoldenrod: "#eee8aa",\n
    plum: "#dda0dd",\n
    turquoise: "#40e0d0",\n
    lightgrey: "#d3d3d3",\n
    lightgoldenrodyellow: "#fafad2",\n
    darkgoldenrod: "#b8860b",\n
    lavender: "#e6e6fa",\n
    maroon: "#800000",\n
    yellowgreen: "#9acd32",\n
    sandybrown: "#f4a460",\n
    thistle: "#d8bfd8",\n
    violet: "#ee82ee",\n
    navy: "#000080",\n
    magenta: "#ff00ff",\n
    dimgrey: "#696969",\n
    tan: "#d2b48c",\n
    rosybrown: "#bc8f8f",\n
    olivedrab: "#6b8e23",\n
    blue: "#0000ff",\n
    lightblue: "#add8e6",\n
    ghostwhite: "#f8f8ff",\n
    honeydew: "#f0fff0",\n
    cornflowerblue: "#6495ed",\n
    slateblue: "#6a5acd",\n
    linen: "#faf0e6",\n
    darkblue: "#00008b",\n
    powderblue: "#b0e0e6",\n
    seagreen: "#2e8b57",\n
    darkkhaki: "#bdb76b",\n
    snow: "#fffafa",\n
    sienna: "#a0522d",\n
    mediumblue: "#0000cd",\n
    royalblue: "#4169e1",\n
    lightcyan: "#e0ffff",\n
    green: "#008000",\n
    mediumpurple: "#9370db",\n
    midnightblue: "#191970",\n
    cornsilk: "#fff8dc",\n
    paleturquoise: "#afeeee",\n
    bisque: "#ffe4c4",\n
    slategray: "#708090",\n
    darkcyan: "#008b8b",\n
    khaki: "#f0e68c",\n
    wheat: "#f5deb3",\n
    teal: "#008080",\n
    darkorchid: "#9932cc",\n
    deepskyblue: "#00bfff",\n
    salmon: "#fa8072",\n
    darkred: "#8b0000",\n
    steelblue: "#4682b4",\n
    palevioletred: "#db7093",\n
    lightslategray: "#778899",\n
    aliceblue: "#f0f8ff",\n
    lightslategrey: "#778899",\n
    lightgreen: "#90ee90",\n
    orchid: "#da70d6",\n
    gainsboro: "#dcdcdc",\n
    mediumseagreen: "#3cb371",\n
    lightgray: "#d3d3d3",\n
    mediumturquoise: "#48d1cc",\n
    lemonchiffon: "#fffacd",\n
    cadetblue: "#5f9ea0",\n
    lightyellow: "#ffffe0",\n
    lavenderblush: "#fff0f5",\n
    coral: "#ff7f50",\n
    purple: "#800080",\n
    aqua: "#00ffff",\n
    whitesmoke: "#f5f5f5",\n
    mediumslateblue: "#7b68ee",\n
    darkorange: "#ff8c00",\n
    mediumaquamarine: "#66cdaa",\n
    darksalmon: "#e9967a",\n
    beige: "#f5f5dc",\n
    blueviolet: "#8a2be2",\n
    azure: "#f0ffff",\n
    lightsteelblue: "#b0c4de",\n
    oldlace: "#fdf5e6"\n
  };\n
\n
  /*\n
      chroma.js\n
  \n
      Copyright (c) 2011-2013, Gregor Aisch\n
      All rights reserved.\n
  \n
      Redistribution and use in source and binary forms, with or without\n
      modification, are permitted provided that the following conditions are met:\n
  \n
      * Redistributions of source code must retain the above copyright notice, this\n
        list of conditions and the following disclaimer.\n
  \n
      * Redistributions in binary form must reproduce the above copyright notice,\n
        this list of conditions and the following disclaimer in the documentation\n
        and/or other materials provided with the distribution.\n
  \n
      * The name Gregor Aisch may not be used to endorse or promote products\n
        derived from this software without specific prior written permission.\n
  \n
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
  \n
      @source: https://github.com/gka/chroma.js\n
  */\n
\n
\n
  type = (function() {\n
    /*\n
    for browser-safe type checking+\n
    ported from jQuery\'s $.type\n
    */\n
\n
    var classToType, name, _i, _len, _ref1;\n
\n
    classToType = {};\n
    _ref1 = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");\n
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n
      name = _ref1[_i];\n
      classToType["[object " + name + "]"] = name.toLowerCase();\n
    }\n
    return function(obj) {\n
      var strType;\n
\n
      strType = Object.prototype.toString.call(obj);\n
      return classToType[strType] || "object";\n
    };\n
  })();\n
\n
  limit = function(x, min, max) {\n
    if (min == null) {\n
      min = 0;\n
    }\n
    if (max == null) {\n
      max = 1;\n
    }\n
    if (x < min) {\n
      x = min;\n
    }\n
    if (x > max) {\n
      x = max;\n
    }\n
    return x;\n
  };\n
\n
  unpack = function(args) {\n
    if (args.length >= 3) {\n
      return args;\n
    } else {\n
      return args[0];\n
    }\n
  };\n
\n
  TWOPI = Math.PI * 2;\n
\n
  PITHIRD = Math.PI / 3;\n
\n
  cos = Math.cos;\n
\n
  /*\n
  interpolates between a set of colors uzing a bezier spline\n
  */\n
\n
\n
  bezier = function(colors) {\n
    var I, I0, I1, c, lab0, lab1, lab2, lab3, _ref1, _ref2, _ref3;\n
\n
    colors = (function() {\n
      var _i, _len, _results;\n
\n
      _results = [];\n
      for (_i = 0, _len = colors.length; _i < _len; _i++) {\n
        c = colors[_i];\n
        _results.push(chroma(c));\n
      }\n
      return _results;\n
    })();\n
    if (colors.length === 2) {\n
      _ref1 = (function() {\n
        var _i, _len, _results;\n
\n
        _results = [];\n
        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n
          c = colors[_i];\n
          _results.push(c.lab());\n
        }\n
        return _results;\n
      })(), lab0 = _ref1[0], lab1 = _ref1[1];\n
      I = function(t) {\n
        var i, lab;\n
\n
        lab = (function() {\n
          var _i, _results;\n
\n
          _results = [];\n
          for (i = _i = 0; _i <= 2; i = ++_i) {\n
            _results.push(lab0[i] + t * (lab1[i] - lab0[i]));\n
          }\n
          return _results;\n
        })();\n
        return chroma.lab.apply(chroma, lab);\n
      };\n
    } else if (colors.length === 3) {\n
      _ref2 = (function() {\n
        var _i, _len, _results;\n
\n
        _results = [];\n
        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n
          c = colors[_i];\n
          _results.push(c.lab());\n
        }\n
        return _results;\n
      })(), lab0 = _ref2[0], lab1 = _ref2[1], lab2 = _ref2[2];\n
      I = function(t) {\n
        var i, lab;\n
\n
        lab = (function() {\n
          var _i, _results;\n
\n
          _results = [];\n
          for (i = _i = 0; _i <= 2; i = ++_i) {\n
            _results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);\n
          }\n
          return _results;\n
        })();\n
        return chroma.lab.apply(chroma, lab);\n
      };\n
    } else if (colors.length === 4) {\n
      _ref3 = (function() {\n
        var _i, _len, _results;\n
\n
        _results = [];\n
        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n
          c = colors[_i];\n
          _results.push(c.lab());\n
        }\n
        return _results;\n
      })(), lab0 = _ref3[0], lab1 = _ref3[1], lab2 = _ref3[2], lab3 = _ref3[3];\n
      I = function(t) {\n
        var i, lab;\n
\n
        lab = (function() {\n
          var _i, _results;\n
\n
          _results = [];\n
          for (i = _i = 0; _i <= 2; i = ++_i) {\n
            _results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);\n
          }\n
          return _results;\n
        })();\n
        return chroma.lab.apply(chroma, lab);\n
      };\n
    } else if (colors.length === 5) {\n
      I0 = bezier(colors.slice(0, 3));\n
      I1 = bezier(colors.slice(2, 5));\n
      I = function(t) {\n
        if (t < 0.5) {\n
          return I0(t * 2);\n
        } else {\n
          return I1((t - 0.5) * 2);\n
        }\n
      };\n
    }\n
    return I;\n
  };\n
\n
  chroma.interpolate.bezier = bezier;\n
\n
}).call(this);\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>57609</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>chroma.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
