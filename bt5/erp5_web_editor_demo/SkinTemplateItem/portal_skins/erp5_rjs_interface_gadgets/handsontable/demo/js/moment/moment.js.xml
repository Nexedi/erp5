<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272340.5</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>moment.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>99201</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>moment.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

//! moment.js\n
//! version : 2.9.0\n
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n
//! license : MIT\n
//! momentjs.com\n
\n
(function (undefined) {\n
    /************************************\n
        Constants\n
    ************************************/\n
\n
    var moment,\n
        VERSION = \'2.9.0\',\n
        // the global-scope this is NOT the global object in Node.js\n
        globalScope = (typeof global !== \'undefined\' && (typeof window === \'undefined\' || window === global.window)) ? global : this,\n
        oldGlobalMoment,\n
        round = Math.round,\n
        hasOwnProperty = Object.prototype.hasOwnProperty,\n
        i,\n
\n
        YEAR = 0,\n
        MONTH = 1,\n
        DATE = 2,\n
        HOUR = 3,\n
        MINUTE = 4,\n
        SECOND = 5,\n
        MILLISECOND = 6,\n
\n
        // internal storage for locale config files\n
        locales = {},\n
\n
        // extra moment internal properties (plugins register props here)\n
        momentProperties = [],\n
\n
        // check for nodeJS\n
        hasModule = (typeof module !== \'undefined\' && module && module.exports),\n
\n
        // ASP.NET json date format regex\n
        aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i,\n
        aspNetTimeSpanJsonRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/,\n
\n
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,\n
\n
        // format tokens\n
        formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,\n
        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n
\n
        // parsing token regexes\n
        parseTokenOneOrTwoDigits = /\\d\\d?/, // 0 - 99\n
        parseTokenOneToThreeDigits = /\\d{1,3}/, // 0 - 999\n
        parseTokenOneToFourDigits = /\\d{1,4}/, // 0 - 9999\n
        parseTokenOneToSixDigits = /[+\\-]?\\d{1,6}/, // -999,999 - 999,999\n
        parseTokenDigits = /\\d+/, // nonzero number of digits\n
        parseTokenWord = /[0-9]*[\'a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.\n
        parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\n
        parseTokenT = /T/i, // T (ISO separator)\n
        parseTokenOffsetMs = /[\\+\\-]?\\d+/, // 1234567890123\n
        parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\n
\n
        //strict parsing regexes\n
        parseTokenOneDigit = /\\d/, // 0 - 9\n
        parseTokenTwoDigits = /\\d\\d/, // 00 - 99\n
        parseTokenThreeDigits = /\\d{3}/, // 000 - 999\n
        parseTokenFourDigits = /\\d{4}/, // 0000 - 9999\n
        parseTokenSixDigits = /[+-]?\\d{6}/, // -999,999 - 999,999\n
        parseTokenSignedNumber = /[+-]?\\d+/, // -inf - inf\n
\n
        // iso 8601 regex\n
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n
        isoRegex = /^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n
\n
        isoFormat = \'YYYY-MM-DDTHH:mm:ssZ\',\n
\n
        isoDates = [\n
            [\'YYYYYY-MM-DD\', /[+-]\\d{6}-\\d{2}-\\d{2}/],\n
            [\'YYYY-MM-DD\', /\\d{4}-\\d{2}-\\d{2}/],\n
            [\'GGGG-[W]WW-E\', /\\d{4}-W\\d{2}-\\d/],\n
            [\'GGGG-[W]WW\', /\\d{4}-W\\d{2}/],\n
            [\'YYYY-DDD\', /\\d{4}-\\d{3}/]\n
        ],\n
\n
        // iso time formats and regexes\n
        isoTimes = [\n
            [\'HH:mm:ss.SSSS\', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n
            [\'HH:mm:ss\', /(T| )\\d\\d:\\d\\d:\\d\\d/],\n
            [\'HH:mm\', /(T| )\\d\\d:\\d\\d/],\n
            [\'HH\', /(T| )\\d\\d/]\n
        ],\n
\n
        // timezone chunker \'+10:00\' > [\'10\', \'00\'] or \'-1530\' > [\'-\', \'15\', \'30\']\n
        parseTimezoneChunker = /([\\+\\-]|\\d\\d)/gi,\n
\n
        // getter and setter names\n
        proxyGettersAndSetters = \'Date|Hours|Minutes|Seconds|Milliseconds\'.split(\'|\'),\n
        unitMillisecondFactors = {\n
            \'Milliseconds\' : 1,\n
            \'Seconds\' : 1e3,\n
            \'Minutes\' : 6e4,\n
            \'Hours\' : 36e5,\n
            \'Days\' : 864e5,\n
            \'Months\' : 2592e6,\n
            \'Years\' : 31536e6\n
        },\n
\n
        unitAliases = {\n
            ms : \'millisecond\',\n
            s : \'second\',\n
            m : \'minute\',\n
            h : \'hour\',\n
            d : \'day\',\n
            D : \'date\',\n
            w : \'week\',\n
            W : \'isoWeek\',\n
            M : \'month\',\n
            Q : \'quarter\',\n
            y : \'year\',\n
            DDD : \'dayOfYear\',\n
            e : \'weekday\',\n
            E : \'isoWeekday\',\n
            gg: \'weekYear\',\n
            GG: \'isoWeekYear\'\n
        },\n
\n
        camelFunctions = {\n
            dayofyear : \'dayOfYear\',\n
            isoweekday : \'isoWeekday\',\n
            isoweek : \'isoWeek\',\n
            weekyear : \'weekYear\',\n
            isoweekyear : \'isoWeekYear\'\n
        },\n
\n
        // format function strings\n
        formatFunctions = {},\n
\n
        // default relative time thresholds\n
        relativeTimeThresholds = {\n
            s: 45,  // seconds to minute\n
            m: 45,  // minutes to hour\n
            h: 22,  // hours to day\n
            d: 26,  // days to month\n
            M: 11   // months to year\n
        },\n
\n
        // tokens to ordinalize and pad\n
        ordinalizeTokens = \'DDD w W M D d\'.split(\' \'),\n
        paddedTokens = \'M D H h m s w W\'.split(\' \'),\n
\n
        formatTokenFunctions = {\n
            M    : function () {\n
                return this.month() + 1;\n
            },\n
            MMM  : function (format) {\n
                return this.localeData().monthsShort(this, format);\n
            },\n
            MMMM : function (format) {\n
                return this.localeData().months(this, format);\n
            },\n
            D    : function () {\n
                return this.date();\n
            },\n
            DDD  : function () {\n
                return this.dayOfYear();\n
            },\n
            d    : function () {\n
                return this.day();\n
            },\n
            dd   : function (format) {\n
                return this.localeData().weekdaysMin(this, format);\n
            },\n
            ddd  : function (format) {\n
                return this.localeData().weekdaysShort(this, format);\n
            },\n
            dddd : function (format) {\n
                return this.localeData().weekdays(this, format);\n
            },\n
            w    : function () {\n
                return this.week();\n
            },\n
            W    : function () {\n
                return this.isoWeek();\n
            },\n
            YY   : function () {\n
                return leftZeroFill(this.year() % 100, 2);\n
            },\n
            YYYY : function () {\n
                return leftZeroFill(this.year(), 4);\n
            },\n
            YYYYY : function () {\n
                return leftZeroFill(this.year(), 5);\n
            },\n
            YYYYYY : function () {\n
                var y = this.year(), sign = y >= 0 ? \'+\' : \'-\';\n
                return sign + leftZeroFill(Math.abs(y), 6);\n
            },\n
            gg   : function () {\n
                return leftZeroFill(this.weekYear() % 100, 2);\n
            },\n
            gggg : function () {\n
                return leftZeroFill(this.weekYear(), 4);\n
            },\n
            ggggg : function () {\n
                return leftZeroFill(this.weekYear(), 5);\n
            },\n
            GG   : function () {\n
                return leftZeroFill(this.isoWeekYear() % 100, 2);\n
            },\n
            GGGG : function () {\n
                return leftZeroFill(this.isoWeekYear(), 4);\n
            },\n
            GGGGG : function () {\n
                return leftZeroFill(this.isoWeekYear(), 5);\n
            },\n
            e : function () {\n
                return this.weekday();\n
            },\n
            E : function () {\n
                return this.isoWeekday();\n
            },\n
            a    : function () {\n
                return this.localeData().meridiem(this.hours(), this.minutes(), true);\n
            },\n
            A    : function () {\n
                return this.localeData().meridiem(this.hours(), this.minutes(), false);\n
            },\n
            H    : function () {\n
                return this.hours();\n
            },\n
            h    : function () {\n
                return this.hours() % 12 || 12;\n
            },\n
            m    : function () {\n
                return this.minutes();\n
            },\n
            s    : function () {\n
                return this.seconds();\n
            },\n
            S    : function () {\n
                return toInt(this.milliseconds() / 100);\n
            },\n
            SS   : function () {\n
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);\n
            },\n
            SSS  : function () {\n
                return leftZeroFill(this.milliseconds(), 3);\n
            },\n
            SSSS : function () {\n
                return leftZeroFill(this.milliseconds(), 3);\n
            },\n
            Z    : function () {\n
                var a = this.utcOffset(),\n
                    b = \'+\';\n
                if (a < 0) {\n
                    a = -a;\n
                    b = \'-\';\n
                }\n
                return b + leftZeroFill(toInt(a / 60), 2) + \':\' + leftZeroFill(toInt(a) % 60, 2);\n
            },\n
            ZZ   : function () {\n
                var a = this.utcOffset(),\n
                    b = \'+\';\n
                if (a < 0) {\n
                    a = -a;\n
                    b = \'-\';\n
                }\n
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);\n
            },\n
            z : function () {\n
                return this.zoneAbbr();\n
            },\n
            zz : function () {\n
                return this.zoneName();\n
            },\n
            x    : function () {\n
                return this.valueOf();\n
            },\n
            X    : function () {\n
                return this.unix();\n
            },\n
            Q : function () {\n
                return this.quarter();\n
            }\n
        },\n
\n
        deprecations = {},\n
\n
        lists = [\'months\', \'monthsShort\', \'weekdays\', \'weekdaysShort\', \'weekdaysMin\'],\n
\n
        updateInProgress = false;\n
\n
    // Pick the first defined of two or three arguments. dfl comes from\n
    // default.\n
    function dfl(a, b, c) {\n
        switch (arguments.length) {\n
            case 2: return a != null ? a : b;\n
            case 3: return a != null ? a : b != null ? b : c;\n
            default: throw new Error(\'Implement me\');\n
        }\n
    }\n
\n
    function hasOwnProp(a, b) {\n
        return hasOwnProperty.call(a, b);\n
    }\n
\n
    function defaultParsingFlags() {\n
        // We need to deep clone this object, and es5 standard is not very\n
        // helpful.\n
        return {\n
            empty : false,\n
            unusedTokens : [],\n
            unusedInput : [],\n
            overflow : -2,\n
            charsLeftOver : 0,\n
            nullInput : false,\n
            invalidMonth : null,\n
            invalidFormat : false,\n
            userInvalidated : false,\n
            iso: false\n
        };\n
    }\n
\n
    function printMsg(msg) {\n
        if (moment.suppressDeprecationWarnings === false &&\n
                typeof console !== \'undefined\' && console.warn) {\n
            console.warn(\'Deprecation warning: \' + msg);\n
        }\n
    }\n
\n
    function deprecate(msg, fn) {\n
        var firstTime = true;\n
        return extend(function () {\n
            if (firstTime) {\n
                printMsg(msg);\n
                firstTime = false;\n
            }\n
            return fn.apply(this, arguments);\n
        }, fn);\n
    }\n
\n
    function deprecateSimple(name, msg) {\n
        if (!deprecations[name]) {\n
            printMsg(msg);\n
            deprecations[name] = true;\n
        }\n
    }\n
\n
    function padToken(func, count) {\n
        return function (a) {\n
            return leftZeroFill(func.call(this, a), count);\n
        };\n
    }\n
    function ordinalizeToken(func, period) {\n
        return function (a) {\n
            return this.localeData().ordinal(func.call(this, a), period);\n
        };\n
    }\n
\n
    function monthDiff(a, b) {\n
        // difference in months\n
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n
            // b is in (anchor - 1 month, anchor + 1 month)\n
            anchor = a.clone().add(wholeMonthDiff, \'months\'),\n
            anchor2, adjust;\n
\n
        if (b - anchor < 0) {\n
            anchor2 = a.clone().add(wholeMonthDiff - 1, \'months\');\n
            // linear across the month\n
            adjust = (b - anchor) / (anchor - anchor2);\n
        } else {\n
            anchor2 = a.clone().add(wholeMonthDiff + 1, \'months\');\n
            // linear across the month\n
            adjust = (b - anchor) / (anchor2 - anchor);\n
        }\n
\n
        return -(wholeMonthDiff + adjust);\n
    }\n
\n
    while (ordinalizeTokens.length) {\n
        i = ordinalizeTokens.pop();\n
        formatTokenFunctions[i + \'o\'] = ordinalizeToken(formatTokenFunctions[i], i);\n
    }\n
    while (paddedTokens.length) {\n
        i = paddedTokens.pop();\n
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);\n
    }\n
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);\n
\n
\n
    function meridiemFixWrap(locale, hour, meridiem) {\n
        var isPm;\n
\n
        if (meridiem == null) {\n
            // nothing to do\n
            return hour;\n
        }\n
        if (locale.meridiemHour != null) {\n
            return locale.meridiemHour(hour, meridiem);\n
        } else if (locale.isPM != null) {\n
            // Fallback\n
            isPm = locale.isPM(meridiem);\n
            if (isPm && hour < 12) {\n
                hour += 12;\n
            }\n
            if (!isPm && hour === 12) {\n
                hour = 0;\n
            }\n
            return hour;\n
        } else {\n
            // thie is not supposed to happen\n
            return hour;\n
        }\n
    }\n
\n
    /************************************\n
        Constructors\n
    ************************************/\n
\n
    function Locale() {\n
    }\n
\n
    // Moment prototype object\n
    function Moment(config, skipOverflow) {\n
        if (skipOverflow !== false) {\n
            checkOverflow(config);\n
        }\n
        copyConfig(this, config);\n
        this._d = new Date(+config._d);\n
        // Prevent infinite loop in case updateOffset creates new moment\n
        // objects.\n
        if (updateInProgress === false) {\n
            updateInProgress = true;\n
            moment.updateOffset(this);\n
            updateInProgress = false;\n
        }\n
    }\n
\n
    // Duration Constructor\n
    function Duration(duration) {\n
        var normalizedInput = normalizeObjectUnits(duration),\n
            years = normalizedInput.year || 0,\n
            quarters = normalizedInput.quarter || 0,\n
            months = normalizedInput.month || 0,\n
            weeks = normalizedInput.week || 0,\n
            days = normalizedInput.day || 0,\n
            hours = normalizedInput.hour || 0,\n
            minutes = normalizedInput.minute || 0,\n
            seconds = normalizedInput.second || 0,\n
            milliseconds = normalizedInput.millisecond || 0;\n
\n
        // representation for dateAddRemove\n
        this._milliseconds = +milliseconds +\n
            seconds * 1e3 + // 1000\n
            minutes * 6e4 + // 1000 * 60\n
            hours * 36e5; // 1000 * 60 * 60\n
        // Because of dateAddRemove treats 24 hours as different from a\n
        // day when working around DST, we need to store them separately\n
        this._days = +days +\n
            weeks * 7;\n
        // It is impossible translate months into days without knowing\n
        // which months you are are talking about, so we have to store\n
        // it separately.\n
        this._months = +months +\n
            quarters * 3 +\n
            years * 12;\n
\n
        this._data = {};\n
\n
        this._locale = moment.localeData();\n
\n
        this._bubble();\n
    }\n
\n
    /************************************\n
        Helpers\n
    ************************************/\n
\n
\n
    function extend(a, b) {\n
        for (var i in b) {\n
            if (hasOwnProp(b, i)) {\n
                a[i] = b[i];\n
            }\n
        }\n
\n
        if (hasOwnProp(b, \'toString\')) {\n
            a.toString = b.toString;\n
        }\n
\n
        if (hasOwnProp(b, \'valueOf\')) {\n
            a.valueOf = b.valueOf;\n
        }\n
\n
        return a;\n
    }\n
\n
    function copyConfig(to, from) {\n
        var i, prop, val;\n
\n
        if (typeof from._isAMomentObject !== \'undefined\') {\n
            to._isAMomentObject = from._isAMomentObject;\n
        }\n
        if (typeof from._i !== \'undefined\') {\n
            to._i = from._i;\n
        }\n
        if (typeof from._f !== \'undefined\') {\n
            to._f = from._f;\n
        }\n
        if (typeof from._l !== \'undefined\') {\n
            to._l = from._l;\n
        }\n
        if (typeof from._strict !== \'undefined\') {\n
            to._strict = from._strict;\n
        }\n
        if (typeof from._tzm !== \'undefined\') {\n
            to._tzm = from._tzm;\n
        }\n
        if (typeof from._isUTC !== \'undefined\') {\n
            to._isUTC = from._isUTC;\n
        }\n
        if (typeof from._offset !== \'undefined\') {\n
            to._offset = from._offset;\n
        }\n
        if (typeof from._pf !== \'undefined\') {\n
            to._pf = from._pf;\n
        }\n
        if (typeof from._locale !== \'undefined\') {\n
            to._locale = from._locale;\n
        }\n
\n
        if (momentProperties.length > 0) {\n
            for (i in momentProperties) {\n
                prop = momentProperties[i];\n
                val = from[prop];\n
                if (typeof val !== \'undefined\') {\n
                    to[prop] = val;\n
                }\n
            }\n
        }\n
\n
        return to;\n
    }\n
\n
    function absRound(number) {\n
        if (number < 0) {\n
            return Math.ceil(number);\n
        } else {\n
            return Math.floor(number);\n
        }\n
    }\n
\n
    // left zero fill a number\n
    // see http://jsperf.com/left-zero-filling for performance comparison\n
    function leftZeroFill(number, targetLength, forceSign) {\n
        var output = \'\' + Math.abs(number),\n
            sign = number >= 0;\n
\n
        while (output.length < targetLength) {\n
            output = \'0\' + output;\n
        }\n
        return (sign ? (forceSign ? \'+\' : \'\') : \'-\') + output;\n
    }\n
\n
    function positiveMomentsDifference(base, other) {\n
        var res = {milliseconds: 0, months: 0};\n
\n
        res.months = other.month() - base.month() +\n
            (other.year() - base.year()) * 12;\n
        if (base.clone().add(res.months, \'M\').isAfter(other)) {\n
            --res.months;\n
        }\n
\n
        res.milliseconds = +other - +(base.clone().add(res.months, \'M\'));\n
\n
        return res;\n
    }\n
\n
    function momentsDifference(base, other) {\n
        var res;\n
        other = makeAs(other, base);\n
        if (base.isBefore(other)) {\n
            res = positiveMomentsDifference(base, other);\n
        } else {\n
            res = positiveMomentsDifference(other, base);\n
            res.milliseconds = -res.milliseconds;\n
            res.months = -res.months;\n
        }\n
\n
        return res;\n
    }\n
\n
    // TODO: remove \'name\' arg after deprecation is removed\n
    function createAdder(direction, name) {\n
        return function (val, period) {\n
            var dur, tmp;\n
            //invert the arguments, but complain about it\n
            if (period !== null && !isNaN(+period)) {\n
                deprecateSimple(name, \'moment().\' + name  + \'(period, number) is deprecated. Please use moment().\' + name + \'(number, period).\');\n
                tmp = val; val = period; period = tmp;\n
            }\n
\n
            val = typeof val === \'string\' ? +val : val;\n
            dur = moment.duration(val, period);\n
            addOrSubtractDurationFromMoment(this, dur, direction);\n
            return this;\n
        };\n
    }\n
\n
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {\n
        var milliseconds = duration._milliseconds,\n
            days = duration._days,\n
            months = duration._months;\n
        updateOffset = updateOffset == null ? true : updateOffset;\n
\n
        if (milliseconds) {\n
            mom._d.setTime(+mom._d + milliseconds * isAdding);\n
        }\n
        if (days) {\n
            rawSetter(mom, \'Date\', rawGetter(mom, \'Date\') + days * isAdding);\n
        }\n
        if (months) {\n
            rawMonthSetter(mom, rawGetter(mom, \'Month\') + months * isAdding);\n
        }\n
        if (updateOffset) {\n
            moment.updateOffset(mom, days || months);\n
        }\n
    }\n
\n
    // check if is an array\n
    function isArray(input) {\n
        return Object.prototype.toString.call(input) === \'[object Array]\';\n
    }\n
\n
    function isDate(input) {\n
        return Object.prototype.toString.call(input) === \'[object Date]\' ||\n
            input instanceof Date;\n
    }\n
\n
    // compare two arrays, return the number of differences\n
    function compareArrays(array1, array2, dontConvert) {\n
        var len = Math.min(array1.length, array2.length),\n
            lengthDiff = Math.abs(array1.length - array2.length),\n
            diffs = 0,\n
            i;\n
        for (i = 0; i < len; i++) {\n
            if ((dontConvert && array1[i] !== array2[i]) ||\n
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n
                diffs++;\n
            }\n
        }\n
        return diffs + lengthDiff;\n
    }\n
\n
    function normalizeUnits(units) {\n
        if (units) {\n
            var lowered = units.toLowerCase().replace(/(.)s$/, \'$1\');\n
            units = unitAliases[units] || camelFunctions[lowered] || lowered;\n
        }\n
        return units;\n
    }\n
\n
    function normalizeObjectUnits(inputObject) {\n
        var normalizedInput = {},\n
            normalizedProp,\n
            prop;\n
\n
        for (prop in inputObject) {\n
            if (hasOwnProp(inputObject, prop)) {\n
                normalizedProp = normalizeUnits(prop);\n
                if (normalizedProp) {\n
                    normalizedInput[normalizedProp] = inputObject[prop];\n
                }\n
            }\n
        }\n
\n
        return normalizedInput;\n
    }\n
\n
    function makeList(field) {\n
        var count, setter;\n
\n
        if (field.indexOf(\'week\') === 0) {\n
            count = 7;\n
            setter = \'day\';\n
        }\n
        else if (field.indexOf(\'month\') === 0) {\n
            count = 12;\n
            setter = \'month\';\n
        }\n
        else {\n
            return;\n
        }\n
\n
        moment[field] = function (format, index) {\n
            var i, getter,\n
                method = moment._locale[field],\n
                results = [];\n
\n
            if (typeof format === \'number\') {\n
                index = format;\n
                format = undefined;\n
            }\n
\n
            getter = function (i) {\n
                var m = moment().utc().set(setter, i);\n
                return method.call(moment._locale, m, format || \'\');\n
            };\n
\n
            if (index != null) {\n
                return getter(index);\n
            }\n
            else {\n
                for (i = 0; i < count; i++) {\n
                    results.push(getter(i));\n
                }\n
                return results;\n
            }\n
        };\n
    }\n
\n
    function toInt(argumentForCoercion) {\n
        var coercedNumber = +argumentForCoercion,\n
            value = 0;\n
\n
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n
            if (coercedNumber >= 0) {\n
                value = Math.floor(coercedNumber);\n
            } else {\n
                value = Math.ceil(coercedNumber);\n
            }\n
        }\n
\n
        return value;\n
    }\n
\n
    function daysInMonth(year, month) {\n
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n
    }\n
\n
    function weeksInYear(year, dow, doy) {\n
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;\n
    }\n
\n
    function daysInYear(year) {\n
        return isLeapYear(year) ? 366 : 365;\n
    }\n
\n
    function isLeapYear(year) {\n
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n
    }\n
\n
    function checkOverflow(m) {\n
        var overflow;\n
        if (m._a && m._pf.overflow === -2) {\n
            overflow =\n
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :\n
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :\n
                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||\n
                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||\n
                                           m._a[SECOND] !== 0 ||\n
                                           m._a[MILLISECOND] !== 0)) ? HOUR :\n
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :\n
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :\n
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :\n
                -1;\n
\n
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n
                overflow = DATE;\n
            }\n
\n
            m._pf.overflow = overflow;\n
        }\n
    }\n
\n
    function isValid(m) {\n
        if (m._isValid == null) {\n
            m._isValid = !isNaN(m._d.getTime()) &&\n
                m._pf.overflow < 0 &&\n
                !m._pf.empty &&\n
                !m._pf.invalidMonth &&\n
                !m._pf.nullInput &&\n
                !m._pf.invalidFormat &&\n
                !m._pf.userInvalidated;\n
\n
            if (m._strict) {\n
                m._isValid = m._isValid &&\n
                    m._pf.charsLeftOver === 0 &&\n
                    m._pf.unusedTokens.length === 0 &&\n
                    m._pf.bigHour === undefined;\n
            }\n
        }\n
        return m._isValid;\n
    }\n
\n
    function normalizeLocale(key) {\n
        return key ? key.toLowerCase().replace(\'_\', \'-\') : key;\n
    }\n
\n
    // pick the locale from the array\n
    // try [\'en-au\', \'en-gb\'] as \'en-au\', \'en-gb\', \'en\', as in move through the list trying each\n
    // substring from most specific to least, but move to the next array item if it\'s a more specific variant than the current root\n
    function chooseLocale(names) {\n
        var i = 0, j, next, locale, split;\n
\n
        while (i < names.length) {\n
            split = normalizeLocale(names[i]).split(\'-\');\n
            j = split.length;\n
            next = normalizeLocale(names[i + 1]);\n
            next = next ? next.split(\'-\') : null;\n
            while (j > 0) {\n
                locale = loadLocale(split.slice(0, j).join(\'-\'));\n
                if (locale) {\n
                    return locale;\n
                }\n
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n
                    //the next array item is better than a shallower substring of this one\n
                    break;\n
                }\n
                j--;\n
            }\n
            i++;\n
        }\n
        return null;\n
    }\n
\n
    function loadLocale(name) {\n
        var oldLocale = null;\n
        if (!locales[name] && hasModule) {\n
            try {\n
                oldLocale = moment.locale();\n
                require(\'./locale/\' + name);\n
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales\n
                moment.locale(oldLocale);\n
            } catch (e) { }\n
        }\n
        return locales[name];\n
    }\n
\n
    // Return a moment from input, that is local/utc/utcOffset equivalent to\n
    // model.\n
    function makeAs(input, model) {\n
        var res, diff;\n
        if (model._isUTC) {\n
            res = model.clone();\n
            diff = (moment.isMoment(input) || isDate(input) ?\n
                    +input : +moment(input)) - (+res);\n
            // Use low-level api, because this fn is low-level api.\n
            res._d.setTime(+res._d + diff);\n
            moment.updateOffset(res, false);\n
            return res;\n
        } else {\n
            return moment(input).local();\n
        }\n
    }\n
\n
    /************************************\n
        Locale\n
    ************************************/\n
\n
\n
    extend(Locale.prototype, {\n
\n
        set : function (config) {\n
            var prop, i;\n
            for (i in config) {\n
                prop = config[i];\n
                if (typeof prop === \'function\') {\n
                    this[i] = prop;\n
                } else {\n
                    this[\'_\' + i] = prop;\n
                }\n
            }\n
            // Lenient ordinal parsing accepts just a number in addition to\n
            // number + (possibly) stuff coming from _ordinalParseLenient.\n
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + \'|\' + /\\d{1,2}/.source);\n
        },\n
\n
        _months : \'January_February_March_April_May_June_July_August_September_October_November_December\'.split(\'_\'),\n
        months : function (m) {\n
            return this._months[m.month()];\n
        },\n
\n
        _monthsShort : \'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\'.split(\'_\'),\n
        monthsShort : function (m) {\n
            return this._monthsShort[m.month()];\n
        },\n
\n
        monthsParse : function (monthName, format, strict) {\n
            var i, mom, regex;\n
\n
            if (!this._monthsParse) {\n
                this._monthsParse = [];\n
                this._longMonthsParse = [];\n
                this._shortMonthsParse = [];\n
            }\n
\n
            for (i = 0; i < 12; i++) {\n
                // make the regex if we don\'t have it already\n
                mom = moment.utc([2000, i]);\n
                if (strict && !this._longMonthsParse[i]) {\n
                    this._longMonthsParse[i] = new RegExp(\'^\' + this.months(mom, \'\').replace(\'.\', \'\') + \'$\', \'i\');\n
                    this._shortMonthsParse[i] = new RegExp(\'^\' + this.monthsShort(mom, \'\').replace(\'.\', \'\') + \'$\', \'i\');\n
                }\n
                if (!strict && !this._monthsParse[i]) {\n
                    regex = \'^\' + this.months(mom, \'\') + \'|^\' + this.monthsShort(mom, \'\');\n
                    this._monthsParse[i] = new RegExp(regex.replace(\'.\', \'\'), \'i\');\n
                }\n
                // test the regex\n
                if (strict && format === \'MMMM\' && this._longMonthsParse[i].test(monthName)) {\n
                    return i;\n
                } else if (strict && format === \'MMM\' && this._shortMonthsParse[i].test(monthName)) {\n
                    return i;\n
                } else if (!strict && this._monthsParse[i].test(monthName)) {\n
                    return i;\n
                }\n
            }\n
        },\n
\n
        _weekdays : \'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\'.split(\'_\'),\n
        weekdays : function (m) {\n
            return this._weekdays[m.day()];\n
        },\n
\n
        _weekdaysShort : \'Sun_Mon_Tue_Wed_Thu_Fri_Sat\'.split(\'_\'),\n
        weekdaysShort : function (m) {\n
            return this._weekdaysShort[m.day()];\n
        },\n
\n
        _weekdaysMin : \'Su_Mo_Tu_We_Th_Fr_Sa\'.split(\'_\'),\n
        weekdaysMin : function (m) {\n
            return this._weekdaysMin[m.day()];\n
        },\n
\n
        weekdaysParse : function (weekdayName) {\n
            var i, mom, regex;\n
\n
            if (!this._weekdaysParse) {\n
                this._weekdaysParse = [];\n
            }\n
\n
            for (i = 0; i < 7; i++) {\n
                // make the regex if we don\'t have it already\n
                if (!this._weekdaysParse[i]) {\n
                    mom = moment([2000, 1]).day(i);\n
                    regex = \'^\' + this.weekdays(mom, \'\') + \'|^\' + this.weekdaysShort(mom, \'\') + \'|^\' + this.weekdaysMin(mom, \'\');\n
                    this._weekdaysParse[i] = new RegExp(regex.replace(\'.\', \'\'), \'i\');\n
                }\n
                // test the regex\n
                if (this._weekdaysParse[i].test(weekdayName)) {\n
                    return i;\n
                }\n
            }\n
        },\n
\n
        _longDateFormat : {\n
            LTS : \'h:mm:ss A\',\n
            LT : \'h:mm A\',\n
            L : \'MM/DD/YYYY\',\n
            LL : \'MMMM D, YYYY\',\n
            LLL : \'MMMM D, YYYY LT\',\n
            LLLL : \'dddd, MMMM D, YYYY LT\'\n
        },\n
        longDateFormat : function (key) {\n
            var output = this._longDateFormat[key];\n
            if (!output && this._longDateFormat[key.toUpperCase()]) {\n
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {\n
                    return val.slice(1);\n
                });\n
                this._longDateFormat[key] = output;\n
            }\n
            return output;\n
        },\n
\n
        isPM : function (input) {\n
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n
            // Using charAt should be more compatible.\n
            return ((input + \'\').toLowerCase().charAt(0) === \'p\');\n
        },\n
\n
        _meridiemParse : /[ap]\\.?m?\\.?/i,\n
        meridiem : function (hours, minutes, isLower) {\n
            if (hours > 11) {\n
                return isLower ? \'pm\' : \'PM\';\n
            } else {\n
                return isLower ? \'am\' : \'AM\';\n
            }\n
        },\n
\n
\n
        _calendar : {\n
            sameDay : \'[Today at] LT\',\n
            nextDay : \'[Tomorrow at] LT\',\n
            nextWeek : \'dddd [at] LT\',\n
            lastDay : \'[Yesterday at] LT\',\n
            lastWeek : \'[Last] dddd [at] LT\',\n
            sameElse : \'L\'\n
        },\n
        calendar : function (key, mom, now) {\n
            var output = this._calendar[key];\n
            return typeof output === \'function\' ? output.apply(mom, [now]) : output;\n
        },\n
\n
        _relativeTime : {\n
            future : \'in %s\',\n
            past : \'%s ago\',\n
            s : \'a few seconds\',\n
            m : \'a minute\',\n
            mm : \'%d minutes\',\n
            h : \'an hour\',\n
            hh : \'%d hours\',\n
            d : \'a day\',\n
            dd : \'%d days\',\n
            M : \'a month\',\n
            MM : \'%d months\',\n
            y : \'a year\',\n
            yy : \'%d years\'\n
        },\n
\n
        relativeTime : function (number, withoutSuffix, string, isFuture) {\n
            var output = this._relativeTime[string];\n
            return (typeof output === \'function\') ?\n
                output(number, withoutSuffix, string, isFuture) :\n
                output.replace(/%d/i, number);\n
        },\n
\n
        pastFuture : function (diff, output) {\n
            var format = this._relativeTime[diff > 0 ? \'future\' : \'past\'];\n
            return typeof format === \'function\' ? format(output) : format.replace(/%s/i, output);\n
        },\n
\n
        ordinal : function (number) {\n
            return this._ordinal.replace(\'%d\', number);\n
        },\n
        _ordinal : \'%d\',\n
        _ordinalParse : /\\d{1,2}/,\n
\n
        preparse : function (string) {\n
            return string;\n
        },\n
\n
        postformat : function (string) {\n
            return string;\n
        },\n
\n
        week : function (mom) {\n
            return weekOfYear(mom, this._week.dow, this._week.doy).week;\n
        },\n
\n
        _week : {\n
            dow : 0, // Sunday is the first day of the week.\n
            doy : 6  // The week that contains Jan 1st is the first week of the year.\n
        },\n
\n
        firstDayOfWeek : function () {\n
            return this._week.dow;\n
        },\n
\n
        firstDayOfYear : function () {\n
            return this._week.doy;\n
        },\n
\n
        _invalidDate: \'Invalid date\',\n
        invalidDate: function () {\n
            return this._invalidDate;\n
        }\n
    });\n
\n
    /************************************\n
        Formatting\n
    ************************************/\n
\n
\n
    function removeFormattingTokens(input) {\n
        if (input.match(/\\[[\\s\\S]/)) {\n
            return input.replace(/^\\[|\\]$/g, \'\');\n
        }\n
        return input.replace(/\\\\/g, \'\');\n
    }\n
\n
    function makeFormatFunction(format) {\n
        var array = format.match(formattingTokens), i, length;\n
\n
        for (i = 0, length = array.length; i < length; i++) {\n
            if (formatTokenFunctions[array[i]]) {\n
                array[i] = formatTokenFunctions[array[i]];\n
            } else {\n
                array[i] = removeFormattingTokens(array[i]);\n
            }\n
        }\n
\n
        return function (mom) {\n
            var output = \'\';\n
            for (i = 0; i < length; i++) {\n
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n
            }\n
            return output;\n
        };\n
    }\n
\n
    // format date using native date object\n
    function formatMoment(m, format) {\n
        if (!m.isValid()) {\n
            return m.localeData().invalidDate();\n
        }\n
\n
        format = expandFormat(format, m.localeData());\n
\n
        if (!formatFunctions[format]) {\n
            formatFunctions[format] = makeFormatFunction(format);\n
        }\n
\n
        return formatFunctions[format](m);\n
    }\n
\n
    function expandFormat(format, locale) {\n
        var i = 5;\n
\n
        function replaceLongDateFormatTokens(input) {\n
            return locale.longDateFormat(input) || input;\n
        }\n
\n
        localFormattingTokens.lastIndex = 0;\n
        while (i >= 0 && localFormattingTokens.test(format)) {\n
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n
            localFormattingTokens.lastIndex = 0;\n
            i -= 1;\n
        }\n
\n
        return format;\n
    }\n
\n
\n
    /************************************\n
        Parsing\n
    ************************************/\n
\n
\n
    // get the regex to find the next token\n
    function getParseRegexForToken(token, config) {\n
        var a, strict = config._strict;\n
        switch (token) {\n
        case \'Q\':\n
            return parseTokenOneDigit;\n
        case \'DDDD\':\n
            return parseTokenThreeDigits;\n
        case \'YYYY\':\n
        case \'GGGG\':\n
        case \'gggg\':\n
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;\n
        case \'Y\':\n
        case \'G\':\n
        case \'g\':\n
            return parseTokenSignedNumber;\n
        case \'YYYYYY\':\n
        case \'YYYYY\':\n
        case \'GGGGG\':\n
        case \'ggggg\':\n
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;\n
        case \'S\':\n
            if (strict) {\n
                return parseTokenOneDigit;\n
            }\n
            /* falls through */\n
        case \'SS\':\n
            if (strict) {\n
                return parseTokenTwoDigits;\n
            }\n
            /* falls through */\n
        case \'SSS\':\n
            if (strict) {\n
                return parseTokenThreeDigits;\n
            }\n
            /* falls through */\n
        case \'DDD\':\n
            return parseTokenOneToThreeDigits;\n
        case \'MMM\':\n
        case \'MMMM\':\n
        case \'dd\':\n
        case \'ddd\':\n
        case \'dddd\':\n
            return parseTokenWord;\n
        case \'a\':\n
        case \'A\':\n
            return config._locale._meridiemParse;\n
        case \'x\':\n
            return parseTokenOffsetMs;\n
        case \'X\':\n
            return parseTokenTimestampMs;\n
        case \'Z\':\n
        case \'ZZ\':\n
            return parseTokenTimezone;\n
        case \'T\':\n
            return parseTokenT;\n
        case \'SSSS\':\n
            return parseTokenDigits;\n
        case \'MM\':\n
        case \'DD\':\n
        case \'YY\':\n
        case \'GG\':\n
        case \'gg\':\n
        case \'HH\':\n
        case \'hh\':\n
        case \'mm\':\n
        case \'ss\':\n
        case \'ww\':\n
        case \'WW\':\n
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;\n
        case \'M\':\n
        case \'D\':\n
        case \'d\':\n
        case \'H\':\n
        case \'h\':\n
        case \'m\':\n
        case \'s\':\n
        case \'w\':\n
        case \'W\':\n
        case \'e\':\n
        case \'E\':\n
            return parseTokenOneOrTwoDigits;\n
        case \'Do\':\n
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;\n
        default :\n
            a = new RegExp(regexpEscape(unescapeFormat(token.replace(\'\\\\\', \'\')), \'i\'));\n
            return a;\n
        }\n
    }\n
\n
    function utcOffsetFromString(string) {\n
        string = string || \'\';\n
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),\n
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],\n
            parts = (tzChunk + \'\').match(parseTimezoneChunker) || [\'-\', 0, 0],\n
            minutes = +(parts[1] * 60) + toInt(parts[2]);\n
\n
        return parts[0] === \'+\' ? minutes : -minutes;\n
    }\n
\n
    // function to convert string input to date\n
    function addTimeToArrayFromToken(token, input, config) {\n
        var a, datePartArray = config._a;\n
\n
        switch (token) {\n
        // QUARTER\n
        case \'Q\':\n
            if (input != null) {\n
                datePartArray[MONTH] = (toInt(input) - 1) * 3;\n
            }\n
            break;\n
        // MONTH\n
        case \'M\' : // fall through to MM\n
        case \'MM\' :\n
            if (input != null) {\n
                datePartArray[MONTH] = toInt(input) - 1;\n
            }\n
            break;\n
        case \'MMM\' : // fall through to MMMM\n
        case \'MMMM\' :\n
            a = config._locale.monthsParse(input, token, config._strict);\n
            // if we didn\'t find a month name, mark the date as invalid.\n
            if (a != null) {\n
                datePartArray[MONTH] = a;\n
            } else {\n
                config._pf.invalidMonth = input;\n
            }\n
            break;\n
        // DAY OF MONTH\n
        case \'D\' : // fall through to DD\n
        case \'DD\' :\n
            if (input != null) {\n
                datePartArray[DATE] = toInt(input);\n
            }\n
            break;\n
        case \'Do\' :\n
            if (input != null) {\n
                datePartArray[DATE] = toInt(parseInt(\n
                            input.match(/\\d{1,2}/)[0], 10));\n
            }\n
            break;\n
        // DAY OF YEAR\n
        case \'DDD\' : // fall through to DDDD\n
        case \'DDDD\' :\n
            if (input != null) {\n
                config._dayOfYear = toInt(input);\n
            }\n
\n
            break;\n
        // YEAR\n
        case \'YY\' :\n
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);\n
            break;\n
        case \'YYYY\' :\n
        case \'YYYYY\' :\n
        case \'YYYYYY\' :\n
            datePartArray[YEAR] = toInt(input);\n
            break;\n
        // AM / PM\n
        case \'a\' : // fall through to A\n
        case \'A\' :\n
            config._meridiem = input;\n
            // config._isPm = config._locale.isPM(input);\n
            break;\n
        // HOUR\n
        case \'h\' : // fall through to hh\n
        case \'hh\' :\n
            config._pf.bigHour = true;\n
            /* falls through */\n
        case \'H\' : // fall through to HH\n
        case \'HH\' :\n
            datePartArray[HOUR] = toInt(input);\n
            break;\n
        // MINUTE\n
        case \'m\' : // fall through to mm\n
        case \'mm\' :\n
            datePartArray[MINUTE] = toInt(input);\n
            break;\n
        // SECOND\n
        case \'s\' : // fall through to ss\n
        case \'ss\' :\n
            datePartArray[SECOND] = toInt(input);\n
            break;\n
        // MILLISECOND\n
        case \'S\' :\n
        case \'SS\' :\n
        case \'SSS\' :\n
        case \'SSSS\' :\n
            datePartArray[MILLISECOND] = toInt((\'0.\' + input) * 1000);\n
            break;\n
        // UNIX OFFSET (MILLISECONDS)\n
        case \'x\':\n
            config._d = new Date(toInt(input));\n
            break;\n
        // UNIX TIMESTAMP WITH MS\n
        case \'X\':\n
            config._d = new Date(parseFloat(input) * 1000);\n
            break;\n
        // TIMEZONE\n
        case \'Z\' : // fall through to ZZ\n
        case \'ZZ\' :\n
            config._useUTC = true;\n
            config._tzm = utcOffsetFromString(input);\n
            break;\n
        // WEEKDAY - human\n
        case \'dd\':\n
        case \'ddd\':\n
        case \'dddd\':\n
            a = config._locale.weekdaysParse(input);\n
            // if we didn\'t get a weekday name, mark the date as invalid\n
            if (a != null) {\n
                config._w = config._w || {};\n
                config._w[\'d\'] = a;\n
            } else {\n
                config._pf.invalidWeekday = input;\n
            }\n
            break;\n
        // WEEK, WEEK DAY - numeric\n
        case \'w\':\n
        case \'ww\':\n
        case \'W\':\n
        case \'WW\':\n
        case \'d\':\n
        case \'e\':\n
        case \'E\':\n
            token = token.substr(0, 1);\n
            /* falls through */\n
        case \'gggg\':\n
        case \'GGGG\':\n
        case \'GGGGG\':\n
            token = token.substr(0, 2);\n
            if (input) {\n
                config._w = config._w || {};\n
                config._w[token] = toInt(input);\n
            }\n
            break;\n
        case \'gg\':\n
        case \'GG\':\n
            config._w = config._w || {};\n
            config._w[token] = moment.parseTwoDigitYear(input);\n
        }\n
    }\n
\n
    function dayOfYearFromWeekInfo(config) {\n
        var w, weekYear, week, weekday, dow, doy, temp;\n
\n
        w = config._w;\n
        if (w.GG != null || w.W != null || w.E != null) {\n
            dow = 1;\n
            doy = 4;\n
\n
            // TODO: We need to take the current isoWeekYear, but that depends on\n
            // how we interpret now (local, utc, fixed offset). So create\n
            // a now version of current config (take local/utc/offset flags, and\n
            // create now).\n
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);\n
            week = dfl(w.W, 1);\n
            weekday = dfl(w.E, 1);\n
        } else {\n
            dow = config._locale._week.dow;\n
            doy = config._locale._week.doy;\n
\n
            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);\n
            week = dfl(w.w, 1);\n
\n
            if (w.d != null) {\n
                // weekday -- low day numbers are considered next week\n
                weekday = w.d;\n
                if (weekday < dow) {\n
                    ++week;\n
                }\n
            } else if (w.e != null) {\n
                // local weekday -- counting starts from begining of week\n
                weekday = w.e + dow;\n
            } else {\n
                // default to begining of week\n
                weekday = dow;\n
            }\n
        }\n
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);\n
\n
        config._a[YEAR] = temp.year;\n
        config._dayOfYear = temp.dayOfYear;\n
    }\n
\n
    // convert an array to a date.\n
    // the array should mirror the parameters below\n
    // note: all values past the year are optional and will default to the lowest possible value.\n
    // [year, month, day , hour, minute, second, millisecond]\n
    function dateFromConfig(config) {\n
        var i, date, input = [], currentDate, yearToUse;\n
\n
        if (config._d) {\n
            return;\n
        }\n
\n
        currentDate = currentDateArray(config);\n
\n
        //compute day of the year from weeks and weekdays\n
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n
            dayOfYearFromWeekInfo(config);\n
        }\n
\n
        //if the day of the year is set, figure out what it is\n
        if (config._dayOfYear) {\n
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);\n
\n
            if (config._dayOfYear > daysInYear(yearToUse)) {\n
                config._pf._overflowDayOfYear = true;\n
            }\n
\n
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);\n
            config._a[MONTH] = date.getUTCMonth();\n
            config._a[DATE] = date.getUTCDate();\n
        }\n
\n
        // Default to current date.\n
        // * if no year, month, day of month are given, default to today\n
        // * if day of month is given, default month and year\n
        // * if month is given, default only year\n
        // * if year is given, don\'t default anything\n
        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n
            config._a[i] = input[i] = currentDate[i];\n
        }\n
\n
        // Zero out whatever was not defaulted, including time\n
        for (; i < 7; i++) {\n
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n
        }\n
\n
        // Check for 24:00:00.000\n
        if (config._a[HOUR] === 24 &&\n
                config._a[MINUTE] === 0 &&\n
                config._a[SECOND] === 0 &&\n
                config._a[MILLISECOND] === 0) {\n
            config._nextDay = true;\n
            config._a[HOUR] = 0;\n
        }\n
\n
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);\n
        // Apply timezone offset from input. The actual utcOffset can be changed\n
        // with parseZone.\n
        if (config._tzm != null) {\n
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n
        }\n
\n
        if (config._nextDay) {\n
            config._a[HOUR] = 24;\n
        }\n
    }\n
\n
    function dateFromObject(config) {\n
        var normalizedInput;\n
\n
        if (config._d) {\n
            return;\n
        }\n
\n
        normalizedInput = normalizeObjectUnits(config._i);\n
        config._a = [\n
            normalizedInput.year,\n
            normalizedInput.month,\n
            normalizedInput.day || normalizedInput.date,\n
            normalizedInput.hour,\n
            normalizedInput.minute,\n
            normalizedInput.second,\n
            normalizedInput.millisecond\n
        ];\n
\n
        dateFromConfig(config);\n
    }\n
\n
    function currentDateArray(config) {\n
        var now = new Date();\n
        if (config._useUTC) {\n
            return [\n
                now.getUTCFullYear(),\n
                now.getUTCMonth(),\n
                now.getUTCDate()\n
            ];\n
        } else {\n
            return [now.getFullYear(), now.getMonth(), now.getDate()];\n
        }\n
    }\n
\n
    // date from string and format string\n
    function makeDateFromStringAndFormat(config) {\n
        if (config._f === moment.ISO_8601) {\n
            parseISO(config);\n
            return;\n
        }\n
\n
        config._a = [];\n
        config._pf.empty = true;\n
\n
        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n
        var string = \'\' + config._i,\n
            i, parsedInput, tokens, token, skipped,\n
            stringLength = string.length,\n
            totalParsedInputLength = 0;\n
\n
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n
\n
        for (i = 0; i < tokens.length; i++) {\n
            token = tokens[i];\n
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n
            if (parsedInput) {\n
                skipped = string.substr(0, string.indexOf(parsedInput));\n
                if (skipped.length > 0) {\n
                    config._pf.unusedInput.push(skipped);\n
                }\n
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n
                totalParsedInputLength += parsedInput.length;\n
            }\n
            // don\'t parse if it\'s not a known token\n
            if (formatTokenFunctions[token]) {\n
                if (parsedInput) {\n
                    config._pf.empty = false;\n
                }\n
                else {\n
                    config._pf.unusedTokens.push(token);\n
                }\n
                addTimeToArrayFromToken(token, parsedInput, config);\n
            }\n
            else if (config._strict && !parsedInput) {\n
                config._pf.unusedTokens.push(token);\n
            }\n
        }\n
\n
        // add remaining unparsed input length to the string\n
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;\n
        if (string.length > 0) {\n
            config._pf.unusedInput.push(string);\n
        }\n
\n
        // clear _12h flag if hour is <= 12\n
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {\n
            config._pf.bigHour = undefined;\n
        }\n
        // handle meridiem\n
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR],\n
                config._meridiem);\n
        dateFromConfig(config);\n
        checkOverflow(config);\n
    }\n
\n
    function unescapeFormat(s) {\n
        return s.replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n
            return p1 || p2 || p3 || p4;\n
        });\n
    }\n
\n
    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n
    function regexpEscape(s) {\n
        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \'\\\\$&\');\n
    }\n
\n
    // date from string and array of format strings\n
    function makeDateFromStringAndArray(config) {\n
        var tempConfig,\n
            bestMoment,\n
\n
            scoreToBeat,\n
            i,\n
            currentScore;\n
\n
        if (config._f.length === 0) {\n
            config._pf.invalidFormat = true;\n
            config._d = new Date(NaN);\n
            return;\n
        }\n
\n
        for (i = 0; i < config._f.length; i++) {\n
            currentScore = 0;\n
            tempConfig = copyConfig({}, config);\n
            if (config._useUTC != null) {\n
                tempConfig._useUTC = config._useUTC;\n
            }\n
            tempConfig._pf = defaultParsingFlags();\n
            tempConfig._f = config._f[i];\n
            makeDateFromStringAndFormat(tempConfig);\n
\n
            if (!isValid(tempConfig)) {\n
                continue;\n
            }\n
\n
            // if there is any input that was not parsed add a penalty for that format\n
            currentScore += tempConfig._pf.charsLeftOver;\n
\n
            //or tokens\n
            currentScore += tempConfig._pf.unusedTokens.length * 10;\n
\n
            tempConfig._pf.score = currentScore;\n
\n
            if (scoreToBeat == null || currentScore < scoreToBeat) {\n
                scoreToBeat = currentScore;\n
                bestMoment = tempConfig;\n
            }\n
        }\n
\n
        extend(config, bestMoment || tempConfig);\n
    }\n
\n
    // date from iso format\n
    function parseISO(config) {\n
        var i, l,\n
            string = config._i,\n
            match = isoRegex.exec(string);\n
\n
        if (match) {\n
            config._pf.iso = true;\n
            for (i = 0, l = isoDates.length; i < l; i++) {\n
                if (isoDates[i][1].exec(string)) {\n
                    // match[5] should be \'T\' or undefined\n
                    config._f = isoDates[i][0] + (match[6] || \' \');\n
                    break;\n
                }\n
            }\n
            for (i = 0, l = isoTimes.length; i < l; i++) {\n
                if (isoTimes[i][1].exec(string)) {\n
                    config._f += isoTimes[i][0];\n
                    break;\n
                }\n
            }\n
            if (string.match(parseTokenTimezone)) {\n
                config._f += \'Z\';\n
            }\n
            makeDateFromStringAndFormat(config);\n
        } else {\n
            config._isValid = false;\n
        }\n
    }\n
\n
    // date from iso format or fallback\n
    function makeDateFromString(config) {\n
        parseISO(config);\n
        if (config._isValid === false) {\n
            delete config._isValid;\n
            moment.createFromInputFallback(config);\n
        }\n
    }\n
\n
    function map(arr, fn) {\n
        var res = [], i;\n
        for (i = 0; i < arr.length; ++i) {\n
            res.push(fn(arr[i], i));\n
        }\n
        return res;\n
    }\n
\n
    function makeDateFromInput(config) {\n
        var input = config._i, matched;\n
        if (input === undefined) {\n
            config._d = new Date();\n
        } else if (isDate(input)) {\n
            config._d = new Date(+input);\n
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {\n
            config._d = new Date(+matched[1]);\n
        } else if (typeof input === \'string\') {\n
            makeDateFromString(config);\n
        } else if (isArray(input)) {\n
            config._a = map(input.slice(0), function (obj) {\n
                return parseInt(obj, 10);\n
            });\n
            dateFromConfig(config);\n
        } else if (typeof(input) === \'object\') {\n
            dateFromObject(config);\n
        } else if (typeof(input) === \'number\') {\n
            // from milliseconds\n
            config._d = new Date(input);\n
        } else {\n
            moment.createFromInputFallback(config);\n
        }\n
    }\n
\n
    function makeDate(y, m, d, h, M, s, ms) {\n
        //can\'t just apply() to create a date:\n
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n
        var date = new Date(y, m, d, h, M, s, ms);\n
\n
        //the date constructor doesn\'t accept years < 1970\n
        if (y < 1970) {\n
            date.setFullYear(y);\n
        }\n
        return date;\n
    }\n
\n
    function makeUTCDate(y) {\n
        var date = new Date(Date.UTC.apply(null, arguments));\n
        if (y < 1970) {\n
            date.setUTCFullYear(y);\n
        }\n
        return date;\n
    }\n
\n
    function parseWeekday(input, locale) {\n
        if (typeof input === \'string\') {\n
            if (!isNaN(input)) {\n
                input = parseInt(input, 10);\n
            }\n
            else {\n
                input = locale.weekdaysParse(input);\n
                if (typeof input !== \'number\') {\n
                    return null;\n
                }\n
            }\n
        }\n
        return input;\n
    }\n
\n
    /************************************\n
        Relative Time\n
    ************************************/\n
\n
\n
    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n
    }\n
\n
    function relativeTime(posNegDuration, withoutSuffix, locale) {\n
        var duration = moment.duration(posNegDuration).abs(),\n
            seconds = round(duration.as(\'s\')),\n
            minutes = round(duration.as(\'m\')),\n
            hours = round(duration.as(\'h\')),\n
            days = round(duration.as(\'d\')),\n
            months = round(duration.as(\'M\')),\n
            years = round(duration.as(\'y\')),\n
\n
            args = seconds < relativeTimeThresholds.s && [\'s\', seconds] ||\n
                minutes === 1 && [\'m\'] ||\n
                minutes < relativeTimeThresholds.m && [\'mm\', minutes] ||\n
                hours === 1 && [\'h\'] ||\n
                hours < relativeTimeThresholds.h && [\'hh\', hours] ||\n
                days === 1 && [\'d\'] ||\n
                days < relativeTimeThresholds.d && [\'dd\', days] ||\n
                months === 1 && [\'M\'] ||\n
                months < relativeTimeThresholds.M && [\'MM\', months] ||\n
                years === 1 && [\'y\'] || [\'yy\', years];\n
\n
        args[2] = withoutSuffix;\n
        args[3] = +posNegDuration > 0;\n
        args[4] = locale;\n
        return substituteTimeAgo.apply({}, args);\n
    }\n
\n
\n
    /************************************\n
        Week of Year\n
    ************************************/\n
\n
\n
    // firstDayOfWeek       0 = sun, 6 = sat\n
    //                      the day of the week that starts the week\n
    //                      (usually sunday or monday)\n
    // firstDayOfWeekOfYear 0 = sun, 6 = sat\n
    //                      the first week is the week that contains the first\n
    //                      of this day of the week\n
    //                      (eg. ISO weeks use thursday (4))\n
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n
        var end = firstDayOfWeekOfYear - firstDayOfWeek,\n
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n
            adjustedMoment;\n
\n
\n
        if (daysToDayOfWeek > end) {\n
            daysToDayOfWeek -= 7;\n
        }\n
\n
        if (daysToDayOfWeek < end - 7) {\n
            daysToDayOfWeek += 7;\n
        }\n
\n
        adjustedMoment = moment(mom).add(daysToDayOfWeek, \'d\');\n
        return {\n
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n
            year: adjustedMoment.year()\n
        };\n
    }\n
\n
    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;\n
\n
        d = d === 0 ? 7 : d;\n
        weekday = weekday != null ? weekday : firstDayOfWeek;\n
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);\n
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;\n
\n
        return {\n
            year: dayOfYear > 0 ? year : year - 1,\n
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear\n
        };\n
    }\n
\n
    /************************************\n
        Top Level Functions\n
    ************************************/\n
\n
    function makeMoment(config) {\n
        var input = config._i,\n
            format = config._f,\n
            res;\n
\n
        config._locale = config._locale || moment.localeData(config._l);\n
\n
        if (input === null || (format === undefined && input === \'\')) {\n
            return moment.invalid({nullInput: true});\n
        }\n
\n
        if (typeof input === \'string\') {\n
            config._i = input = config._locale.preparse(input);\n
        }\n
\n
        if (moment.isMoment(input)) {\n
            return new Moment(input, true);\n
        } else if (format) {\n
            if (isArray(format)) {\n
                makeDateFromStringAndArray(config);\n
            } else {\n
                makeDateFromStringAndFormat(config);\n
            }\n
        } else {\n
            makeDateFromInput(config);\n
        }\n
\n
        res = new Moment(config);\n
        if (res._nextDay) {\n
            // Adding is smart enough around DST\n
            res.add(1, \'d\');\n
            res._nextDay = undefined;\n
        }\n
\n
        return res;\n
    }\n
\n
    moment = function (input, format, locale, strict) {\n
        var c;\n
\n
        if (typeof(locale) === \'boolean\') {\n
            strict = locale;\n
            locale = undefined;\n
        }\n
        // object construction must be done this way.\n
        // https://github.com/moment/moment/issues/1423\n
        c = {};\n
        c._isAMomentObject = true;\n
        c._i = input;\n
        c._f = format;\n
        c._l = locale;\n
        c._strict = strict;\n
        c._isUTC = false;\n
        c._pf = defaultParsingFlags();\n
\n
        return makeMoment(c);\n
    };\n
\n
    moment.suppressDeprecationWarnings = false;\n
\n
    moment.createFromInputFallback = deprecate(\n
        \'moment construction falls back to js Date. This is \' +\n
        \'discouraged and will be removed in upcoming major \' +\n
        \'release. Please refer to \' +\n
        \'https://github.com/moment/moment/issues/1407 for more info.\',\n
        function (config) {\n
            config._d = new Date(config._i + (config._useUTC ? \' UTC\' : \'\'));\n
        }\n
    );\n
\n
    // Pick a moment m from moments so that m[fn](other) is true for all\n
    // other. This relies on the function fn to be transitive.\n
    //\n
    // moments should either be an array of moment objects or an array, whose\n
    // first element is an array of moment objects.\n
    function pickBy(fn, moments) {\n
        var res, i;\n
        if (moments.length === 1 && isArray(moments[0])) {\n
            moments = moments[0];\n
        }\n
        if (!moments.length) {\n
            return moment();\n
        }\n
        res = moments[0];\n
        for (i = 1; i < moments.length; ++i) {\n
            if (moments[i][fn](res)) {\n
                res = moments[i];\n
            }\n
        }\n
        return res;\n
    }\n
\n
    moment.min = function () {\n
        var args = [].slice.call(arguments, 0);\n
\n
        return pickBy(\'isBefore\', args);\n
    };\n
\n
    moment.max = function () {\n
        var args = [].slice.call(arguments, 0);\n
\n
        return pickBy(\'isAfter\', args);\n
    };\n
\n
    // creating with utc\n
    moment.utc = function (input, format, locale, strict) {\n
        var c;\n
\n
        if (typeof(locale) === \'boolean\') {\n
            strict = locale;\n
            locale = undefined;\n
        }\n
        // object construction must be done this way.\n
        // https://github.com/moment/moment/issues/1423\n
        c = {};\n
        c._isAMomentObject = true;\n
        c._useUTC = true;\n
        c._isUTC = true;\n
        c._l = locale;\n
        c._i = input;\n
        c._f = format;\n
        c._strict = strict;\n
        c._pf = defaultParsingFlags();\n
\n
        return makeMoment(c).utc();\n
    };\n
\n
    // creating with unix timestamp (in seconds)\n
    moment.unix = function (input) {\n
        return moment(input * 1000);\n
    };\n
\n
    // duration\n
    moment.duration = function (input, key) {\n
        var duration = input,\n
            // matching against regexp is expensive, do it on demand\n
            match = null,\n
            sign,\n
            ret,\n
            parseIso,\n
            diffRes;\n
\n
        if (moment.isDuration(input)) {\n
            duration = {\n
                ms: input._milliseconds,\n
                d: input._days,\n
                M: input._months\n
            };\n
        } else if (typeof input === \'number\') {\n
            duration = {};\n
            if (key) {\n
                duration[key] = input;\n
            } else {\n
                duration.milliseconds = input;\n
            }\n
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {\n
            sign = (match[1] === \'-\') ? -1 : 1;\n
            duration = {\n
                y: 0,\n
                d: toInt(match[DATE]) * sign,\n
                h: toInt(match[HOUR]) * sign,\n
                m: toInt(match[MINUTE]) * sign,\n
                s: toInt(match[SECOND]) * sign,\n
                ms: toInt(match[MILLISECOND]) * sign\n
            };\n
        } else if (!!(match = isoDurationRegex.exec(input))) {\n
            sign = (match[1] === \'-\') ? -1 : 1;\n
            parseIso = function (inp) {\n
                // We\'d normally use ~~inp for this, but unfortunately it also\n
                // converts floats to ints.\n
                // inp may be undefined, so careful calling replace on it.\n
                var res = inp && parseFloat(inp.replace(\',\', \'.\'));\n
                // apply sign while we\'re at it\n
                return (isNaN(res) ? 0 : res) * sign;\n
            };\n
            duration = {\n
                y: parseIso(match[2]),\n
                M: parseIso(match[3]),\n
                d: parseIso(match[4]),\n
                h: parseIso(match[5]),\n
                m: parseIso(match[6]),\n
                s: parseIso(match[7]),\n
                w: parseIso(match[8])\n
            };\n
        } else if (duration == null) {// checks for null or undefined\n
            duration = {};\n
        } else if (typeof duration === \'object\' &&\n
                (\'from\' in duration || \'to\' in duration)) {\n
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));\n
\n
            duration = {};\n
            duration.ms = diffRes.milliseconds;\n
            duration.M = diffRes.months;\n
        }\n
\n
        ret = new Duration(duration);\n
\n
        if (moment.isDuration(input) && hasOwnProp(input, \'_locale\')) {\n
            ret._locale = input._locale;\n
        }\n
\n
        return ret;\n
    };\n
\n
    // version number\n
    moment.version = VERSION;\n
\n
    // default format\n
    moment.defaultFormat = isoFormat;\n
\n
    // constant that refers to the ISO standard\n
    moment.ISO_8601 = function () {};\n
\n
    // Plugins that add properties should also add the key here (null value),\n
    // so we can properly clone ourselves.\n
    moment.momentProperties = momentProperties;\n
\n
    // This function will be called whenever a moment is mutated.\n
    // It is intended to keep the offset in sync with the timezone.\n
    moment.updateOffset = function () {};\n
\n
    // This function allows you to set a threshold for relative time strings\n
    moment.relativeTimeThreshold = function (threshold, limit) {\n
        if (relativeTimeThresholds[threshold] === undefined) {\n
            return false;\n
        }\n
        if (limit === undefined) {\n
            return relativeTimeThresholds[threshold];\n
        }\n
        relativeTimeThresholds[threshold] = limit;\n
        return true;\n
    };\n
\n
    moment.lang = deprecate(\n
        \'moment.lang is deprecated. Use moment.locale instead.\',\n
        function (key, value) {\n
            return moment.locale(key, value);\n
        }\n
    );\n
\n
    // This function will load locale and then set the global locale.  If\n
    // no arguments are passed in, it will simply return the current global\n
    // locale key.\n
    moment.locale = function (key, values) {\n
        var data;\n
        if (key) {\n
            if (typeof(values) !== \'undefined\') {\n
                data = moment.defineLocale(key, values);\n
            }\n
            else {\n
                data = moment.localeData(key);\n
            }\n
\n
            if (data) {\n
                moment.duration._locale = moment._locale = data;\n
            }\n
        }\n
\n
        return moment._locale._abbr;\n
    };\n
\n
    moment.defineLocale = function (name, values) {\n
        if (values !== null) {\n
            values.abbr = name;\n
            if (!locales[name]) {\n
                locales[name] = new Locale();\n
            }\n
            locales[name].set(values);\n
\n
            // backwards compat for now: also set the locale\n
            moment.locale(name);\n
\n
            return locales[name];\n
        } else {\n
            // useful for testing\n
            delete locales[name];\n
            return null;\n
        }\n
    };\n
\n
    moment.langData = deprecate(\n
        \'moment.langData is deprecated. Use moment.localeData instead.\',\n
        function (key) {\n
            return moment.localeData(key);\n
        }\n
    );\n
\n
    // returns locale data\n
    moment.localeData = function (key) {\n
        var locale;\n
\n
        if (key && key._locale && key._locale._abbr) {\n
            key = key._locale._abbr;\n
        }\n
\n
        if (!key) {\n
            return moment._locale;\n
        }\n
\n
        if (!isArray(key)) {\n
            //short-circuit everything else\n
            locale = loadLocale(key);\n
            if (locale) {\n
                return locale;\n
            }\n
            key = [key];\n
        }\n
\n
        return chooseLocale(key);\n
    };\n
\n
    // compare moment object\n
    moment.isMoment = function (obj) {\n
        return obj instanceof Moment ||\n
            (obj != null && hasOwnProp(obj, \'_isAMomentObject\'));\n
    };\n
\n
    // for typechecking Duration objects\n
    moment.isDuration = function (obj) {\n
        return obj instanceof Duration;\n
    };\n
\n
    for (i = lists.length - 1; i >= 0; --i) {\n
        makeList(lists[i]);\n
    }\n
\n
    moment.normalizeUnits = function (units) {\n
        return normalizeUnits(units);\n
    };\n
\n
    moment.invalid = function (flags) {\n
        var m = moment.utc(NaN);\n
        if (flags != null) {\n
            extend(m._pf, flags);\n
        }\n
        else {\n
            m._pf.userInvalidated = true;\n
        }\n
\n
        return m;\n
    };\n
\n
    moment.parseZone = function () {\n
        return moment.apply(null, arguments).parseZone();\n
    };\n
\n
    moment.parseTwoDigitYear = function (input) {\n
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n
    };\n
\n
    moment.isDate = isDate;\n
\n
    /************************************\n
        Moment Prototype\n
    ************************************/\n
\n
\n
    extend(moment.fn = Moment.prototype, {\n
\n
        clone : function () {\n
            return moment(this);\n
        },\n
\n
        valueOf : function () {\n
            return +this._d - ((this._offset || 0) * 60000);\n
        },\n
\n
        unix : function () {\n
            return Math.floor(+this / 1000);\n
        },\n
\n
        toString : function () {\n
            return this.clone().locale(\'en\').format(\'ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\');\n
        },\n
\n
        toDate : function () {\n
            return this._offset ? new Date(+this) : this._d;\n
        },\n
\n
        toISOString : function () {\n
            var m = moment(this).utc();\n
            if (0 < m.year() && m.year() <= 9999) {\n
                if (\'function\' === typeof Date.prototype.toISOString) {\n
                    // native implementation is ~50x faster, use it when we can\n
                    return this.toDate().toISOString();\n
                } else {\n
                    return formatMoment(m, \'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\');\n
                }\n
            } else {\n
                return formatMoment(m, \'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\');\n
            }\n
        },\n
\n
        toArray : function () {\n
            var m = this;\n
            return [\n
                m.year(),\n
                m.month(),\n
                m.date(),\n
                m.hours(),\n
                m.minutes(),\n
                m.seconds(),\n
                m.milliseconds()\n
            ];\n
        },\n
\n
        isValid : function () {\n
            return isValid(this);\n
        },\n
\n
        isDSTShifted : function () {\n
            if (this._a) {\n
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;\n
            }\n
\n
            return false;\n
        },\n
\n
        parsingFlags : function () {\n
            return extend({}, this._pf);\n
        },\n
\n
        invalidAt: function () {\n
            return this._pf.overflow;\n
        },\n
\n
        utc : function (keepLocalTime) {\n
            return this.utcOffset(0, keepLocalTime);\n
        },\n
\n
        local : function (keepLocalTime) {\n
            if (this._isUTC) {\n
                this.utcOffset(0, keepLocalTime);\n
                this._isUTC = false;\n
\n
                if (keepLocalTime) {\n
                    this.subtract(this._dateUtcOffset(), \'m\');\n
                }\n
            }\n
            return this;\n
        },\n
\n
        format : function (inputString) {\n
            var output = formatMoment(this, inputString || moment.defaultFormat);\n
            return this.localeData().postformat(output);\n
        },\n
\n
        add : createAdder(1, \'add\'),\n
\n
        subtract : createAdder(-1, \'subtract\'),\n
\n
        diff : function (input, units, asFloat) {\n
            var that = makeAs(input, this),\n
                zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4,\n
                anchor, diff, output, daysAdjust;\n
\n
            units = normalizeUnits(units);\n
\n
            if (units === \'year\' || units === \'month\' || units === \'quarter\') {\n
                output = monthDiff(this, that);\n
                if (units === \'quarter\') {\n
                    output = output / 3;\n
                } else if (units === \'year\') {\n
                    output = output / 12;\n
                }\n
            } else {\n
                diff = this - that;\n
                output = units === \'second\' ? diff / 1e3 : // 1000\n
                    units === \'minute\' ? diff / 6e4 : // 1000 * 60\n
                    units === \'hour\' ? diff / 36e5 : // 1000 * 60 * 60\n
                    units === \'day\' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n
                    units === \'week\' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n
                    diff;\n
            }\n
            return asFloat ? output : absRound(output);\n
        },\n
\n
        from : function (time, withoutSuffix) {\n
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n
        },\n
\n
        fromNow : function (withoutSuffix) {\n
            return this.from(moment(), withoutSuffix);\n
        },\n
\n
        calendar : function (time) {\n
            // We want to compare the start of today, vs this.\n
            // Getting start-of-today depends on whether we\'re locat/utc/offset\n
            // or not.\n
            var now = time || moment(),\n
                sod = makeAs(now, this).startOf(\'day\'),\n
                diff = this.diff(sod, \'days\', true),\n
                format = diff < -6 ? \'sameElse\' :\n
                    diff < -1 ? \'lastWeek\' :\n
                    diff < 0 ? \'lastDay\' :\n
                    diff < 1 ? \'sameDay\' :\n
                    diff < 2 ? \'nextDay\' :\n
                    diff < 7 ? \'nextWeek\' : \'sameElse\';\n
            return this.format(this.localeData().calendar(format, this, moment(now)));\n
        },\n
\n
        isLeapYear : function () {\n
            return isLeapYear(this.year());\n
        },\n
\n
        isDST : function () {\n
            return (this.utcOffset() > this.clone().month(0).utcOffset() ||\n
                this.utcOffset() > this.clone().month(5).utcOffset());\n
        },\n
\n
        day : function (input) {\n
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n
            if (input != null) {\n
                input = parseWeekday(input, this.localeData());\n
                return this.add(input - day, \'d\');\n
            } else {\n
                return day;\n
            }\n
        },\n
\n
        month : makeAccessor(\'Month\', true),\n
\n
        startOf : function (units) {\n
            units = normalizeUnits(units);\n
            // the following switch intentionally omits break keywords\n
            // to utilize falling through the cases.\n
            switch (units) {\n
            case \'year\':\n
                this.month(0);\n
                /* falls through */\n
            case \'quarter\':\n
            case \'month\':\n
                this.date(1);\n
                /* falls through */\n
            case \'week\':\n
            case \'isoWeek\':\n
            case \'day\':\n
                this.hours(0);\n
                /* falls through */\n
            case \'hour\':\n
                this.minutes(0);\n
                /* falls through */\n
            case \'minute\':\n
                this.seconds(0);\n
                /* falls through */\n
            case \'second\':\n
                this.milliseconds(0);\n
                /* falls through */\n
            }\n
\n
            // weeks are a special case\n
            if (units === \'week\') {\n
                this.weekday(0);\n
            } else if (units === \'isoWeek\') {\n
                this.isoWeekday(1);\n
            }\n
\n
            // quarters are also special\n
            if (units === \'quarter\') {\n
                this.month(Math.floor(this.month() / 3) * 3);\n
            }\n
\n
            return this;\n
        },\n
\n
        endOf: function (units) {\n
            units = normalizeUnits(units);\n
            if (units === undefined || units === \'millisecond\') {\n
                return this;\n
            }\n
            return this.startOf(units).add(1, (units === \'isoWeek\' ? \'week\' : units)).subtract(1, \'ms\');\n
        },\n
\n
        isAfter: function (input, units) {\n
            var inputMs;\n
            units = normalizeUnits(typeof units !== \'undefined\' ? units : \'millisecond\');\n
            if (units === \'millisecond\') {\n
                input = moment.isMoment(input) ? input : moment(input);\n
                return +this > +input;\n
            } else {\n
                inputMs = moment.isMoment(input) ? +input : +moment(input);\n
                return inputMs < +this.clone().startOf(units);\n
            }\n
        },\n
\n
        isBefore: function (input, units) {\n
            var inputMs;\n
            units = normalizeUnits(typeof units !== \'undefined\' ? units : \'millisecond\');\n
            if (units === \'millisecond\') {\n
                input = moment.isMoment(input) ? input : moment(input);\n
                return +this < +input;\n
            } else {\n
                inputMs = moment.isMoment(input) ? +input : +moment(input);\n
                return +this.clone().endOf(units) < inputMs;\n
            }\n
        },\n
\n
        isBetween: function (from, to, units) {\n
            return this.isAfter(from, units) && this.isBefore(to, units);\n
        },\n
\n
        isSame: function (input, units) {\n
            var inputMs;\n
            units = normalizeUnits(units || \'millisecond\');\n
            if (units === \'millisecond\') {\n
                input = moment.isMoment(input) ? input : moment(input);\n
                return +this === +input;\n
            } else {\n
                inputMs = +moment(input);\n
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));\n
            }\n
        },\n
\n
        min: deprecate(\n
                 \'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548\',\n
                 function (other) {\n
                     other = moment.apply(null, arguments);\n
                     return other < this ? this : other;\n
                 }\n
         ),\n
\n
        max: deprecate(\n
                \'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548\',\n
                function (other) {\n
                    other = moment.apply(null, arguments);\n
                    return other > this ? this : other;\n
                }\n
        ),\n
\n
        zone : deprecate(\n
                \'moment().zone is deprecated, use moment().utcOffset instead. \' +\n
                \'https://github.com/moment/moment/issues/1779\',\n
                function (input, keepLocalTime) {\n
                    if (input != null) {\n
                        if (typeof input !== \'string\') {\n
                            input = -input;\n
                        }\n
\n
                        this.utcOffset(input, keepLocalTime);\n
\n
                        return this;\n
                    } else {\n
                        return -this.utcOffset();\n
                    }\n
                }\n
        ),\n
\n
        // keepLocalTime = true means only change the timezone, without\n
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n
        // 5:31:26 +0200 It is possible that 5:31:26 doesn\'t exist with offset\n
        // +0200, so we adjust the time as needed, to be valid.\n
        //\n
        // Keeping the time actually adds/subtracts (one hour)\n
        // from the actual represented time. That is why we call updateOffset\n
        // a second time. In case it wants us to change the offset again\n
        // _changeInProgress == true case, then we have to adjust, because\n
        // there is no such time in the given timezone.\n
        utcOffset : function (input, keepLocalTime) {\n
            var offset = this._offset || 0,\n
                localAdjust;\n
            if (input != null) {\n
                if (typeof input === \'string\') {\n
                    input = utcOffsetFromString(input);\n
                }\n
                if (Math.abs(input) < 16) {\n
                    input = input * 60;\n
                }\n
                if (!this._isUTC && keepLocalTime) {\n
                    localAdjust = this._dateUtcOffset();\n
                }\n
                this._offset = input;\n
                this._isUTC = true;\n
                if (localAdjust != null) {\n
                    this.add(localAdjust, \'m\');\n
                }\n
                if (offset !== input) {\n
                    if (!keepLocalTime || this._changeInProgress) {\n
                        addOrSubtractDurationFromMoment(this,\n
                                moment.duration(input - offset, \'m\'), 1, false);\n
                    } else if (!this._changeInProgress) {\n
                        this._changeInProgress = true;\n
                        moment.updateOffset(this, true);\n
                        this._changeInProgress = null;\n
                    }\n
                }\n
\n
                return this;\n
            } else {\n
                return this._isUTC ? offset : this._dateUtcOffset();\n
            }\n
        },\n
\n
        isLocal : function () {\n
            return !this._isUTC;\n
        },\n
\n
        isUtcOffset : function () {\n
            return this._isUTC;\n
        },\n
\n
        isUtc : function () {\n
            return this._isUTC && this._offset === 0;\n
        },\n
\n
        zoneAbbr : function () {\n
            return this._isUTC ? \'UTC\' : \'\';\n
        },\n
\n
        zoneName : function () {\n
            return this._isUTC ? \'Coordinated Universal Time\' : \'\';\n
        },\n
\n
        parseZone : function () {\n
            if (this._tzm) {\n
                this.utcOffset(this._tzm);\n
            } else if (typeof this._i === \'string\') {\n
                this.utcOffset(utcOffsetFromString(this._i));\n
            }\n
            return this;\n
        },\n
\n
        hasAlignedHourOffset : function (input) {\n
            if (!input) {\n
                input = 0;\n
            }\n
            else {\n
                input = moment(input).utcOffset();\n
            }\n
\n
            return (this.utcOffset() - input) % 60 === 0;\n
        },\n
\n
        daysInMonth : function () {\n
            return daysInMonth(this.year(), this.month());\n
        },\n
\n
        dayOfYear : function (input) {\n
            var dayOfYear = round((moment(this).startOf(\'day\') - moment(this).startOf(\'year\')) / 864e5) + 1;\n
            return input == null ? dayOfYear : this.add((input - dayOfYear), \'d\');\n
        },\n
\n
        quarter : function (input) {\n
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n
        },\n
\n
        weekYear : function (input) {\n
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;\n
            return input == null ? year : this.add((input - year), \'y\');\n
        },\n
\n
        isoWeekYear : function (input) {\n
            var year = weekOfYear(this, 1, 4).year;\n
            return input == null ? year : this.add((input - year), \'y\');\n
        },\n
\n
        week : function (input) {\n
            var week = this.localeData().week(this);\n
            return input == null ? week : this.add((input - week) * 7, \'d\');\n
        },\n
\n
        isoWeek : function (input) {\n
            var week = weekOfYear(this, 1, 4).week;\n
            return input == null ? week : this.add((input - week) * 7, \'d\');\n
        },\n
\n
        weekday : function (input) {\n
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n
            return input == null ? weekday : this.add(input - weekday, \'d\');\n
        },\n
\n
        isoWeekday : function (input) {\n
            // behaves the same as moment#day except\n
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n
            // as a setter, sunday should belong to the previous week.\n
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n
        },\n
\n
        isoWeeksInYear : function () {\n
            return weeksInYear(this.year(), 1, 4);\n
        },\n
\n
        weeksInYear : function () {\n
            var weekInfo = this.localeData()._week;\n
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n
        },\n
\n
        get : function (units) {\n
            units = normalizeUnits(units);\n
            return this[units]();\n
        },\n
\n
        set : function (units, value) {\n
            var unit;\n
            if (typeof units === \'object\') {\n
                for (unit in units) {\n
                    this.set(unit, units[unit]);\n
                }\n
            }\n
            else {\n
                units = normalizeUnits(units);\n
                if (typeof this[units] === \'function\') {\n
                    this[units](value);\n
                }\n
            }\n
            return this;\n
        },\n
\n
        // If passed a locale key, it will set the locale for this\n
        // instance.  Otherwise, it will return the locale configuration\n
        // variables for this instance.\n
        locale : function (key) {\n
            var newLocaleData;\n
\n
            if (key === undefined) {\n
                return this._locale._abbr;\n
            } else {\n
                newLocaleData = moment.localeData(key);\n
                if (newLocaleData != null) {\n
                    this._locale = newLocaleData;\n
                }\n
                return this;\n
            }\n
        },\n
\n
        lang : deprecate(\n
            \'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\',\n
            function (key) {\n
                if (key === undefined) {\n
                    return this.localeData();\n
                } else {\n
                    return this.locale(key);\n
                }\n
            }\n
        ),\n
\n
        localeData : function () {\n
            return this._locale;\n
        },\n
\n
        _dateUtcOffset : function () {\n
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n
            // https://github.com/moment/moment/pull/1871\n
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;\n
        }\n
\n
    });\n
\n
    function rawMonthSetter(mom, value) {\n
        var dayOfMonth;\n
\n
        // TODO: Move this out of here!\n
        if (typeof value === \'string\') {\n
            value = mom.localeData().monthsParse(value);\n
            // TODO: Another silent failure?\n
            if (typeof value !== \'number\') {\n
                return mom;\n
            }\n
        }\n
\n
        dayOfMonth = Math.min(mom.date(),\n
                daysInMonth(mom.year(), value));\n
        mom._d[\'set\' + (mom._isUTC ? \'UTC\' : \'\') + \'Month\'](value, dayOfMonth);\n
        return mom;\n
    }\n
\n
    function rawGetter(mom, unit) {\n
        return mom._d[\'get\' + (mom._isUTC ? \'UTC\' : \'\') + unit]();\n
    }\n
\n
    function rawSetter(mom, unit, value) {\n
        if (unit === \'Month\') {\n
            return rawMonthSetter(mom, value);\n
        } else {\n
            return mom._d[\'set\' + (mom._isUTC ? \'UTC\' : \'\') + unit](value);\n
        }\n
    }\n
\n
    function makeAccessor(unit, keepTime) {\n
        return function (value) {\n
            if (value != null) {\n
                rawSetter(this, unit, value);\n
                moment.updateOffset(this, keepTime);\n
                return this;\n
            } else {\n
                return rawGetter(this, unit);\n
            }\n
        };\n
    }\n
\n
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor(\'Milliseconds\', false);\n
    moment.fn.second = moment.fn.seconds = makeAccessor(\'Seconds\', false);\n
    moment.fn.minute = moment.fn.minutes = makeAccessor(\'Minutes\', false);\n
    // Setting the hour should keep the time, because the user explicitly\n
    // specified which hour he wants. So trying to maintain the same hour (in\n
    // a new timezone) makes sense. Adding/subtracting hours does not follow\n
    // this rule.\n
    moment.fn.hour = moment.fn.hours = makeAccessor(\'Hours\', true);\n
    // moment.fn.month is defined separately\n
    moment.fn.date = makeAccessor(\'Date\', true);\n
    moment.fn.dates = deprecate(\'dates accessor is deprecated. Use date instead.\', makeAccessor(\'Date\', true));\n
    moment.fn.year = makeAccessor(\'FullYear\', true);\n
    moment.fn.years = deprecate(\'years accessor is deprecated. Use year instead.\', makeAccessor(\'FullYear\', true));\n
\n
    // add plural methods\n
    moment.fn.days = moment.fn.day;\n
    moment.fn.months = moment.fn.month;\n
    moment.fn.weeks = moment.fn.week;\n
    moment.fn.isoWeeks = moment.fn.isoWeek;\n
    moment.fn.quarters = moment.fn.quarter;\n
\n
    // add aliased format methods\n
    moment.fn.toJSON = moment.fn.toISOString;\n
\n
    // alias isUtc for dev-friendliness\n
    moment.fn.isUTC = moment.fn.isUtc;\n
\n
    /************************************\n
        Duration Prototype\n
    ************************************/\n
\n
\n
    function daysToYears (days) {\n
        // 400 years have 146097 days (taking into account leap year rules)\n
        return days * 400 / 146097;\n
    }\n
\n
    function yearsToDays (years) {\n
        // years * 365 + absRound(years / 4) -\n
        //     absRound(years / 100) + absRound(years / 400);\n
        return years * 146097 / 400;\n
    }\n
\n
    extend(moment.duration.fn = Duration.prototype, {\n
\n
        _bubble : function () {\n
            var milliseconds = this._milliseconds,\n
                days = this._days,\n
                months = this._months,\n
                data = this._data,\n
                seconds, minutes, hours, years = 0;\n
\n
            // The following code bubbles up values, see the tests for\n
            // examples of what that means.\n
            data.milliseconds = milliseconds % 1000;\n
\n
            seconds = absRound(milliseconds / 1000);\n
            data.seconds = seconds % 60;\n
\n
            minutes = absRound(seconds / 60);\n
            data.minutes = minutes % 60;\n
\n
            hours = absRound(minutes / 60);\n
            data.hours = hours % 24;\n
\n
            days += absRound(hours / 24);\n
\n
            // Accurately convert days to years, assume start from year 0.\n
            years = absRound(daysToYears(days));\n
            days -= absRound(yearsToDays(years));\n
\n
            // 30 days to a month\n
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.\n
            months += absRound(days / 30);\n
            days %= 30;\n
\n
            // 12 months -> 1 year\n
            years += absRound(months / 12);\n
            months %= 12;\n
\n
            data.days = days;\n
            data.months = months;\n
            data.years = years;\n
        },\n
\n
        abs : function () {\n
            this._milliseconds = Math.abs(this._milliseconds);\n
            this._days = Math.abs(this._days);\n
            this._months = Math.abs(this._months);\n
\n
            this._data.milliseconds = Math.abs(this._data.milliseconds);\n
            this._data.seconds = Math.abs(this._data.seconds);\n
            this._data.minutes = Math.abs(this._data.minutes);\n
            this._data.hours = Math.abs(this._data.hours);\n
            this._data.months = Math.abs(this._data.months);\n
            this._data.years = Math.abs(this._data.years);\n
\n
            return this;\n
        },\n
\n
        weeks : function () {\n
            return absRound(this.days() / 7);\n
        },\n
\n
        valueOf : function () {\n
            return this._milliseconds +\n
              this._days * 864e5 +\n
              (this._months % 12) * 2592e6 +\n
              toInt(this._months / 12) * 31536e6;\n
        },\n
\n
        humanize : function (withSuffix) {\n
            var output = relativeTime(this, !withSuffix, this.localeData());\n
\n
            if (withSuffix) {\n
                output = this.localeData().pastFuture(+this, output);\n
            }\n
\n
            return this.localeData().postformat(output);\n
        },\n
\n
        add : function (input, val) {\n
            // supports only 2.0-style add(1, \'s\') or add(moment)\n
            var dur = moment.duration(input, val);\n
\n
            this._milliseconds += dur._milliseconds;\n
            this._days += dur._days;\n
            this._months += dur._months;\n
\n
            this._bubble();\n
\n
            return this;\n
        },\n
\n
        subtract : function (input, val) {\n
            var dur = moment.duration(input, val);\n
\n
            this._milliseconds -= dur._milliseconds;\n
            this._days -= dur._days;\n
            this._months -= dur._months;\n
\n
            this._bubble();\n
\n
            return this;\n
        },\n
\n
        get : function (units) {\n
            units = normalizeUnits(units);\n
            return this[units.toLowerCase() + \'s\']();\n
        },\n
\n
        as : function (units) {\n
            var days, months;\n
            units = normalizeUnits(units);\n
\n
            if (units === \'month\' || units === \'year\') {\n
                days = this._days + this._milliseconds / 864e5;\n
                months = this._months + daysToYears(days) * 12;\n
                return units === \'month\' ? months : months / 12;\n
            } else {\n
                // handle milliseconds separately because of floating point math errors (issue #1867)\n
                days = this._days + Math.round(yearsToDays(this._months / 12));\n
                switch (units) {\n
                    case \'week\': return days / 7 + this._milliseconds / 6048e5;\n
                    case \'day\': return days + this._milliseconds / 864e5;\n
                    case \'hour\': return days * 24 + this._milliseconds / 36e5;\n
                    case \'minute\': return days * 24 * 60 + this._milliseconds / 6e4;\n
                    case \'second\': return days * 24 * 60 * 60 + this._milliseconds / 1000;\n
                    // Math.floor prevents floating point math errors here\n
                    case \'millisecond\': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;\n
                    default: throw new Error(\'Unknown unit \' + units);\n
                }\n
            }\n
        },\n
\n
        lang : moment.fn.lang,\n
        locale : moment.fn.locale,\n
\n
        toIsoString : deprecate(\n
            \'toIsoString() is deprecated. Please use toISOString() instead \' +\n
            \'(notice the capitals)\',\n
            function () {\n
                return this.toISOString();\n
            }\n
        ),\n
\n
        toISOString : function () {\n
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n
            var years = Math.abs(this.years()),\n
                months = Math.abs(this.months()),\n
                days = Math.abs(this.days()),\n
                hours = Math.abs(this.hours()),\n
                minutes = Math.abs(this.minutes()),\n
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);\n
\n
            if (!this.asSeconds()) {\n
                // this is the same as C#\'s (Noda) and python (isodate)...\n
                // but not other JS (goog.date)\n
                return \'P0D\';\n
            }\n
\n
            return (this.asSeconds() < 0 ? \'-\' : \'\') +\n
                \'P\' +\n
                (years ? years + \'Y\' : \'\') +\n
                (months ? months + \'M\' : \'\') +\n
                (days ? days + \'D\' : \'\') +\n
                ((hours || minutes || seconds) ? \'T\' : \'\') +\n
                (hours ? hours + \'H\' : \'\') +\n
                (minutes ? minutes + \'M\' : \'\') +\n
                (seconds ? seconds + \'S\' : \'\');\n
        },\n
\n
        localeData : function () {\n
            return this._locale;\n
        },\n
\n
        toJSON : function () {\n
            return this.toISOString();\n
        }\n
    });\n
\n
    moment.duration.fn.toString = moment.duration.fn.toISOString;\n
\n
    function makeDurationGetter(name) {\n
        moment.duration.fn[name] = function () {\n
            return this._data[name];\n
        };\n
    }\n
\n
    for (i in unitMillisecondFactors) {\n
        if (hasOwnProp(unitMillisecondFactors, i)) {\n
            makeDurationGetter(i.toLowerCase());\n
        }\n
    }\n
\n
    moment.duration.fn.asMilliseconds = function () {\n
        return this.as(\'ms\');\n
    };\n
    moment.duration.fn.asSeconds = function () {\n
        return this.as(\'s\');\n
    };\n
    moment.duration.fn.asMinutes = function () {\n
        return this.as(\'m\');\n
    };\n
    moment.duration.fn.asHours = function () {\n
        return this.as(\'h\');\n
    };\n
    moment.duration.fn.asDays = function () {\n
        return this.as(\'d\');\n
    };\n
    moment.duration.fn.asWeeks = function () {\n
        return this.as(\'weeks\');\n
    };\n
    moment.duration.fn.asMonths = function () {\n
        return this.as(\'M\');\n
    };\n
    moment.duration.fn.asYears = function () {\n
        return this.as(\'y\');\n
    };\n
\n
    /************************************\n
        Default Locale\n
    ************************************/\n
\n
\n
    // Set default locale, other locale will inherit from English.\n
    moment.locale(\'en\', {\n
        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n
        ordinal : function (number) {\n
            var b = number % 10,\n
                output = (toInt(number % 100 / 10) === 1) ? \'th\' :\n
                (b === 1) ? \'st\' :\n
                (b === 2) ? \'nd\' :\n
                (b === 3) ? \'rd\' : \'th\';\n
            return number + output;\n
        }\n
    });\n
\n
    /* EMBED_LOCALES */\n
\n
    /************************************\n
        Exposing Moment\n
    ************************************/\n
\n
    function makeGlobal(shouldDeprecate) {\n
        /*global ender:false */\n
        if (typeof ender !== \'undefined\') {\n
            return;\n
        }\n
        oldGlobalMoment = globalScope.moment;\n
        if (shouldDeprecate) {\n
            globalScope.moment = deprecate(\n
                    \'Accessing Moment through the global scope is \' +\n
                    \'deprecated, and will be removed in an upcoming \' +\n
                    \'release.\',\n
                    moment);\n
        } else {\n
            globalScope.moment = moment;\n
        }\n
    }\n
\n
    // CommonJS module is defined\n
    if (hasModule) {\n
        module.exports = moment;\n
    } else if (typeof define === \'function\' && define.amd) {\n
        define(function (require, exports, module) {\n
            if (module.config && module.config() && module.config().noGlobal === true) {\n
                // release the global variable\n
                globalScope.moment = oldGlobalMoment;\n
            }\n
\n
            return moment;\n
        });\n
        makeGlobal(true);\n
    } else {\n
        makeGlobal();\n
    }\n
}).call(this);\n


]]></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
