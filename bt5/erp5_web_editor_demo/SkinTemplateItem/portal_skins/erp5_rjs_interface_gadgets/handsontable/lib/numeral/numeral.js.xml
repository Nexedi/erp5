<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272909.07</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>numeral.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*!\n
 * numeral.js\n
 * version : 1.5.3\n
 * author : Adam Draper\n
 * license : MIT\n
 * http://adamwdraper.github.com/Numeral-js/\n
 */\n
\n
(function () {\n
\n
    /************************************\n
        Constants\n
    ************************************/\n
\n
    var numeral,\n
        VERSION = \'1.5.3\',\n
        // internal storage for language config files\n
        languages = {},\n
        currentLanguage = \'en\',\n
        zeroFormat = null,\n
        defaultFormat = \'0,0\',\n
        // check for nodeJS\n
        hasModule = (typeof module !== \'undefined\' && module.exports);\n
\n
\n
    /************************************\n
        Constructors\n
    ************************************/\n
\n
\n
    // Numeral prototype object\n
    function Numeral (number) {\n
        this._value = number;\n
    }\n
\n
    /**\n
     * Implementation of toFixed() that treats floats more like decimals\n
     *\n
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \'0.61\') that present\n
     * problems for accounting- and finance-related software.\n
     */\n
    function toFixed (value, precision, roundingFunction, optionals) {\n
        var power = Math.pow(10, precision),\n
            optionalsRegExp,\n
            output;\n
\n
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n
        // Multiply up by precision, round accurately, then divide and use native toFixed():\n
        output = (roundingFunction(value * power) / power).toFixed(precision);\n
\n
        if (optionals) {\n
            optionalsRegExp = new RegExp(\'0{1,\' + optionals + \'}$\');\n
            output = output.replace(optionalsRegExp, \'\');\n
        }\n
\n
        return output;\n
    }\n
\n
    /************************************\n
        Formatting\n
    ************************************/\n
\n
    // determine what type of formatting we need to do\n
    function formatNumeral (n, format, roundingFunction) {\n
        var output;\n
\n
        // figure out what kind of format we are dealing with\n
        if (format.indexOf(\'$\') > -1) { // currency!!!!!\n
            output = formatCurrency(n, format, roundingFunction);\n
        } else if (format.indexOf(\'%\') > -1) { // percentage\n
            output = formatPercentage(n, format, roundingFunction);\n
        } else if (format.indexOf(\':\') > -1) { // time\n
            output = formatTime(n, format);\n
        } else { // plain ol\' numbers or bytes\n
            output = formatNumber(n._value, format, roundingFunction);\n
        }\n
\n
        // return string\n
        return output;\n
    }\n
\n
    // revert to number\n
    function unformatNumeral (n, string) {\n
        var stringOriginal = string,\n
            thousandRegExp,\n
            millionRegExp,\n
            billionRegExp,\n
            trillionRegExp,\n
            suffixes = [\'KB\', \'MB\', \'GB\', \'TB\', \'PB\', \'EB\', \'ZB\', \'YB\'],\n
            bytesMultiplier = false,\n
            power;\n
\n
        if (string.indexOf(\':\') > -1) {\n
            n._value = unformatTime(string);\n
        } else {\n
            if (string === zeroFormat) {\n
                n._value = 0;\n
            } else {\n
                if (languages[currentLanguage].delimiters.decimal !== \'.\') {\n
                    string = string.replace(/\\./g,\'\').replace(languages[currentLanguage].delimiters.decimal, \'.\');\n
                }\n
\n
                // see if abbreviations are there so that we can multiply to the correct number\n
                thousandRegExp = new RegExp(\'[^a-zA-Z]\' + languages[currentLanguage].abbreviations.thousand + \'(?:\\\\)|(\\\\\' + languages[currentLanguage].currency.symbol + \')?(?:\\\\))?)?$\');\n
                millionRegExp = new RegExp(\'[^a-zA-Z]\' + languages[currentLanguage].abbreviations.million + \'(?:\\\\)|(\\\\\' + languages[currentLanguage].currency.symbol + \')?(?:\\\\))?)?$\');\n
                billionRegExp = new RegExp(\'[^a-zA-Z]\' + languages[currentLanguage].abbreviations.billion + \'(?:\\\\)|(\\\\\' + languages[currentLanguage].currency.symbol + \')?(?:\\\\))?)?$\');\n
                trillionRegExp = new RegExp(\'[^a-zA-Z]\' + languages[currentLanguage].abbreviations.trillion + \'(?:\\\\)|(\\\\\' + languages[currentLanguage].currency.symbol + \')?(?:\\\\))?)?$\');\n
\n
                // see if bytes are there so that we can multiply to the correct number\n
                for (power = 0; power <= suffixes.length; power++) {\n
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;\n
\n
                    if (bytesMultiplier) {\n
                        break;\n
                    }\n
                }\n
\n
                // do some math to create our number\n
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf(\'%\') > -1) ? 0.01 : 1) * (((string.split(\'-\').length + Math.min(string.split(\'(\').length-1, string.split(\')\').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\\.]+/g, \'\'));\n
\n
                // round if we are talking about bytes\n
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;\n
            }\n
        }\n
        return n._value;\n
    }\n
\n
    function formatCurrency (n, format, roundingFunction) {\n
        var symbolIndex = format.indexOf(\'$\'),\n
            openParenIndex = format.indexOf(\'(\'),\n
            minusSignIndex = format.indexOf(\'-\'),\n
            space = \'\',\n
            spliceIndex,\n
            output;\n
\n
        // check for space before or after currency\n
        if (format.indexOf(\' $\') > -1) {\n
            space = \' \';\n
            format = format.replace(\' $\', \'\');\n
        } else if (format.indexOf(\'$ \') > -1) {\n
            space = \' \';\n
            format = format.replace(\'$ \', \'\');\n
        } else {\n
            format = format.replace(\'$\', \'\');\n
        }\n
\n
        // format the number\n
        output = formatNumber(n._value, format, roundingFunction);\n
\n
        // position the symbol\n
        if (symbolIndex <= 1) {\n
            if (output.indexOf(\'(\') > -1 || output.indexOf(\'-\') > -1) {\n
                output = output.split(\'\');\n
                spliceIndex = 1;\n
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){\n
                    // the symbol appears before the "(" or "-"\n
                    spliceIndex = 0;\n
                }\n
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);\n
                output = output.join(\'\');\n
            } else {\n
                output = languages[currentLanguage].currency.symbol + space + output;\n
            }\n
        } else {\n
            if (output.indexOf(\')\') > -1) {\n
                output = output.split(\'\');\n
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);\n
                output = output.join(\'\');\n
            } else {\n
                output = output + space + languages[currentLanguage].currency.symbol;\n
            }\n
        }\n
\n
        return output;\n
    }\n
\n
    function formatPercentage (n, format, roundingFunction) {\n
        var space = \'\',\n
            output,\n
            value = n._value * 100;\n
\n
        // check for space before %\n
        if (format.indexOf(\' %\') > -1) {\n
            space = \' \';\n
            format = format.replace(\' %\', \'\');\n
        } else {\n
            format = format.replace(\'%\', \'\');\n
        }\n
\n
        output = formatNumber(value, format, roundingFunction);\n
\n
        if (output.indexOf(\')\') > -1 ) {\n
            output = output.split(\'\');\n
            output.splice(-1, 0, space + \'%\');\n
            output = output.join(\'\');\n
        } else {\n
            output = output + space + \'%\';\n
        }\n
\n
        return output;\n
    }\n
\n
    function formatTime (n) {\n
        var hours = Math.floor(n._value/60/60),\n
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),\n
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));\n
        return hours + \':\' + ((minutes < 10) ? \'0\' + minutes : minutes) + \':\' + ((seconds < 10) ? \'0\' + seconds : seconds);\n
    }\n
\n
    function unformatTime (string) {\n
        var timeArray = string.split(\':\'),\n
            seconds = 0;\n
        // turn hours and minutes into seconds and add them all up\n
        if (timeArray.length === 3) {\n
            // hours\n
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n
            // minutes\n
            seconds = seconds + (Number(timeArray[1]) * 60);\n
            // seconds\n
            seconds = seconds + Number(timeArray[2]);\n
        } else if (timeArray.length === 2) {\n
            // minutes\n
            seconds = seconds + (Number(timeArray[0]) * 60);\n
            // seconds\n
            seconds = seconds + Number(timeArray[1]);\n
        }\n
        return Number(seconds);\n
    }\n
\n
    function formatNumber (value, format, roundingFunction) {\n
        var negP = false,\n
            signed = false,\n
            optDec = false,\n
            abbr = \'\',\n
            abbrK = false, // force abbreviation to thousands\n
            abbrM = false, // force abbreviation to millions\n
            abbrB = false, // force abbreviation to billions\n
            abbrT = false, // force abbreviation to trillions\n
            abbrForce = false, // force abbreviation\n
            bytes = \'\',\n
            ord = \'\',\n
            abs = Math.abs(value),\n
            suffixes = [\'B\', \'KB\', \'MB\', \'GB\', \'TB\', \'PB\', \'EB\', \'ZB\', \'YB\'],\n
            min,\n
            max,\n
            power,\n
            w,\n
            precision,\n
            thousands,\n
            d = \'\',\n
            neg = false;\n
\n
        // check if number is zero and a custom zero format has been set\n
        if (value === 0 && zeroFormat !== null) {\n
            return zeroFormat;\n
        } else {\n
            // see if we should use parentheses for negative number or if we should prefix with a sign\n
            // if both are present we default to parentheses\n
            if (format.indexOf(\'(\') > -1) {\n
                negP = true;\n
                format = format.slice(1, -1);\n
            } else if (format.indexOf(\'+\') > -1) {\n
                signed = true;\n
                format = format.replace(/\\+/g, \'\');\n
            }\n
\n
            // see if abbreviation is wanted\n
            if (format.indexOf(\'a\') > -1) {\n
                // check if abbreviation is specified\n
                abbrK = format.indexOf(\'aK\') >= 0;\n
                abbrM = format.indexOf(\'aM\') >= 0;\n
                abbrB = format.indexOf(\'aB\') >= 0;\n
                abbrT = format.indexOf(\'aT\') >= 0;\n
                abbrForce = abbrK || abbrM || abbrB || abbrT;\n
\n
                // check for space before abbreviation\n
                if (format.indexOf(\' a\') > -1) {\n
                    abbr = \' \';\n
                    format = format.replace(\' a\', \'\');\n
                } else {\n
                    format = format.replace(\'a\', \'\');\n
                }\n
\n
                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n
                    // trillion\n
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;\n
                    value = value / Math.pow(10, 12);\n
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n
                    // billion\n
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;\n
                    value = value / Math.pow(10, 9);\n
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n
                    // million\n
                    abbr = abbr + languages[currentLanguage].abbreviations.million;\n
                    value = value / Math.pow(10, 6);\n
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n
                    // thousand\n
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;\n
                    value = value / Math.pow(10, 3);\n
                }\n
            }\n
\n
            // see if we are formatting bytes\n
            if (format.indexOf(\'b\') > -1) {\n
                // check for space before\n
                if (format.indexOf(\' b\') > -1) {\n
                    bytes = \' \';\n
                    format = format.replace(\' b\', \'\');\n
                } else {\n
                    format = format.replace(\'b\', \'\');\n
                }\n
\n
                for (power = 0; power <= suffixes.length; power++) {\n
                    min = Math.pow(1024, power);\n
                    max = Math.pow(1024, power+1);\n
\n
                    if (value >= min && value < max) {\n
                        bytes = bytes + suffixes[power];\n
                        if (min > 0) {\n
                            value = value / min;\n
                        }\n
                        break;\n
                    }\n
                }\n
            }\n
\n
            // see if ordinal is wanted\n
            if (format.indexOf(\'o\') > -1) {\n
                // check for space before\n
                if (format.indexOf(\' o\') > -1) {\n
                    ord = \' \';\n
                    format = format.replace(\' o\', \'\');\n
                } else {\n
                    format = format.replace(\'o\', \'\');\n
                }\n
\n
                ord = ord + languages[currentLanguage].ordinal(value);\n
            }\n
\n
            if (format.indexOf(\'[.]\') > -1) {\n
                optDec = true;\n
                format = format.replace(\'[.]\', \'.\');\n
            }\n
\n
            w = value.toString().split(\'.\')[0];\n
            precision = format.split(\'.\')[1];\n
            thousands = format.indexOf(\',\');\n
\n
            if (precision) {\n
                if (precision.indexOf(\'[\') > -1) {\n
                    precision = precision.replace(\']\', \'\');\n
                    precision = precision.split(\'[\');\n
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n
                } else {\n
                    d = toFixed(value, precision.length, roundingFunction);\n
                }\n
\n
                w = d.split(\'.\')[0];\n
\n
                if (d.split(\'.\')[1].length) {\n
                    d = languages[currentLanguage].delimiters.decimal + d.split(\'.\')[1];\n
                } else {\n
                    d = \'\';\n
                }\n
\n
                if (optDec && Number(d.slice(1)) === 0) {\n
                    d = \'\';\n
                }\n
            } else {\n
                w = toFixed(value, null, roundingFunction);\n
            }\n
\n
            // format number\n
            if (w.indexOf(\'-\') > -1) {\n
                w = w.slice(1);\n
                neg = true;\n
            }\n
\n
            if (thousands > -1) {\n
                w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \'$1\' + languages[currentLanguage].delimiters.thousands);\n
            }\n
\n
            if (format.indexOf(\'.\') === 0) {\n
                w = \'\';\n
            }\n
\n
            return ((negP && neg) ? \'(\' : \'\') + ((!negP && neg) ? \'-\' : \'\') + ((!neg && signed) ? \'+\' : \'\') + w + d + ((ord) ? ord : \'\') + ((abbr) ? abbr : \'\') + ((bytes) ? bytes : \'\') + ((negP && neg) ? \')\' : \'\');\n
        }\n
    }\n
\n
    /************************************\n
        Top Level Functions\n
    ************************************/\n
\n
    numeral = function (input) {\n
        if (numeral.isNumeral(input)) {\n
            input = input.value();\n
        } else if (input === 0 || typeof input === \'undefined\') {\n
            input = 0;\n
        } else if (!Number(input)) {\n
            input = numeral.fn.unformat(input);\n
        }\n
\n
        return new Numeral(Number(input));\n
    };\n
\n
    // version number\n
    numeral.version = VERSION;\n
\n
    // compare numeral object\n
    numeral.isNumeral = function (obj) {\n
        return obj instanceof Numeral;\n
    };\n
\n
    // This function will load languages and then set the global language.  If\n
    // no arguments are passed in, it will simply return the current global\n
    // language key.\n
    numeral.language = function (key, values) {\n
        if (!key) {\n
            return currentLanguage;\n
        }\n
\n
        if (key && !values) {\n
            if(!languages[key]) {\n
                throw new Error(\'Unknown language : \' + key);\n
            }\n
            currentLanguage = key;\n
        }\n
\n
        if (values || !languages[key]) {\n
            loadLanguage(key, values);\n
        }\n
\n
        return numeral;\n
    };\n
\n
    // This function provides access to the loaded language data.  If\n
    // no arguments are passed in, it will simply return the current\n
    // global language object.\n
    numeral.languageData = function (key) {\n
        if (!key) {\n
            return languages[currentLanguage];\n
        }\n
\n
        if (!languages[key]) {\n
            throw new Error(\'Unknown language : \' + key);\n
        }\n
\n
        return languages[key];\n
    };\n
\n
    numeral.language(\'en\', {\n
        delimiters: {\n
            thousands: \',\',\n
            decimal: \'.\'\n
        },\n
        abbreviations: {\n
            thousand: \'k\',\n
            million: \'m\',\n
            billion: \'b\',\n
            trillion: \'t\'\n
        },\n
        ordinal: function (number) {\n
            var b = number % 10;\n
            return (~~ (number % 100 / 10) === 1) ? \'th\' :\n
                (b === 1) ? \'st\' :\n
                (b === 2) ? \'nd\' :\n
                (b === 3) ? \'rd\' : \'th\';\n
        },\n
        currency: {\n
            symbol: \'$\'\n
        }\n
    });\n
\n
    numeral.zeroFormat = function (format) {\n
        zeroFormat = typeof(format) === \'string\' ? format : null;\n
    };\n
\n
    numeral.defaultFormat = function (format) {\n
        defaultFormat = typeof(format) === \'string\' ? format : \'0.0\';\n
    };\n
\n
    numeral.validate = function(val, culture) {\n
\n
        var _decimalSep,\n
          _thousandSep,\n
          _currSymbol,\n
          _valArray,\n
          _abbrObj,\n
          _thousandRegEx,\n
          languageData,\n
          temp;\n
\n
        //coerce val to string\n
        if (typeof val !== \'string\') {\n
            val += \'\';\n
            if (console.warn) {\n
                console.warn(\'Numeral.js: Value is not string. It has been co-erced to: \', val);\n
            }\n
        }\n
\n
        //trim whitespaces from either sides\n
        val = val.trim();\n
\n
\n
        //if val is empty return false\n
        if (val === \'\') {\n
            return false;\n
        }\n
\n
        //replace the initial \'+\' or \'-\' sign if present\n
        val = val.replace(/^[+-]?/, \'\');\n
\n
\n
        //get the decimal and thousands separator from numeral.languageData\n
        try {\n
            //check if the culture is understood by numeral. if not, default it to current language\n
            languageData = numeral.languageData(culture);\n
        } catch (e) {\n
            languageData = numeral.languageData(numeral.language());\n
        }\n
\n
        //setup the delimiters and currency symbol based on culture/language\n
        _currSymbol = languageData.currency.symbol;\n
        _abbrObj = languageData.abbreviations;\n
        _decimalSep = languageData.delimiters.decimal;\n
        if (languageData.delimiters.thousands === \'.\') {\n
            _thousandSep = \'\\\\.\';\n
        } else {\n
            _thousandSep = languageData.delimiters.thousands;\n
        }\n
\n
        //validating currency symbol\n
        temp = val.match(/^[^\\d\\.\\,]+/);\n
        if (temp !== null) {\n
            //chuck the currency symbol away\n
            val = val.substr(1);\n
            if (temp[0] !== _currSymbol) {\n
                return false;\n
            }\n
        }\n
\n
        //validating abbreviation symbol\n
        temp = val.match(/[^\\d]+$/);\n
        if (temp !== null) {\n
            val = val.slice(0, - 1);\n
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n
                return false;\n
            }\n
        }\n
\n
        //if val is just digits the return true\n
        if ( !! val.match(/^\\d+$/)) {\n
            return true;\n
        }\n
        _thousandRegEx = new RegExp(_thousandSep + \'{2}\');\n
\n
        if (!val.match(/[^\\d.,]/g)) {\n
            _valArray = val.split(_decimalSep);\n
            if (_valArray.length > 2) {\n
                return false;\n
            } else {\n
                if (_valArray.length < 2) {\n
                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n
                } else {\n
                    // for values without leading zero eg. .984\n
                    if (_valArray[0] === \'\') {\n
                        return ( !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n
                    } else if (_valArray[0].length === 1) {\n
                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n
                    } else {\n
                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n
                    }\n
                }\n
            }\n
        }\n
\n
        return false;\n
    };\n
\n
    /************************************\n
        Helpers\n
    ************************************/\n
\n
    function loadLanguage(key, values) {\n
        languages[key] = values;\n
    }\n
\n
    /************************************\n
        Floating-point helpers\n
    ************************************/\n
\n
    // The floating-point helper functions and implementation\n
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/\n
\n
    /**\n
     * Array.prototype.reduce for browsers that don\'t support it\n
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility\n
     */\n
    if (\'function\' !== typeof Array.prototype.reduce) {\n
        Array.prototype.reduce = function (callback, opt_initialValue) {\n
            \'use strict\';\n
\n
            if (null === this || \'undefined\' === typeof this) {\n
                // At the moment all modern browsers, that support strict mode, have\n
                // native implementation of Array.prototype.reduce. For instance, IE8\n
                // does not support strict mode, so this check is actually useless.\n
                throw new TypeError(\'Array.prototype.reduce called on null or undefined\');\n
            }\n
\n
            if (\'function\' !== typeof callback) {\n
                throw new TypeError(callback + \' is not a function\');\n
            }\n
\n
            var index,\n
                value,\n
                length = this.length >>> 0,\n
                isValueSet = false;\n
\n
            if (1 < arguments.length) {\n
                value = opt_initialValue;\n
                isValueSet = true;\n
            }\n
\n
            for (index = 0; length > index; ++index) {\n
                if (this.hasOwnProperty(index)) {\n
                    if (isValueSet) {\n
                        value = callback(value, this[index], index, this);\n
                    } else {\n
                        value = this[index];\n
                        isValueSet = true;\n
                    }\n
                }\n
            }\n
\n
            if (!isValueSet) {\n
                throw new TypeError(\'Reduce of empty array with no initial value\');\n
            }\n
\n
            return value;\n
        };\n
    }\n
\n
\n
    /**\n
     * Computes the multiplier necessary to make x >= 1,\n
     * effectively eliminating miscalculations caused by\n
     * finite precision.\n
     */\n
    function multiplier(x) {\n
        var parts = x.toString().split(\'.\');\n
        if (parts.length < 2) {\n
            return 1;\n
        }\n
        return Math.pow(10, parts[1].length);\n
    }\n
\n
    /**\n
     * Given a variable number of arguments, returns the maximum\n
     * multiplier that must be used to normalize an operation involving\n
     * all of them.\n
     */\n
    function correctionFactor() {\n
        var args = Array.prototype.slice.call(arguments);\n
        return args.reduce(function (prev, next) {\n
            var mp = multiplier(prev),\n
                mn = multiplier(next);\n
        return mp > mn ? mp : mn;\n
        }, -Infinity);\n
    }\n
\n
\n
    /************************************\n
        Numeral Prototype\n
    ************************************/\n
\n
\n
    numeral.fn = Numeral.prototype = {\n
\n
        clone : function () {\n
            return numeral(this);\n
        },\n
\n
        format : function (inputString, roundingFunction) {\n
            return formatNumeral(this,\n
                  inputString ? inputString : defaultFormat,\n
                  (roundingFunction !== undefined) ? roundingFunction : Math.round\n
              );\n
        },\n
\n
        unformat : function (inputString) {\n
            if (Object.prototype.toString.call(inputString) === \'[object Number]\') {\n
                return inputString;\n
            }\n
            return unformatNumeral(this, inputString ? inputString : defaultFormat);\n
        },\n
\n
        value : function () {\n
            return this._value;\n
        },\n
\n
        valueOf : function () {\n
            return this._value;\n
        },\n
\n
        set : function (value) {\n
            this._value = Number(value);\n
            return this;\n
        },\n
\n
        add : function (value) {\n
            var corrFactor = correctionFactor.call(null, this._value, value);\n
\n
            function cback(accum, curr, currI, O) {\n
                return accum + corrFactor * curr;\n
            }\n
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;\n
            return this;\n
        },\n
\n
        subtract : function (value) {\n
            var corrFactor = correctionFactor.call(null, this._value, value);\n
\n
            function cback(accum, curr, currI, O) {\n
                return accum - corrFactor * curr;\n
            }\n
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;\n
            return this;\n
        },\n
\n
        multiply : function (value) {\n
            function cback(accum, curr, currI, O) {\n
                var corrFactor = correctionFactor(accum, curr);\n
                return (accum * corrFactor) * (curr * corrFactor) /\n
                    (corrFactor * corrFactor);\n
            }\n
            this._value = [this._value, value].reduce(cback, 1);\n
            return this;\n
        },\n
\n
        divide : function (value) {\n
            function cback(accum, curr, currI, O) {\n
                var corrFactor = correctionFactor(accum, curr);\n
                return (accum * corrFactor) / (curr * corrFactor);\n
            }\n
            this._value = [this._value, value].reduce(cback);\n
            return this;\n
        },\n
\n
        difference : function (value) {\n
            return Math.abs(numeral(this._value).subtract(value).value());\n
        }\n
\n
    };\n
\n
    /************************************\n
        Exposing Numeral\n
    ************************************/\n
\n
    // CommonJS module is defined\n
    if (hasModule) {\n
        module.exports = numeral;\n
    }\n
\n
    /*global ender:false */\n
    if (typeof ender === \'undefined\') {\n
        // here, `this` means `window` in the browser, or `global` on the server\n
        // add `numeral` as a global object via a string identifier,\n
        // for Closure Compiler \'advanced\' mode\n
        this[\'numeral\'] = numeral;\n
    }\n
\n
    /*global define:false */\n
    if (typeof define === \'function\' && define.amd) {\n
        define([], function () {\n
            return numeral;\n
        });\n
    }\n
}).call(window);\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>27152</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>numeral.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
