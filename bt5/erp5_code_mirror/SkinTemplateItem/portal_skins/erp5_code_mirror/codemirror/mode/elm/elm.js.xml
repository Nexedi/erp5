<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604378.6</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>elm.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
(function(mod) {\n
  if (typeof exports == "object" && typeof module == "object") // CommonJS\n
    mod(require("../../lib/codemirror"));\n
  else if (typeof define == "function" && define.amd) // AMD\n
    define(["../../lib/codemirror"], mod);\n
  else // Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  "use strict";\n
\n
  CodeMirror.defineMode("elm", function() {\n
\n
    function switchState(source, setState, f) {\n
      setState(f);\n
      return f(source, setState);\n
    }\n
\n
    // These should all be Unicode extended, as per the Haskell 2010 report\n
    var smallRE = /[a-z_]/;\n
    var largeRE = /[A-Z]/;\n
    var digitRE = /[0-9]/;\n
    var hexitRE = /[0-9A-Fa-f]/;\n
    var octitRE = /[0-7]/;\n
    var idRE = /[a-z_A-Z0-9\\\']/;\n
    var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:\\u03BB\\u2192]/;\n
    var specialRE = /[(),;[\\]`{}]/;\n
    var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n
\n
    function normal() {\n
      return function (source, setState) {\n
        if (source.eatWhile(whiteCharRE)) {\n
          return null;\n
        }\n
\n
        var ch = source.next();\n
        if (specialRE.test(ch)) {\n
          if (ch == \'{\' && source.eat(\'-\')) {\n
            var t = "comment";\n
            if (source.eat(\'#\')) t = "meta";\n
            return switchState(source, setState, ncomment(t, 1));\n
          }\n
          return null;\n
        }\n
\n
        if (ch == \'\\\'\') {\n
          if (source.eat(\'\\\\\'))\n
            source.next();  // should handle other escapes here\n
          else\n
            source.next();\n
\n
          if (source.eat(\'\\\'\'))\n
            return "string";\n
          return "error";\n
        }\n
\n
        if (ch == \'"\') {\n
          return switchState(source, setState, stringLiteral);\n
        }\n
\n
        if (largeRE.test(ch)) {\n
          source.eatWhile(idRE);\n
          if (source.eat(\'.\'))\n
            return "qualifier";\n
          return "variable-2";\n
        }\n
\n
        if (smallRE.test(ch)) {\n
          var isDef = source.pos === 1;\n
          source.eatWhile(idRE);\n
          return isDef ? "variable-3" : "variable";\n
        }\n
\n
        if (digitRE.test(ch)) {\n
          if (ch == \'0\') {\n
            if (source.eat(/[xX]/)) {\n
              source.eatWhile(hexitRE); // should require at least 1\n
              return "integer";\n
            }\n
            if (source.eat(/[oO]/)) {\n
              source.eatWhile(octitRE); // should require at least 1\n
              return "number";\n
            }\n
          }\n
          source.eatWhile(digitRE);\n
          var t = "number";\n
          if (source.eat(\'.\')) {\n
            t = "number";\n
            source.eatWhile(digitRE); // should require at least 1\n
          }\n
          if (source.eat(/[eE]/)) {\n
            t = "number";\n
            source.eat(/[-+]/);\n
            source.eatWhile(digitRE); // should require at least 1\n
          }\n
          return t;\n
        }\n
\n
        if (symbolRE.test(ch)) {\n
          if (ch == \'-\' && source.eat(/-/)) {\n
            source.eatWhile(/-/);\n
            if (!source.eat(symbolRE)) {\n
              source.skipToEnd();\n
              return "comment";\n
            }\n
          }\n
          source.eatWhile(symbolRE);\n
          return "builtin";\n
        }\n
\n
        return "error";\n
      }\n
    }\n
\n
    function ncomment(type, nest) {\n
      if (nest == 0) {\n
        return normal();\n
      }\n
      return function(source, setState) {\n
        var currNest = nest;\n
        while (!source.eol()) {\n
          var ch = source.next();\n
          if (ch == \'{\' && source.eat(\'-\')) {\n
            ++currNest;\n
          } else if (ch == \'-\' && source.eat(\'}\')) {\n
            --currNest;\n
            if (currNest == 0) {\n
              setState(normal());\n
              return type;\n
            }\n
          }\n
        }\n
        setState(ncomment(type, currNest));\n
        return type;\n
      }\n
    }\n
\n
    function stringLiteral(source, setState) {\n
      while (!source.eol()) {\n
        var ch = source.next();\n
        if (ch == \'"\') {\n
          setState(normal());\n
          return "string";\n
        }\n
        if (ch == \'\\\\\') {\n
          if (source.eol() || source.eat(whiteCharRE)) {\n
            setState(stringGap);\n
            return "string";\n
          }\n
          if (!source.eat(\'&\')) source.next(); // should handle other escapes here\n
        }\n
      }\n
      setState(normal());\n
      return "error";\n
    }\n
\n
    function stringGap(source, setState) {\n
      if (source.eat(\'\\\\\')) {\n
        return switchState(source, setState, stringLiteral);\n
      }\n
      source.next();\n
      setState(normal());\n
      return "error";\n
    }\n
\n
\n
    var wellKnownWords = (function() {\n
      var wkw = {};\n
\n
      var keywords = [\n
        "case", "of", "as",\n
        "if", "then", "else",\n
        "let", "in",\n
        "infix", "infixl", "infixr",\n
        "type", "alias",\n
        "input", "output", "foreign", "loopback",\n
        "module", "where", "import", "exposing",\n
        "_", "..", "|", ":", "=", "\\\\", "\\"", "->", "<-"\n
      ];\n
\n
      for (var i = keywords.length; i--;)\n
        wkw[keywords[i]] = "keyword";\n
\n
      return wkw;\n
    })();\n
\n
\n
\n
    return {\n
      startState: function ()  { return { f: normal() }; },\n
      copyState:  function (s) { return { f: s.f }; },\n
\n
      token: function(stream, state) {\n
        var t = state.f(stream, function(s) { state.f = s; });\n
        var w = stream.current();\n
        return (wellKnownWords.hasOwnProperty(w)) ? wellKnownWords[w] : t;\n
      }\n
    };\n
\n
  });\n
\n
  CodeMirror.defineMIME("text/x-elm", "elm");\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>5552</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
