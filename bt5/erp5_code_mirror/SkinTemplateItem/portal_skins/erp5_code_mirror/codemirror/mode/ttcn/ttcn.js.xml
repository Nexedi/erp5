<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604387.45</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>ttcn.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
(function(mod) {\n
  if (typeof exports == "object" && typeof module == "object") // CommonJS\n
    mod(require("../../lib/codemirror"));\n
  else if (typeof define == "function" && define.amd) // AMD\n
    define(["../../lib/codemirror"], mod);\n
  else // Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  "use strict";\n
\n
  CodeMirror.defineMode("ttcn", function(config, parserConfig) {\n
    var indentUnit = config.indentUnit,\n
        keywords = parserConfig.keywords || {},\n
        builtin = parserConfig.builtin || {},\n
        timerOps = parserConfig.timerOps || {},\n
        portOps  = parserConfig.portOps || {},\n
        configOps = parserConfig.configOps || {},\n
        verdictOps = parserConfig.verdictOps || {},\n
        sutOps = parserConfig.sutOps || {},\n
        functionOps = parserConfig.functionOps || {},\n
\n
        verdictConsts = parserConfig.verdictConsts || {},\n
        booleanConsts = parserConfig.booleanConsts || {},\n
        otherConsts   = parserConfig.otherConsts || {},\n
\n
        types = parserConfig.types || {},\n
        visibilityModifiers = parserConfig.visibilityModifiers || {},\n
        templateMatch = parserConfig.templateMatch || {},\n
        multiLineStrings = parserConfig.multiLineStrings,\n
        indentStatements = parserConfig.indentStatements !== false;\n
    var isOperatorChar = /[+\\-*&@=<>!\\/]/;\n
    var curPunc;\n
\n
    function tokenBase(stream, state) {\n
      var ch = stream.next();\n
\n
      if (ch == \'"\' || ch == "\'") {\n
        state.tokenize = tokenString(ch);\n
        return state.tokenize(stream, state);\n
      }\n
      if (/[\\[\\]{}\\(\\),;\\\\:\\?\\.]/.test(ch)) {\n
        curPunc = ch;\n
        return "punctuation";\n
      }\n
      if (ch == "#"){\n
        stream.skipToEnd();\n
        return "atom preprocessor";\n
      }\n
      if (ch == "%"){\n
        stream.eatWhile(/\\b/);\n
        return "atom ttcn3Macros";\n
      }\n
      if (/\\d/.test(ch)) {\n
        stream.eatWhile(/[\\w\\.]/);\n
        return "number";\n
      }\n
      if (ch == "/") {\n
        if (stream.eat("*")) {\n
          state.tokenize = tokenComment;\n
          return tokenComment(stream, state);\n
        }\n
        if (stream.eat("/")) {\n
          stream.skipToEnd();\n
          return "comment";\n
        }\n
      }\n
      if (isOperatorChar.test(ch)) {\n
        if(ch == "@"){\n
          if(stream.match("try") || stream.match("catch")\n
              || stream.match("lazy")){\n
            return "keyword";\n
          }\n
        }\n
        stream.eatWhile(isOperatorChar);\n
        return "operator";\n
      }\n
      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n
      var cur = stream.current();\n
\n
      if (keywords.propertyIsEnumerable(cur)) return "keyword";\n
      if (builtin.propertyIsEnumerable(cur)) return "builtin";\n
\n
      if (timerOps.propertyIsEnumerable(cur)) return "def timerOps";\n
      if (configOps.propertyIsEnumerable(cur)) return "def configOps";\n
      if (verdictOps.propertyIsEnumerable(cur)) return "def verdictOps";\n
      if (portOps.propertyIsEnumerable(cur)) return "def portOps";\n
      if (sutOps.propertyIsEnumerable(cur)) return "def sutOps";\n
      if (functionOps.propertyIsEnumerable(cur)) return "def functionOps";\n
\n
      if (verdictConsts.propertyIsEnumerable(cur)) return "string verdictConsts";\n
      if (booleanConsts.propertyIsEnumerable(cur)) return "string booleanConsts";\n
      if (otherConsts.propertyIsEnumerable(cur)) return "string otherConsts";\n
\n
      if (types.propertyIsEnumerable(cur)) return "builtin types";\n
      if (visibilityModifiers.propertyIsEnumerable(cur))\n
        return "builtin visibilityModifiers";\n
      if (templateMatch.propertyIsEnumerable(cur)) return "atom templateMatch";\n
\n
      return "variable";\n
    }\n
\n
    function tokenString(quote) {\n
      return function(stream, state) {\n
        var escaped = false, next, end = false;\n
        while ((next = stream.next()) != null) {\n
          if (next == quote && !escaped){\n
            var afterQuote = stream.peek();\n
            //look if the character after the quote is like the B in \'10100010\'B\n
            if (afterQuote){\n
              afterQuote = afterQuote.toLowerCase();\n
              if(afterQuote == "b" || afterQuote == "h" || afterQuote == "o")\n
                stream.next();\n
            }\n
            end = true; break;\n
          }\n
          escaped = !escaped && next == "\\\\";\n
        }\n
        if (end || !(escaped || multiLineStrings))\n
          state.tokenize = null;\n
        return "string";\n
      };\n
    }\n
\n
    function tokenComment(stream, state) {\n
      var maybeEnd = false, ch;\n
      while (ch = stream.next()) {\n
        if (ch == "/" && maybeEnd) {\n
          state.tokenize = null;\n
          break;\n
        }\n
        maybeEnd = (ch == "*");\n
      }\n
      return "comment";\n
    }\n
\n
    function Context(indented, column, type, align, prev) {\n
      this.indented = indented;\n
      this.column = column;\n
      this.type = type;\n
      this.align = align;\n
      this.prev = prev;\n
    }\n
\n
    function pushContext(state, col, type) {\n
      var indent = state.indented;\n
      if (state.context && state.context.type == "statement")\n
        indent = state.context.indented;\n
      return state.context = new Context(indent, col, type, null, state.context);\n
    }\n
\n
    function popContext(state) {\n
      var t = state.context.type;\n
      if (t == ")" || t == "]" || t == "}")\n
        state.indented = state.context.indented;\n
      return state.context = state.context.prev;\n
    }\n
\n
    //Interface\n
    return {\n
      startState: function(basecolumn) {\n
        return {\n
          tokenize: null,\n
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),\n
          indented: 0,\n
          startOfLine: true\n
        };\n
      },\n
\n
      token: function(stream, state) {\n
        var ctx = state.context;\n
        if (stream.sol()) {\n
          if (ctx.align == null) ctx.align = false;\n
          state.indented = stream.indentation();\n
          state.startOfLine = true;\n
        }\n
        if (stream.eatSpace()) return null;\n
        curPunc = null;\n
        var style = (state.tokenize || tokenBase)(stream, state);\n
        if (style == "comment") return style;\n
        if (ctx.align == null) ctx.align = true;\n
\n
        if ((curPunc == ";" || curPunc == ":" || curPunc == ",")\n
            && ctx.type == "statement"){\n
          popContext(state);\n
        }\n
        else if (curPunc == "{") pushContext(state, stream.column(), "}");\n
        else if (curPunc == "[") pushContext(state, stream.column(), "]");\n
        else if (curPunc == "(") pushContext(state, stream.column(), ")");\n
        else if (curPunc == "}") {\n
          while (ctx.type == "statement") ctx = popContext(state);\n
          if (ctx.type == "}") ctx = popContext(state);\n
          while (ctx.type == "statement") ctx = popContext(state);\n
        }\n
        else if (curPunc == ctx.type) popContext(state);\n
        else if (indentStatements &&\n
            (((ctx.type == "}" || ctx.type == "top") && curPunc != \';\') ||\n
            (ctx.type == "statement" && curPunc == "newstatement")))\n
          pushContext(state, stream.column(), "statement");\n
\n
        state.startOfLine = false;\n
\n
        return style;\n
      },\n
\n
      electricChars: "{}",\n
      blockCommentStart: "/*",\n
      blockCommentEnd: "*/",\n
      lineComment: "//",\n
      fold: "brace"\n
    };\n
  });\n
\n
  function words(str) {\n
    var obj = {}, words = str.split(" ");\n
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n
    return obj;\n
  }\n
\n
  function def(mimes, mode) {\n
    if (typeof mimes == "string") mimes = [mimes];\n
    var words = [];\n
    function add(obj) {\n
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))\n
        words.push(prop);\n
    }\n
\n
    add(mode.keywords);\n
    add(mode.builtin);\n
    add(mode.timerOps);\n
    add(mode.portOps);\n
\n
    if (words.length) {\n
      mode.helperType = mimes[0];\n
      CodeMirror.registerHelper("hintWords", mimes[0], words);\n
    }\n
\n
    for (var i = 0; i < mimes.length; ++i)\n
      CodeMirror.defineMIME(mimes[i], mode);\n
  }\n
\n
  def(["text/x-ttcn", "text/x-ttcn3", "text/x-ttcnpp"], {\n
    name: "ttcn",\n
    keywords: words("activate address alive all alt altstep and and4b any" +\n
    " break case component const continue control deactivate" +\n
    " display do else encode enumerated except exception" +\n
    " execute extends extension external for from function" +\n
    " goto group if import in infinity inout interleave" +\n
    " label language length log match message mixed mod" +\n
    " modifies module modulepar mtc noblock not not4b nowait" +\n
    " of on optional or or4b out override param pattern port" +\n
    " procedure record recursive rem repeat return runs select" +\n
    " self sender set signature system template testcase to" +\n
    " type union value valueof var variant while with xor xor4b"),\n
    builtin: words("bit2hex bit2int bit2oct bit2str char2int char2oct encvalue" +\n
    " decomp decvalue float2int float2str hex2bit hex2int" +\n
    " hex2oct hex2str int2bit int2char int2float int2hex" +\n
    " int2oct int2str int2unichar isbound ischosen ispresent" +\n
    " isvalue lengthof log2str oct2bit oct2char oct2hex oct2int" +\n
    " oct2str regexp replace rnd sizeof str2bit str2float" +\n
    " str2hex str2int str2oct substr unichar2int unichar2char" +\n
    " enum2int"),\n
    types: words("anytype bitstring boolean char charstring default float" +\n
    " hexstring integer objid octetstring universal verdicttype timer"),\n
    timerOps: words("read running start stop timeout"),\n
    portOps: words("call catch check clear getcall getreply halt raise receive" +\n
    " reply send trigger"),\n
    configOps: words("create connect disconnect done kill killed map unmap"),\n
    verdictOps: words("getverdict setverdict"),\n
    sutOps: words("action"),\n
    functionOps: words("apply derefers refers"),\n
\n
    verdictConsts: words("error fail inconc none pass"),\n
    booleanConsts: words("true false"),\n
    otherConsts: words("null NULL omit"),\n
\n
    visibilityModifiers: words("private public friend"),\n
    templateMatch: words("complement ifpresent subset superset permutation"),\n
    multiLineStrings: true\n
  });\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>10155</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
