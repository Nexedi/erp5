<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604382.35</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>mscgen.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
// mode(s) for the sequence chart dsl\'s mscgen, xÃ¹ and msgenny\n
// For more information on mscgen, see the site of the original author:\n
// http://www.mcternan.me.uk/mscgen\n
//\n
// This mode for mscgen and the two derivative languages were\n
// originally made for use in the mscgen_js interpreter\n
// (https://sverweij.github.io/mscgen_js)\n
\n
(function(mod) {\n
  if ( typeof exports == "object" && typeof module == "object")// CommonJS\n
    mod(require("../../lib/codemirror"));\n
  else if ( typeof define == "function" && define.amd)// AMD\n
    define(["../../lib/codemirror"], mod);\n
  else// Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  "use strict";\n
\n
  var languages = {\n
    mscgen: {\n
      "keywords" : ["msc"],\n
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs"],\n
      "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],\n
      "brackets" : ["\\\\{", "\\\\}"], // [ and  ] are brackets too, but these get handled in with lists\n
      "arcsWords" : ["note", "abox", "rbox", "box"],\n
      "arcsOthers" : ["\\\\|\\\\|\\\\|", "\\\\.\\\\.\\\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\\\.\\\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],\n
      "singlecomment" : ["//", "#"],\n
      "operators" : ["="]\n
    },\n
    xu: {\n
      "keywords" : ["msc"],\n
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "watermark"],\n
      "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],\n
      "brackets" : ["\\\\{", "\\\\}"],  // [ and  ] are brackets too, but these get handled in with lists\n
      "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],\n
      "arcsOthers" : ["\\\\|\\\\|\\\\|", "\\\\.\\\\.\\\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\\\.\\\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],\n
      "singlecomment" : ["//", "#"],\n
      "operators" : ["="]\n
    },\n
    msgenny: {\n
      "keywords" : null,\n
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "watermark"],\n
      "attributes" : null,\n
      "brackets" : ["\\\\{", "\\\\}"],\n
      "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],\n
      "arcsOthers" : ["\\\\|\\\\|\\\\|", "\\\\.\\\\.\\\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\\\.\\\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],\n
      "singlecomment" : ["//", "#"],\n
      "operators" : ["="]\n
    }\n
  }\n
\n
  CodeMirror.defineMode("mscgen", function(_, modeConfig) {\n
    var language = languages[modeConfig && modeConfig.language || "mscgen"]\n
    return {\n
      startState: startStateFn,\n
      copyState: copyStateFn,\n
      token: produceTokenFunction(language),\n
      lineComment : "#",\n
      blockCommentStart : "/*",\n
      blockCommentEnd : "*/"\n
    };\n
  });\n
\n
  CodeMirror.defineMIME("text/x-mscgen", "mscgen");\n
  CodeMirror.defineMIME("text/x-xu", {name: "mscgen", language: "xu"});\n
  CodeMirror.defineMIME("text/x-msgenny", {name: "mscgen", language: "msgenny"});\n
\n
  function wordRegexpBoundary(pWords) {\n
    return new RegExp("\\\\b(" + pWords.join("|") + ")\\\\b", "i");\n
  }\n
\n
  function wordRegexp(pWords) {\n
    return new RegExp("(" + pWords.join("|") + ")", "i");\n
  }\n
\n
  function startStateFn() {\n
    return {\n
      inComment : false,\n
      inString : false,\n
      inAttributeList : false,\n
      inScript : false\n
    };\n
  }\n
\n
  function copyStateFn(pState) {\n
    return {\n
      inComment : pState.inComment,\n
      inString : pState.inString,\n
      inAttributeList : pState.inAttributeList,\n
      inScript : pState.inScript\n
    };\n
  }\n
\n
  function produceTokenFunction(pConfig) {\n
\n
    return function(pStream, pState) {\n
      if (pStream.match(wordRegexp(pConfig.brackets), true, true)) {\n
        return "bracket";\n
      }\n
      /* comments */\n
      if (!pState.inComment) {\n
        if (pStream.match(/\\/\\*[^\\*\\/]*/, true, true)) {\n
          pState.inComment = true;\n
          return "comment";\n
        }\n
        if (pStream.match(wordRegexp(pConfig.singlecomment), true, true)) {\n
          pStream.skipToEnd();\n
          return "comment";\n
        }\n
      }\n
      if (pState.inComment) {\n
        if (pStream.match(/[^\\*\\/]*\\*\\//, true, true))\n
          pState.inComment = false;\n
        else\n
          pStream.skipToEnd();\n
        return "comment";\n
      }\n
      /* strings */\n
      if (!pState.inString && pStream.match(/\\"(\\\\\\"|[^\\"])*/, true, true)) {\n
        pState.inString = true;\n
        return "string";\n
      }\n
      if (pState.inString) {\n
        if (pStream.match(/[^\\"]*\\"/, true, true))\n
          pState.inString = false;\n
        else\n
          pStream.skipToEnd();\n
        return "string";\n
      }\n
      /* keywords & operators */\n
      if (!!pConfig.keywords && pStream.match(wordRegexpBoundary(pConfig.keywords), true, true))\n
        return "keyword";\n
\n
      if (pStream.match(wordRegexpBoundary(pConfig.options), true, true))\n
        return "keyword";\n
\n
      if (pStream.match(wordRegexpBoundary(pConfig.arcsWords), true, true))\n
        return "keyword";\n
\n
      if (pStream.match(wordRegexp(pConfig.arcsOthers), true, true))\n
        return "keyword";\n
\n
      if (!!pConfig.operators && pStream.match(wordRegexp(pConfig.operators), true, true))\n
        return "operator";\n
\n
      /* attribute lists */\n
      if (!pConfig.inAttributeList && !!pConfig.attributes && pStream.match(/\\[/, true, true)) {\n
        pConfig.inAttributeList = true;\n
        return "bracket";\n
      }\n
      if (pConfig.inAttributeList) {\n
        if (pConfig.attributes !== null && pStream.match(wordRegexpBoundary(pConfig.attributes), true, true)) {\n
          return "attribute";\n
        }\n
        if (pStream.match(/]/, true, true)) {\n
          pConfig.inAttributeList = false;\n
          return "bracket";\n
        }\n
      }\n
\n
      pStream.next();\n
      return "base";\n
    };\n
  }\n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>6523</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
