<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604387.36</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>ttcn-cfg.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
(function(mod) {\n
  if (typeof exports == "object" && typeof module == "object") // CommonJS\n
    mod(require("../../lib/codemirror"));\n
  else if (typeof define == "function" && define.amd) // AMD\n
    define(["../../lib/codemirror"], mod);\n
  else // Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  "use strict";\n
\n
  CodeMirror.defineMode("ttcn-cfg", function(config, parserConfig) {\n
    var indentUnit = config.indentUnit,\n
        keywords = parserConfig.keywords || {},\n
        fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions || {},\n
        externalCommands = parserConfig.externalCommands || {},\n
        multiLineStrings = parserConfig.multiLineStrings,\n
        indentStatements = parserConfig.indentStatements !== false;\n
    var isOperatorChar = /[\\|]/;\n
    var curPunc;\n
\n
    function tokenBase(stream, state) {\n
      var ch = stream.next();\n
      if (ch == \'"\' || ch == "\'") {\n
        state.tokenize = tokenString(ch);\n
        return state.tokenize(stream, state);\n
      }\n
      if (/[:=]/.test(ch)) {\n
        curPunc = ch;\n
        return "punctuation";\n
      }\n
      if (ch == "#"){\n
        stream.skipToEnd();\n
        return "comment";\n
      }\n
      if (/\\d/.test(ch)) {\n
        stream.eatWhile(/[\\w\\.]/);\n
        return "number";\n
      }\n
      if (isOperatorChar.test(ch)) {\n
        stream.eatWhile(isOperatorChar);\n
        return "operator";\n
      }\n
      if (ch == "["){\n
        stream.eatWhile(/[\\w_\\]]/);\n
        return "number sectionTitle";\n
      }\n
\n
      stream.eatWhile(/[\\w\\$_]/);\n
      var cur = stream.current();\n
      if (keywords.propertyIsEnumerable(cur)) return "keyword";\n
      if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))\n
        return "negative fileNCtrlMaskOptions";\n
      if (externalCommands.propertyIsEnumerable(cur)) return "negative externalCommands";\n
\n
      return "variable";\n
    }\n
\n
    function tokenString(quote) {\n
      return function(stream, state) {\n
        var escaped = false, next, end = false;\n
        while ((next = stream.next()) != null) {\n
          if (next == quote && !escaped){\n
            var afterNext = stream.peek();\n
            //look if the character if the quote is like the B in \'10100010\'B\n
            if (afterNext){\n
              afterNext = afterNext.toLowerCase();\n
              if(afterNext == "b" || afterNext == "h" || afterNext == "o")\n
                stream.next();\n
            }\n
            end = true; break;\n
          }\n
          escaped = !escaped && next == "\\\\";\n
        }\n
        if (end || !(escaped || multiLineStrings))\n
          state.tokenize = null;\n
        return "string";\n
      };\n
    }\n
\n
    function Context(indented, column, type, align, prev) {\n
      this.indented = indented;\n
      this.column = column;\n
      this.type = type;\n
      this.align = align;\n
      this.prev = prev;\n
    }\n
    function pushContext(state, col, type) {\n
      var indent = state.indented;\n
      if (state.context && state.context.type == "statement")\n
        indent = state.context.indented;\n
      return state.context = new Context(indent, col, type, null, state.context);\n
    }\n
    function popContext(state) {\n
      var t = state.context.type;\n
      if (t == ")" || t == "]" || t == "}")\n
        state.indented = state.context.indented;\n
      return state.context = state.context.prev;\n
    }\n
\n
    //Interface\n
    return {\n
      startState: function(basecolumn) {\n
        return {\n
          tokenize: null,\n
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),\n
          indented: 0,\n
          startOfLine: true\n
        };\n
      },\n
\n
      token: function(stream, state) {\n
        var ctx = state.context;\n
        if (stream.sol()) {\n
          if (ctx.align == null) ctx.align = false;\n
          state.indented = stream.indentation();\n
          state.startOfLine = true;\n
        }\n
        if (stream.eatSpace()) return null;\n
        curPunc = null;\n
        var style = (state.tokenize || tokenBase)(stream, state);\n
        if (style == "comment") return style;\n
        if (ctx.align == null) ctx.align = true;\n
\n
        if ((curPunc == ";" || curPunc == ":" || curPunc == ",")\n
            && ctx.type == "statement"){\n
          popContext(state);\n
        }\n
        else if (curPunc == "{") pushContext(state, stream.column(), "}");\n
        else if (curPunc == "[") pushContext(state, stream.column(), "]");\n
        else if (curPunc == "(") pushContext(state, stream.column(), ")");\n
        else if (curPunc == "}") {\n
          while (ctx.type == "statement") ctx = popContext(state);\n
          if (ctx.type == "}") ctx = popContext(state);\n
          while (ctx.type == "statement") ctx = popContext(state);\n
        }\n
        else if (curPunc == ctx.type) popContext(state);\n
        else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")\n
            && curPunc != \';\') || (ctx.type == "statement"\n
            && curPunc == "newstatement")))\n
          pushContext(state, stream.column(), "statement");\n
        state.startOfLine = false;\n
        return style;\n
      },\n
\n
      electricChars: "{}",\n
      lineComment: "#",\n
      fold: "brace"\n
    };\n
  });\n
\n
  function words(str) {\n
    var obj = {}, words = str.split(" ");\n
    for (var i = 0; i < words.length; ++i)\n
      obj[words[i]] = true;\n
    return obj;\n
  }\n
\n
  CodeMirror.defineMIME("text/x-ttcn-cfg", {\n
    name: "ttcn-cfg",\n
    keywords: words("Yes No LogFile FileMask ConsoleMask AppendFile" +\n
    " TimeStampFormat LogEventTypes SourceInfoFormat" +\n
    " LogEntityName LogSourceInfo DiskFullAction" +\n
    " LogFileNumber LogFileSize MatchingHints Detailed" +\n
    " Compact SubCategories Stack Single None Seconds" +\n
    " DateTime Time Stop Error Retry Delete TCPPort KillTimer" +\n
    " NumHCs UnixSocketsEnabled LocalAddress"),\n
    fileNCtrlMaskOptions: words("TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING" +\n
    " TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP" +\n
    " TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION" +\n
    " TTCN_USER TTCN_FUNCTION TTCN_STATISTICS" +\n
    " TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG" +\n
    " EXECUTOR ERROR WARNING PORTEVENT TIMEROP" +\n
    " VERDICTOP DEFAULTOP TESTCASE ACTION USER" +\n
    " FUNCTION STATISTICS PARALLEL MATCHING DEBUG" +\n
    " LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED" +\n
    " DEBUG_ENCDEC DEBUG_TESTPORT" +\n
    " DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE" +\n
    " DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT" +\n
    " DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED" +\n
    " EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA" +\n
    " EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS" +\n
    " EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED" +\n
    " FUNCTION_RND FUNCTION_UNQUALIFIED" +\n
    " MATCHING_DONE MATCHING_MCSUCCESS" +\n
    " MATCHING_MCUNSUCC MATCHING_MMSUCCESS" +\n
    " MATCHING_MMUNSUCC MATCHING_PCSUCCESS" +\n
    " MATCHING_PCUNSUCC MATCHING_PMSUCCESS" +\n
    " MATCHING_PMUNSUCC MATCHING_PROBLEM" +\n
    " MATCHING_TIMEOUT MATCHING_UNQUALIFIED" +\n
    " PARALLEL_PORTCONN PARALLEL_PORTMAP" +\n
    " PARALLEL_PTC PARALLEL_UNQUALIFIED" +\n
    " PORTEVENT_DUALRECV PORTEVENT_DUALSEND" +\n
    " PORTEVENT_MCRECV PORTEVENT_MCSEND" +\n
    " PORTEVENT_MMRECV PORTEVENT_MMSEND" +\n
    " PORTEVENT_MQUEUE PORTEVENT_PCIN" +\n
    " PORTEVENT_PCOUT PORTEVENT_PMIN" +\n
    " PORTEVENT_PMOUT PORTEVENT_PQUEUE" +\n
    " PORTEVENT_STATE PORTEVENT_UNQUALIFIED" +\n
    " STATISTICS_UNQUALIFIED STATISTICS_VERDICT" +\n
    " TESTCASE_FINISH TESTCASE_START" +\n
    " TESTCASE_UNQUALIFIED TIMEROP_GUARD" +\n
    " TIMEROP_READ TIMEROP_START TIMEROP_STOP" +\n
    " TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED" +\n
    " USER_UNQUALIFIED VERDICTOP_FINAL" +\n
    " VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT" +\n
    " VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED"),\n
    externalCommands: words("BeginControlPart EndControlPart BeginTestCase" +\n
    " EndTestCase"),\n
    multiLineStrings: true\n
  });\n
});

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>7857</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
