<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604371.88</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>closebrackets.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
(function(mod) {\n
  if (typeof exports == "object" && typeof module == "object") // CommonJS\n
    mod(require("../../lib/codemirror"));\n
  else if (typeof define == "function" && define.amd) // AMD\n
    define(["../../lib/codemirror"], mod);\n
  else // Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  var defaults = {\n
    pairs: "()[]{}\'\'\\"\\"",\n
    triples: "",\n
    explode: "[]{}"\n
  };\n
\n
  var Pos = CodeMirror.Pos;\n
\n
  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {\n
    if (old && old != CodeMirror.Init) {\n
      cm.removeKeyMap(keyMap);\n
      cm.state.closeBrackets = null;\n
    }\n
    if (val) {\n
      cm.state.closeBrackets = val;\n
      cm.addKeyMap(keyMap);\n
    }\n
  });\n
\n
  function getOption(conf, name) {\n
    if (name == "pairs" && typeof conf == "string") return conf;\n
    if (typeof conf == "object" && conf[name] != null) return conf[name];\n
    return defaults[name];\n
  }\n
\n
  var bind = defaults.pairs + "`";\n
  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n
  for (var i = 0; i < bind.length; i++)\n
    keyMap["\'" + bind.charAt(i) + "\'"] = handler(bind.charAt(i));\n
\n
  function handler(ch) {\n
    return function(cm) { return handleChar(cm, ch); };\n
  }\n
\n
  function getConfig(cm) {\n
    var deflt = cm.state.closeBrackets;\n
    if (!deflt) return null;\n
    var mode = cm.getModeAt(cm.getCursor());\n
    return mode.closeBrackets || deflt;\n
  }\n
\n
  function handleBackspace(cm) {\n
    var conf = getConfig(cm);\n
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;\n
\n
    var pairs = getOption(conf, "pairs");\n
    var ranges = cm.listSelections();\n
    for (var i = 0; i < ranges.length; i++) {\n
      if (!ranges[i].empty()) return CodeMirror.Pass;\n
      var around = charsAround(cm, ranges[i].head);\n
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n
    }\n
    for (var i = ranges.length - 1; i >= 0; i--) {\n
      var cur = ranges[i].head;\n
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");\n
    }\n
  }\n
\n
  function handleEnter(cm) {\n
    var conf = getConfig(cm);\n
    var explode = conf && getOption(conf, "explode");\n
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;\n
\n
    var ranges = cm.listSelections();\n
    for (var i = 0; i < ranges.length; i++) {\n
      if (!ranges[i].empty()) return CodeMirror.Pass;\n
      var around = charsAround(cm, ranges[i].head);\n
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n
    }\n
    cm.operation(function() {\n
      cm.replaceSelection("\\n\\n", null);\n
      cm.execCommand("goCharLeft");\n
      ranges = cm.listSelections();\n
      for (var i = 0; i < ranges.length; i++) {\n
        var line = ranges[i].head.line;\n
        cm.indentLine(line, null, true);\n
        cm.indentLine(line + 1, null, true);\n
      }\n
    });\n
  }\n
\n
  function contractSelection(sel) {\n
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n
    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n
            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n
  }\n
\n
  function handleChar(cm, ch) {\n
    var conf = getConfig(cm);\n
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;\n
\n
    var pairs = getOption(conf, "pairs");\n
    var pos = pairs.indexOf(ch);\n
    if (pos == -1) return CodeMirror.Pass;\n
    var triples = getOption(conf, "triples");\n
\n
    var identical = pairs.charAt(pos + 1) == ch;\n
    var ranges = cm.listSelections();\n
    var opening = pos % 2 == 0;\n
\n
    var type, next;\n
    for (var i = 0; i < ranges.length; i++) {\n
      var range = ranges[i], cur = range.head, curType;\n
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n
      if (opening && !range.empty()) {\n
        curType = "surround";\n
      } else if ((identical || !opening) && next == ch) {\n
        if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n
          curType = "skipThree";\n
        else\n
          curType = "skip";\n
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n
                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n
                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n
        curType = "addFour";\n
      } else if (identical) {\n
        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = "both";\n
        else return CodeMirror.Pass;\n
      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n
                             isClosingBracket(next, pairs) ||\n
                             /\\s/.test(next))) {\n
        curType = "both";\n
      } else {\n
        return CodeMirror.Pass;\n
      }\n
      if (!type) type = curType;\n
      else if (type != curType) return CodeMirror.Pass;\n
    }\n
\n
    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n
    cm.operation(function() {\n
      if (type == "skip") {\n
        cm.execCommand("goCharRight");\n
      } else if (type == "skipThree") {\n
        for (var i = 0; i < 3; i++)\n
          cm.execCommand("goCharRight");\n
      } else if (type == "surround") {\n
        var sels = cm.getSelections();\n
        for (var i = 0; i < sels.length; i++)\n
          sels[i] = left + sels[i] + right;\n
        cm.replaceSelections(sels, "around");\n
        sels = cm.listSelections().slice();\n
        for (var i = 0; i < sels.length; i++)\n
          sels[i] = contractSelection(sels[i]);\n
        cm.setSelections(sels);\n
      } else if (type == "both") {\n
        cm.replaceSelection(left + right, null);\n
        cm.triggerElectric(left + right);\n
        cm.execCommand("goCharLeft");\n
      } else if (type == "addFour") {\n
        cm.replaceSelection(left + left + left + left, "before");\n
        cm.execCommand("goCharRight");\n
      }\n
    });\n
  }\n
\n
  function isClosingBracket(ch, pairs) {\n
    var pos = pairs.lastIndexOf(ch);\n
    return pos > -1 && pos % 2 == 1;\n
  }\n
\n
  function charsAround(cm, pos) {\n
    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n
                          Pos(pos.line, pos.ch + 1));\n
    return str.length == 2 ? str : null;\n
  }\n
\n
  // Project the token type that will exists after the given char is\n
  // typed, and use it to determine whether it would cause the start\n
  // of a string token.\n
  function enteringString(cm, pos, ch) {\n
    var line = cm.getLine(pos.line);\n
    var token = cm.getTokenAt(pos);\n
    if (/\\bstring2?\\b/.test(token.type)) return false;\n
    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n
    stream.pos = stream.start = token.start;\n
    for (;;) {\n
      var type1 = cm.getMode().token(stream, token.state);\n
      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n
      stream.start = stream.pos;\n
    }\n
  }\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>6945</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
