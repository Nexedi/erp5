<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604373.45</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>sql-hint.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
(function(mod) {\n
  if (typeof exports == "object" && typeof module == "object") // CommonJS\n
    mod(require("../../lib/codemirror"), require("../../mode/sql/sql"));\n
  else if (typeof define == "function" && define.amd) // AMD\n
    define(["../../lib/codemirror", "../../mode/sql/sql"], mod);\n
  else // Plain browser env\n
    mod(CodeMirror);\n
})(function(CodeMirror) {\n
  "use strict";\n
\n
  var tables;\n
  var defaultTable;\n
  var keywords;\n
  var CONS = {\n
    QUERY_DIV: ";",\n
    ALIAS_KEYWORD: "AS"\n
  };\n
  var Pos = CodeMirror.Pos;\n
\n
  function isArray(val) { return Object.prototype.toString.call(val) == "[object Array]" }\n
\n
  function getKeywords(editor) {\n
    var mode = editor.doc.modeOption;\n
    if (mode === "sql") mode = "text/x-sql";\n
    return CodeMirror.resolveMode(mode).keywords;\n
  }\n
\n
  function getText(item) {\n
    return typeof item == "string" ? item : item.text;\n
  }\n
\n
  function wrapTable(name, value) {\n
    if (isArray(value)) value = {columns: value}\n
    if (!value.text) value.text = name\n
    return value\n
  }\n
\n
  function parseTables(input) {\n
    var result = {}\n
    if (isArray(input)) {\n
      for (var i = input.length - 1; i >= 0; i--) {\n
        var item = input[i]\n
        result[getText(item).toUpperCase()] = wrapTable(getText(item), item)\n
      }\n
    } else if (input) {\n
      for (var name in input)\n
        result[name.toUpperCase()] = wrapTable(name, input[name])\n
    }\n
    return result\n
  }\n
\n
  function getTable(name) {\n
    return tables[name.toUpperCase()]\n
  }\n
\n
  function shallowClone(object) {\n
    var result = {};\n
    for (var key in object) if (object.hasOwnProperty(key))\n
      result[key] = object[key];\n
    return result;\n
  }\n
\n
  function match(string, word) {\n
    var len = string.length;\n
    var sub = getText(word).substr(0, len);\n
    return string.toUpperCase() === sub.toUpperCase();\n
  }\n
\n
  function addMatches(result, search, wordlist, formatter) {\n
    if (isArray(wordlist)) {\n
      for (var i = 0; i < wordlist.length; i++)\n
        if (match(search, wordlist[i])) result.push(formatter(wordlist[i]))\n
    } else {\n
      for (var word in wordlist) if (wordlist.hasOwnProperty(word)) {\n
        var val = wordlist[word]\n
        if (!val || val === true)\n
          val = word\n
        else\n
          val = val.displayText ? {text: val.text, displayText: val.displayText} : val.text\n
        if (match(search, val)) result.push(formatter(val))\n
      }\n
    }\n
  }\n
\n
  function cleanName(name) {\n
    // Get rid name from backticks(`) and preceding dot(.)\n
    if (name.charAt(0) == ".") {\n
      name = name.substr(1);\n
    }\n
    return name.replace(/`/g, "");\n
  }\n
\n
  function insertBackticks(name) {\n
    var nameParts = getText(name).split(".");\n
    for (var i = 0; i < nameParts.length; i++)\n
      nameParts[i] = "`" + nameParts[i] + "`";\n
    var escaped = nameParts.join(".");\n
    if (typeof name == "string") return escaped;\n
    name = shallowClone(name);\n
    name.text = escaped;\n
    return name;\n
  }\n
\n
  function nameCompletion(cur, token, result, editor) {\n
    // Try to complete table, colunm names and return start position of completion\n
    var useBacktick = false;\n
    var nameParts = [];\n
    var start = token.start;\n
    var cont = true;\n
    while (cont) {\n
      cont = (token.string.charAt(0) == ".");\n
      useBacktick = useBacktick || (token.string.charAt(0) == "`");\n
\n
      start = token.start;\n
      nameParts.unshift(cleanName(token.string));\n
\n
      token = editor.getTokenAt(Pos(cur.line, token.start));\n
      if (token.string == ".") {\n
        cont = true;\n
        token = editor.getTokenAt(Pos(cur.line, token.start));\n
      }\n
    }\n
\n
    // Try to complete table names\n
    var string = nameParts.join(".");\n
    addMatches(result, string, tables, function(w) {\n
      return useBacktick ? insertBackticks(w) : w;\n
    });\n
\n
    // Try to complete columns from defaultTable\n
    addMatches(result, string, defaultTable, function(w) {\n
      return useBacktick ? insertBackticks(w) : w;\n
    });\n
\n
    // Try to complete columns\n
    string = nameParts.pop();\n
    var table = nameParts.join(".");\n
\n
    var alias = false;\n
    var aliasTable = table;\n
    // Check if table is available. If not, find table by Alias\n
    if (!getTable(table)) {\n
      var oldTable = table;\n
      table = findTableByAlias(table, editor);\n
      if (table !== oldTable) alias = true;\n
    }\n
\n
    var columns = getTable(table);\n
    if (columns && columns.columns)\n
      columns = columns.columns;\n
\n
    if (columns) {\n
      addMatches(result, string, columns, function(w) {\n
        var tableInsert = table;\n
        if (alias == true) tableInsert = aliasTable;\n
        if (typeof w == "string") {\n
          w = tableInsert + "." + w;\n
        } else {\n
          w = shallowClone(w);\n
          w.text = tableInsert + "." + w.text;\n
        }\n
        return useBacktick ? insertBackticks(w) : w;\n
      });\n
    }\n
\n
    return start;\n
  }\n
\n
  function eachWord(lineText, f) {\n
    if (!lineText) return;\n
    var excepted = /[,;]/g;\n
    var words = lineText.split(" ");\n
    for (var i = 0; i < words.length; i++) {\n
      f(words[i]?words[i].replace(excepted, \'\') : \'\');\n
    }\n
  }\n
\n
  function convertCurToNumber(cur) {\n
    // max characters of a line is 999,999.\n
    return cur.line + cur.ch / Math.pow(10, 6);\n
  }\n
\n
  function convertNumberToCur(num) {\n
    return Pos(Math.floor(num), +num.toString().split(\'.\').pop());\n
  }\n
\n
  function findTableByAlias(alias, editor) {\n
    var doc = editor.doc;\n
    var fullQuery = doc.getValue();\n
    var aliasUpperCase = alias.toUpperCase();\n
    var previousWord = "";\n
    var table = "";\n
    var separator = [];\n
    var validRange = {\n
      start: Pos(0, 0),\n
      end: Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).length)\n
    };\n
\n
    //add separator\n
    var indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV);\n
    while(indexOfSeparator != -1) {\n
      separator.push(doc.posFromIndex(indexOfSeparator));\n
      indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV, indexOfSeparator+1);\n
    }\n
    separator.unshift(Pos(0, 0));\n
    separator.push(Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).text.length));\n
\n
    //find valid range\n
    var prevItem = 0;\n
    var current = convertCurToNumber(editor.getCursor());\n
    for (var i = 0; i < separator.length; i++) {\n
      var _v = convertCurToNumber(separator[i]);\n
      if (current > prevItem && current <= _v) {\n
        validRange = { start: convertNumberToCur(prevItem), end: convertNumberToCur(_v) };\n
        break;\n
      }\n
      prevItem = _v;\n
    }\n
\n
    var query = doc.getRange(validRange.start, validRange.end, false);\n
\n
    for (var i = 0; i < query.length; i++) {\n
      var lineText = query[i];\n
      eachWord(lineText, function(word) {\n
        var wordUpperCase = word.toUpperCase();\n
        if (wordUpperCase === aliasUpperCase && getTable(previousWord))\n
          table = previousWord;\n
        if (wordUpperCase !== CONS.ALIAS_KEYWORD)\n
          previousWord = word;\n
      });\n
      if (table) break;\n
    }\n
    return table;\n
  }\n
\n
  CodeMirror.registerHelper("hint", "sql", function(editor, options) {\n
    tables = parseTables(options && options.tables)\n
    var defaultTableName = options && options.defaultTable;\n
    var disableKeywords = options && options.disableKeywords;\n
    defaultTable = defaultTableName && getTable(defaultTableName);\n
    keywords = keywords || getKeywords(editor);\n
\n
    if (defaultTableName && !defaultTable)\n
      defaultTable = findTableByAlias(defaultTableName, editor);\n
\n
    defaultTable = defaultTable || [];\n
\n
    if (defaultTable.columns)\n
      defaultTable = defaultTable.columns;\n
\n
    var cur = editor.getCursor();\n
    var result = [];\n
    var token = editor.getTokenAt(cur), start, end, search;\n
    if (token.end > cur.ch) {\n
      token.end = cur.ch;\n
      token.string = token.string.slice(0, cur.ch - token.start);\n
    }\n
\n
    if (token.string.match(/^[.`\\w@]\\w*$/)) {\n
      search = token.string;\n
      start = token.start;\n
      end = token.end;\n
    } else {\n
      start = end = cur.ch;\n
      search = "";\n
    }\n
    if (search.charAt(0) == "." || search.charAt(0) == "`") {\n
      start = nameCompletion(cur, token, result, editor);\n
    } else {\n
      addMatches(result, search, tables, function(w) {return w;});\n
      addMatches(result, search, defaultTable, function(w) {return w;});\n
      if (!disableKeywords)\n
        addMatches(result, search, keywords, function(w) {return w.toUpperCase();});\n
    }\n
\n
    return {list: result, from: Pos(cur.line, start), to: Pos(cur.line, end)};\n
  });\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>8578</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
