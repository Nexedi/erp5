<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Cacheable__manager_id</string> </key>
            <value> <string>http_cache</string> </value>
        </item>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts60604374.47</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>runmode.node.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// CodeMirror, copyright (c) by Marijn Haverbeke and others\n
// Distributed under an MIT license: http://codemirror.net/LICENSE\n
\n
/* Just enough of CodeMirror to run runMode under node.js */\n
\n
function splitLines(string){return string.split(/\\r\\n?|\\n/);};\n
\n
// Counts the column offset in a string, taking tabs into account.\n
// Used mostly to find indentation.\n
var countColumn = function(string, end, tabSize, startIndex, startValue) {\n
  if (end == null) {\n
    end = string.search(/[^\\s\\u00a0]/);\n
    if (end == -1) end = string.length;\n
  }\n
  for (var i = startIndex || 0, n = startValue || 0;;) {\n
    var nextTab = string.indexOf("\\t", i);\n
    if (nextTab < 0 || nextTab >= end)\n
      return n + (end - i);\n
    n += nextTab - i;\n
    n += tabSize - (n % tabSize);\n
    i = nextTab + 1;\n
  }\n
};\n
\n
function StringStream(string, tabSize) {\n
  this.pos = this.start = 0;\n
  this.string = string;\n
  this.tabSize = tabSize || 8;\n
  this.lastColumnPos = this.lastColumnValue = 0;\n
  this.lineStart = 0;\n
};\n
\n
StringStream.prototype = {\n
  eol: function() {return this.pos >= this.string.length;},\n
  sol: function() {return this.pos == this.lineStart;},\n
  peek: function() {return this.string.charAt(this.pos) || undefined;},\n
  next: function() {\n
    if (this.pos < this.string.length)\n
      return this.string.charAt(this.pos++);\n
  },\n
  eat: function(match) {\n
    var ch = this.string.charAt(this.pos);\n
    if (typeof match == "string") var ok = ch == match;\n
    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n
    if (ok) {++this.pos; return ch;}\n
  },\n
  eatWhile: function(match) {\n
    var start = this.pos;\n
    while (this.eat(match)){}\n
    return this.pos > start;\n
  },\n
  eatSpace: function() {\n
    var start = this.pos;\n
    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n
    return this.pos > start;\n
  },\n
  skipToEnd: function() {this.pos = this.string.length;},\n
  skipTo: function(ch) {\n
    var found = this.string.indexOf(ch, this.pos);\n
    if (found > -1) {this.pos = found; return true;}\n
  },\n
  backUp: function(n) {this.pos -= n;},\n
  column: function() {\n
    if (this.lastColumnPos < this.start) {\n
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n
      this.lastColumnPos = this.start;\n
    }\n
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n
  },\n
  indentation: function() {\n
    return countColumn(this.string, null, this.tabSize) -\n
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n
  },\n
  match: function(pattern, consume, caseInsensitive) {\n
    if (typeof pattern == "string") {\n
      var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n
      var substr = this.string.substr(this.pos, pattern.length);\n
      if (cased(substr) == cased(pattern)) {\n
        if (consume !== false) this.pos += pattern.length;\n
        return true;\n
      }\n
    } else {\n
      var match = this.string.slice(this.pos).match(pattern);\n
      if (match && match.index > 0) return null;\n
      if (match && consume !== false) this.pos += match[0].length;\n
      return match;\n
    }\n
  },\n
  current: function(){return this.string.slice(this.start, this.pos);},\n
  hideFirstChars: function(n, inner) {\n
    this.lineStart += n;\n
    try { return inner(); }\n
    finally { this.lineStart -= n; }\n
  }\n
};\n
exports.StringStream = StringStream;\n
\n
exports.startState = function(mode, a1, a2) {\n
  return mode.startState ? mode.startState(a1, a2) : true;\n
};\n
\n
var modes = exports.modes = {}, mimeModes = exports.mimeModes = {};\n
exports.defineMode = function(name, mode) {\n
  if (arguments.length > 2)\n
    mode.dependencies = Array.prototype.slice.call(arguments, 2);\n
  modes[name] = mode;\n
};\n
exports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n
\n
exports.defineMode("null", function() {\n
  return {token: function(stream) {stream.skipToEnd();}};\n
});\n
exports.defineMIME("text/plain", "null");\n
\n
exports.resolveMode = function(spec) {\n
  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n
    spec = mimeModes[spec];\n
  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n
    spec = mimeModes[spec.name];\n
  }\n
  if (typeof spec == "string") return {name: spec};\n
  else return spec || {name: "null"};\n
};\n
\n
function copyObj(obj, target, overwrite) {\n
  if (!target) target = {};\n
  for (var prop in obj)\n
    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n
      target[prop] = obj[prop];\n
  return target;\n
}\n
\n
// This can be used to attach properties to mode objects from\n
// outside the actual mode definition.\n
var modeExtensions = exports.modeExtensions = {};\n
exports.extendMode = function(mode, properties) {\n
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n
  copyObj(properties, exts);\n
};\n
\n
exports.getMode = function(options, spec) {\n
  var spec = exports.resolveMode(spec);\n
  var mfactory = modes[spec.name];\n
  if (!mfactory) return exports.getMode(options, "text/plain");\n
  var modeObj = mfactory(options, spec);\n
  if (modeExtensions.hasOwnProperty(spec.name)) {\n
    var exts = modeExtensions[spec.name];\n
    for (var prop in exts) {\n
      if (!exts.hasOwnProperty(prop)) continue;\n
      if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\n
      modeObj[prop] = exts[prop];\n
    }\n
  }\n
  modeObj.name = spec.name;\n
  if (spec.helperType) modeObj.helperType = spec.helperType;\n
  if (spec.modeProps) for (var prop in spec.modeProps)\n
    modeObj[prop] = spec.modeProps[prop];\n
\n
  return modeObj;\n
};\n
exports.registerHelper = exports.registerGlobalHelper = Math.min;\n
\n
exports.runMode = function(string, modespec, callback, options) {\n
  var mode = exports.getMode({indentUnit: 2}, modespec);\n
  var lines = splitLines(string), state = (options && options.state) || exports.startState(mode);\n
  for (var i = 0, e = lines.length; i < e; ++i) {\n
    if (i) callback("\\n");\n
    var stream = new exports.StringStream(lines[i]);\n
    if (!stream.string && mode.blankLine) mode.blankLine(state);\n
    while (!stream.eol()) {\n
      var style = mode.token(stream, state);\n
      callback(stream.current(), style, i, stream.start, state);\n
      stream.start = stream.pos;\n
    }\n
  }\n
};\n
\n
require.cache[require.resolve("../../lib/codemirror")] = require.cache[require.resolve("./runmode.node")];\n
require.cache[require.resolve("../../addon/runmode/runmode")] = require.cache[require.resolve("./runmode.node")];\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>6528</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
