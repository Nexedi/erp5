diff --git a/bt5/erp5_core_test/TestTemplateItem/portal_components/test.erp5.testERP5Core.py b/bt5/erp5_core_test/TestTemplateItem/portal_components/test.erp5.testERP5Core.py
index 41376796d7..0f818f80bd 100644
--- a/bt5/erp5_core_test/TestTemplateItem/portal_components/test.erp5.testERP5Core.py
+++ b/bt5/erp5_core_test/TestTemplateItem/portal_components/test.erp5.testERP5Core.py
@@ -39,7 +39,7 @@ from DateTime import DateTime
 from Testing import ZopeTestCase
 
 from Products.ERP5Type.Utils import bytes2str, str2unicode, str2bytes
-from Products.ERP5Type.tests.utils import TemporaryAlarmScript
+from Products.ERP5Type.tests.utils import TemporaryPythonScript
 from Products.ERP5Type.tests.ERP5TypeTestCase import ERP5TypeTestCase
 from Products.ERP5Type.tests.utils import DummyTranslationService
 
@@ -725,8 +725,8 @@ class TestERP5Core(ERP5TypeTestCase, ZopeTestCase.Functional):
     # Must not raise even if Unauthorized to view
     document_1.standard_error_message(error_type="MyErrorType", error_message="my error message.")
 
-    with TemporaryAlarmScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
-                              "''", attribute=False):
+    with TemporaryPythonScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
+                               body="return ''"):
       # Override the script to allow anonymous to render xhtml style
       response = self.publish(document_1.getPath(), self.auth)
     self.assertEqual(response.getStatus(), 401)
diff --git a/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/Alarm_handleExpiredOAuth2SessionSet.py b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/Alarm_handleExpiredOAuth2SessionSet.py
index 42f6a201be..cdce20388e 100644
--- a/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/Alarm_handleExpiredOAuth2SessionSet.py
+++ b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/Alarm_handleExpiredOAuth2SessionSet.py
@@ -4,46 +4,93 @@ Cleanup OAuth2 Sessions.
 This is not required for expired sessions to be unusable (as they should be),
 but this allows cleaning up sessions from a document point of view.
 """
+LOAD_LIMIT = 10000
 now = DateTime()
-now_catalog_condition = '<%f' % now.timeTime()
 container_value = context.getPortalObject().session_module
 searchFolder = container_value.searchFolder
-client_lifespan_accuracy_dict = {}
-def getSessionAccuracyCompensatedExpirationMaxDate(session_value):
-  key = session_value.getSource()
-  try:
-    lifespan_accuracy = client_lifespan_accuracy_dict[key]
-  except KeyError:
-    lifespan_accuracy = client_lifespan_accuracy_dict[key] = session_value.getSourceValue().getRefreshTokenLifespanAccuracy() / 86400.
-  return session_value.getExpirationDate() + lifespan_accuracy
-def getSessionRawExpirationMaxDate(session_value):
-  return session_value.getExpirationDate()
-for (state, expiration_max_date, getSessionExpirationMaxDate, action) in (
-  ( # Draft sessions' expiration date is the time the Authorisation Code expires.
-    # These should be quite rare, as they mean authentication succeeded but was not transformed into a token.
-    # The session did not actually become something, so mark it deleted.
-    'draft',
-    now,
-    getSessionRawExpirationMaxDate,
-    lambda x: x.delete(),
-  ),
-  ( # Validated sessions' expiration date, plus the associated client's accuracy, is the time the Refresh Token expires.
-    # Invalidate the session, as it is now unusable and should not be presented to the user when listing active sessions.
-    'validated',
-    now,
-    getSessionAccuracyCompensatedExpirationMaxDate,
-    lambda x: x.invalidate(),
-  ),
-):
-  for session_value in searchFolder(
-    portal_type='OAuth2 Session',
-    validation_state=state,
-    float_index=now_catalog_condition,
+deletion_id_list = []
+action_tag = script.id + '_action'
+deletion_delay_days = context.ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay()
+if deletion_delay_days is None:
+  deletion_cutoff = None
+else:
+  deletion_cutoff = now - deletion_delay_days
+load_limit = LOAD_LIMIT
+action_skip_count = 0
+with context.defaultActivateParameterDict({'tag': action_tag}, placeless=True):
+  for (state_list, expiration_max_date, action) in (
+    ( # Draft sessions' expiration date is the time the Authorisation Code expires.
+      # These should be quite rare, as they mean authentication succeeded but was not transformed into a token.
+      # The session did not actually become something, so mark it deleted.
+      ('draft', ),
+      now,
+      lambda x: x.delete(),
+    ),
+    ( # Validated sessions' expiration date, plus the associated client's accuracy, is the time the Refresh Token expires.
+      # Invalidate the session, as it is now unusable and should not be presented to the user when listing active sessions.
+      ('validated', ),
+      # XXX: expects a maximum of one-day expiration max inaccuracy
+      now - 1,
+      lambda x: x.invalidate(),
+    ),
+    (
+      # Invalidated and deleted (state) sessions get deleted after enough time has passed.
+      ('invalidated', 'deleted'),
+      deletion_cutoff,
+      lambda x: deletion_id_list.append(x.getId()),
+    ),
   ):
-    session_value = session_value.getObject()
-    # Recheck document data from ZODB
-    if (
-      session_value.getValidationState() == state and
-      getSessionExpirationMaxDate(session_value) <= expiration_max_date
-    ):
-      action(session_value)
+    if expiration_max_date is None:
+      continue
+    catalog_date_condition = '<%f' % expiration_max_date.timeTime()
+    for state in state_list: # Query with a single state at a time for better SQL index efficiency
+      result_list = searchFolder(
+        portal_type='OAuth2 Session',
+        validation_state=state,
+        float_index=catalog_date_condition,
+        limit=load_limit,
+      )
+      load_limit -= len(result_list)
+      for session_value in result_list:
+        session_value = session_value.getObject()
+        # Recheck document data from ZODB
+        if (
+          session_value.getValidationState() == state and
+          session_value.getExpirationDate() <= expiration_max_date
+        ):
+          action(session_value)
+        else:
+          action_skip_count += 1
+      if load_limit <= 0:
+        break
+    else:
+      continue
+    break
+  if deletion_id_list:
+    container_value.manage_delObjects(ids=deletion_id_list)
+if load_limit <= 0:
+  if (
+    action_skip_count >= LOAD_LIMIT or (
+      action_skip_count > 100 and
+      action_skip_count > (LOAD_LIMIT - load_limit) / 10
+    )
+  ):
+    # Raise if we are about to respawn and more than 10% of the number of found documents were skipped, but not if the absolute value is under 100, but do if LOAD_LIMIT is less than 100.
+    # Possible consequences:
+    # - poor performance (every subsequent iteration will load and skip the same documents)
+    #   This one may be non-critical, but best to know of, investigate and fix.
+    # - infinite iteration (this script will respawn itself, find LOAD_LIMIT documents, process 0, and respawn itself until the in-ZODB conditions become true - which can take months)
+    #   This one is more difficult to properly fix, and worth a raise.
+    raise Exception('Many documents were matched in catalog but skipped by supposedly-identical condition on ZODB (action_skip_count=%s, load_limit=%s). Please investigate.' % (
+      action_skip_count,
+      load_limit,
+    ))
+  # The load quota was exhausted, there may be more to cleanup
+  getattr(
+    context.activate(
+      activity='SQLQueue',
+      priority=11,
+      after_tag=action_tag,
+    ),
+    script.id,
+  )()
diff --git a/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.py b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.py
new file mode 100644
index 0000000000..5c78131096
--- /dev/null
+++ b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.py
@@ -0,0 +1,5 @@
+# Override to customise the retention delay
+# Return a delay, in days, OAuth2 Session documents should be kept once they are invalidated (session expired after being fully established) or in deleted state (session expired mid-establishment and was never usable).
+# Or None to keep forever.
+# This is retroactively applied to existing documents (applied at deletion query-time, not state-change-time)
+return None
diff --git a/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.xml b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.xml
new file mode 100644
index 0000000000..412c6b59d1
--- /dev/null
+++ b/bt5/erp5_oauth2_authorisation/SkinTemplateItem/portal_skins/erp5_oauth2_authorisation/ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0"?>
+<ZopeData>
+  <record id="1" aka="AAAAAAAAAAE=">
+    <pickle>
+      <global name="PythonScript" module="Products.PythonScripts.PythonScript"/>
+    </pickle>
+    <pickle>
+      <dictionary>
+        <item>
+            <key> <string>_bind_names</string> </key>
+            <value>
+              <object>
+                <klass>
+                  <global name="_reconstructor" module="copy_reg"/>
+                </klass>
+                <tuple>
+                  <global name="NameAssignments" module="Shared.DC.Scripts.Bindings"/>
+                  <global name="object" module="__builtin__"/>
+                  <none/>
+                </tuple>
+                <state>
+                  <dictionary>
+                    <item>
+                        <key> <string>_asgns</string> </key>
+                        <value>
+                          <dictionary>
+                            <item>
+                                <key> <string>name_container</string> </key>
+                                <value> <string>container</string> </value>
+                            </item>
+                            <item>
+                                <key> <string>name_context</string> </key>
+                                <value> <string>context</string> </value>
+                            </item>
+                            <item>
+                                <key> <string>name_m_self</string> </key>
+                                <value> <string>script</string> </value>
+                            </item>
+                            <item>
+                                <key> <string>name_subpath</string> </key>
+                                <value> <string>traverse_subpath</string> </value>
+                            </item>
+                          </dictionary>
+                        </value>
+                    </item>
+                  </dictionary>
+                </state>
+              </object>
+            </value>
+        </item>
+        <item>
+            <key> <string>_params</string> </key>
+            <value> <string></string> </value>
+        </item>
+        <item>
+            <key> <string>id</string> </key>
+            <value> <string>ERP5Site_getPreferredInvalidatedOAuth2SessionDeletionDelay</string> </value>
+        </item>
+      </dictionary>
+    </pickle>
+  </record>
+</ZopeData>
diff --git a/bt5/erp5_oauth2_authorisation/TestTemplateItem/portal_components/test.erp5.testOAuth2Server.py b/bt5/erp5_oauth2_authorisation/TestTemplateItem/portal_components/test.erp5.testOAuth2Server.py
index a763f7654c..48bcf4ce30 100644
--- a/bt5/erp5_oauth2_authorisation/TestTemplateItem/portal_components/test.erp5.testOAuth2Server.py
+++ b/bt5/erp5_oauth2_authorisation/TestTemplateItem/portal_components/test.erp5.testOAuth2Server.py
@@ -46,6 +46,7 @@ from six.moves.urllib.parse import parse_qsl, quote, urlencode, urlsplit, urluns
 from AccessControl.SecurityManagement import getSecurityManager, setSecurityManager
 from DateTime import DateTime
 from Products.ERP5Type.tests.ERP5TypeTestCase import ERP5TypeTestCase
+from Products.ERP5Type.tests.utils import TemporaryPythonScript
 from Products.ERP5Type.Utils import bytes2str, str2bytes, unicode2str
 from Products.ERP5.ERP5Site import (
   ERP5_AUTHORISATION_EXTRACTOR_USERNAME_NAME,
@@ -1320,4 +1321,43 @@ class TestOAuth2(ERP5TypeTestCase):
         del cookie_jar[_TEST_ACCESS_COOKIE_NAME]
         del cookie_jar[_TEST_REFRESH_COOKIE_NAME]
 
+  def test_handle_expired_oauth2_session_set_alarm(self):
+    def execute_alarm(at_date):
+      with self.pinDateTime(at_date):
+        self.portal.portal_alarms.handle_expired_oauth2_session_set.activeSense()
+        self.tic()
+
+    def create_validated_session(session_id, expiration_date):
+      connector = self.__oauth2_server_connector_value
+      session = connector.createSession(
+        authorisation_code=session_id,
+        client_value=self.__oauth2_default_client_declaration_value,
+        redirect_uri=None,
+        scope_list=[],
+        code_challenge=None,
+        code_challenge_method=None,
+        network_address='127.0.0.1',
+        user_agent=self.id(),
+      )
+      def cleanup_session():
+        if self.portal.session_module.get(session.getId()) is not None:
+          self.portal.session_module.manage_delObjects([session.getId()])
+      self.addCleanUp(cleanup_session)
+      connector._validateSessionValue(session)
+      session.setPolicyExpirationDate(expiration_date)
+      return session
+
+    import pdb; pdb.set_trace()
+    old_validated_session = create_validated_session("old_validated_session", DateTime('2000/01/01'))
+    old_invalidated_session = create_validated_session("old_invalidated_session", DateTime('2000/01/01'))
+    old_invalidated_session.invalidate()
+    recent_validated_session = create_validated_session("recent_validated_session", DateTime())
+    self.tic()
+    with TemporaryPythonScript()
+    execute_alarm(at_date=DateTime('2000/06/01'))
+    self.assertEqual(old_validated_session.getValidationState(), 'invalidated')
+    self.assertIsNone(self.portal.session_module.get(old_invalidated_session.getId()))
+    self.assertEqual(old_invalidated_session.getValidationState(), 'invalidated')
+
+
   del _printQueryTraceOnFailure
diff --git a/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaCacheSecurity.py b/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaCacheSecurity.py
index 85bd09c6f4..11ca4c7d4a 100644
--- a/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaCacheSecurity.py
+++ b/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaCacheSecurity.py
@@ -32,7 +32,7 @@ from AccessControl import Unauthorized
 from Products.ERP5Type.tests.SecurityTestCase import SecurityTestCase
 from erp5.component.test.ShaCacheMixin import ShaCacheMixin
 from erp5.component.test.ShaSecurityMixin import ShaSecurityMixin
-from Products.ERP5Type.tests.utils import TemporaryAlarmScript
+from Products.ERP5Type.tests.utils import TemporaryPythonScript
 
 
 class TestShaCacheSecurity(ShaCacheMixin, ShaSecurityMixin, SecurityTestCase):
@@ -122,8 +122,8 @@ class TestShaCacheSecurity(ShaCacheMixin, ShaSecurityMixin, SecurityTestCase):
          self.logout()
          self.assertTrue(self.portal.portal_membership.isAnonymousUser())
 
-         with TemporaryAlarmScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
-                                   "''", attribute=False):
+         with TemporaryPythonScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
+                                    body="return ''"):
            # Anonymous can not render xhtml style
            document.view()
            document()
diff --git a/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaDirSecurity.py b/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaDirSecurity.py
index c3892d743f..53b9ea5882 100644
--- a/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaDirSecurity.py
+++ b/bt5/networkcache_erp5/TestTemplateItem/portal_components/test.erp5.testShaDirSecurity.py
@@ -32,7 +32,7 @@ from AccessControl import Unauthorized
 from Products.ERP5Type.tests.SecurityTestCase import SecurityTestCase
 from erp5.component.test.ShaDirMixin import ShaDirMixin
 from erp5.component.test.ShaSecurityMixin import ShaSecurityMixin
-from Products.ERP5Type.tests.utils import TemporaryAlarmScript
+from Products.ERP5Type.tests.utils import TemporaryPythonScript
 
 
 class TestShaDirSecurity(ShaDirMixin, ShaSecurityMixin, SecurityTestCase):
@@ -104,8 +104,8 @@ class TestShaDirSecurity(ShaDirMixin, ShaSecurityMixin, SecurityTestCase):
     self.logout()
     self.assertTrue(self.portal.portal_membership.isAnonymousUser())
 
-    with TemporaryAlarmScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
-                              "''", attribute=False):
+    with TemporaryPythonScript(self.portal, 'Base_checkUserCanViewERP5XHTMLStyleOrRaise',
+                               body="return ''"):
       # Anonymous can not render xhtml style
       data_set.view()
       data_set()
diff --git a/product/ERP5Type/patches/Restricted.py b/product/ERP5Type/patches/Restricted.py
index 76cf58b8ec..6a0e8d5a6b 100644
--- a/product/ERP5Type/patches/Restricted.py
+++ b/product/ERP5Type/patches/Restricted.py
@@ -523,7 +523,8 @@ for dtype in ('int8', 'int16', 'int32', 'int64', \
               'complex64', 'complex128', \
               'bool_', \
               # structured data
-              [('a', 'int8'), ('b', 'float16')]):
+              #[('a', 'int8'), ('b', 'float16')]
+              ):
   allow_type(type(np.dtype(dtype)))
   z = np.array([0,], dtype = dtype)
   allow_type(type(z[0]))
diff --git a/product/ERP5Type/tests/utils.py b/product/ERP5Type/tests/utils.py
index 68af55fa4e..73c8df8a84 100644
--- a/product/ERP5Type/tests/utils.py
+++ b/product/ERP5Type/tests/utils.py
@@ -99,42 +99,31 @@ class PortalAlarmDisabled(object):
   def __enter__(self):
     if self.was_subscribed:
       self.portal_alarms.unsubscribe()
-      # transaction.commit()
 
   def __exit__(self, exc_type, exc_value, traceback):
     if self.was_subscribed:
       self.portal_alarms.subscribe()
-      # transaction.commit()
 
 
-class TemporaryAlarmScript(object):
+class TemporaryPythonScript(object):
   """
-  Context manager for temporary alarm python scripts
+  Context manager for temporary python scripts in portal_skins/custom
   """
-  def __init__(self, portal, script_name, fake_return="", attribute=None):
+  def __init__(self, portal, script_name, arguments='', body=''):
     self.script_name = script_name
     self.portal = portal
-    self.fake_return = fake_return
-    self.attribute = attribute
+    self.arguments = arguments
+    self.body = body
 
   def __enter__(self):
-    if self.script_name in self.portal.portal_skins.custom.objectIds():
-      raise ValueError('Precondition failed: %s exists in custom' % self.script_name)
-    if self.attribute is None:
-      content = """portal_workflow = context.portal_workflow
-portal_workflow.doActionFor(context, action='edit_action', comment='Visited by %s')
-return %s""" % (self.script_name, self.fake_return)
-    elif self.attribute is False:
-      content = """return %s""" % self.fake_return
-    else:
-      content = """portal_workflow = context.portal_workflow
-context.edit(%s='Visited by %s')
-return %s""" % (self.attribute, self.script_name, self.fake_return)
-    createZODBPythonScript(self.portal.portal_skins.custom,
-                        self.script_name,
-                        '*args, **kwargs',
-                        '# Script body\n' + content)
+    script = createZODBPythonScript(
+      self.portal.portal_skins.custom,
+      self.script_name,
+      self.arguments,
+      self.body,
+    )
     transaction.commit()
+    return script
 
   def __exit__(self, exc_type, exc_value, traceback):
     if self.script_name in self.portal.portal_skins.custom.objectIds():
@@ -142,6 +131,29 @@ return %s""" % (self.attribute, self.script_name, self.fake_return)
     transaction.commit()
 
 
+class TemporaryAlarmScript(TemporaryPythonScript):
+  """
+  Context manager for temporary alarm python scripts
+  """
+  def __init__(self, portal, script_name, fake_return="", attribute=None):
+    if attribute is None:
+      body = """portal_workflow = context.portal_workflow
+portal_workflow.doActionFor(context, action='edit_action', comment='Visited by %s')
+return %s""" % (script_name, fake_return)
+    elif attribute is False:
+      body = """return %s""" % self.fake_return
+    else:
+      body = """portal_workflow = context.portal_workflow
+context.edit(%s='Visited by %s')
+return %s""" % (attribute, script_name, fake_return)
+    super(TemporaryAlarmScript, self).__init__(
+      portal,
+      script_name,
+      '*args, **kwargs',
+      body,
+    )
+
+
 # dummy objects
 class DummyMailHostMixin(object):
   """Dummy Mail Host that doesn't really send messages and keep a copy in
