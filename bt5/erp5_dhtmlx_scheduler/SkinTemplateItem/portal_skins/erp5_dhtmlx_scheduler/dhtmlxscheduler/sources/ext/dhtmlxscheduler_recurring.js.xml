<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts65189556.01</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>dhtmlxscheduler_recurring.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*\r\n
@license\r\n
dhtmlxScheduler v.4.3.1 \r\n
\r\n
This software is covered by GPL license. You also can obtain Commercial or Enterprise license to use it in non-GPL project - please contact sales@dhtmlx.com. Usage without proper license is prohibited.\r\n
\r\n
(c) Dinamenta, UAB.\r\n
*/\r\n
scheduler.config.occurrence_timestamp_in_utc = false;\r\n
scheduler.config.recurring_workdays = [1,2,3,4,5];\r\n
scheduler.form_blocks["recurring"] = {\r\n
\t_get_node : function(node){\r\n
\t\tif (typeof node == "string")\r\n
\t\t\tnode = document.getElementById(node);\r\n
\t\tif (node.style.display == \'none\')\r\n
\t\t\tnode.style.display = "";\r\n
\t\treturn node;\r\n
\t},\r\n
\t_outer_html: function(node){\r\n
\t\treturn node.outerHTML || getOuterHTML(node);\r\n
\r\n
\t\t//probably not needed, FF v10- only\r\n
\t\tfunction getOuterHTML(n){\r\n
\t\t\tvar div = document.createElement(\'div\'), h;\r\n
\t\t\tdiv.appendChild( n.cloneNode(true) );\r\n
\t\t\th = div.innerHTML;\r\n
\t\t\tdiv = null;\r\n
\t\t\treturn h;\r\n
\t\t}\r\n
\t},\r\n
\trender:function(sns) {\r\n
\t\tif(sns.form){\r\n
\t\t\tvar rec = scheduler.form_blocks["recurring"];\r\n
\t\t\tvar form = rec._get_node(sns.form);\r\n
\t\t\tvar html = rec._outer_html(form);\r\n
\t\t\tform.style.display = \'none\';\r\n
\t\t\treturn html;\r\n
\t\t}\r\n
\r\n
\t\treturn scheduler.__recurring_template;\r\n
\r\n
\t},\r\n
\t_ds: {},\r\n
\t_get_form_node: function(els, name, value){\r\n
\t\tvar col = els[name];\r\n
\t\tif(!col) return null;\r\n
\t\tif(col.nodeName) return col;\r\n
\r\n
\t\tif(col.length){\r\n
\t\t\tfor(var i=0; i < col.length; i++){\r\n
\t\t\t\tif(col[i].value == value)\r\n
\t\t\t\t\treturn col[i];\r\n
\t\t\t}\r\n
\t\t}\r\n
\t},\r\n
\t_get_node_value: function(els, name, multiselect){\r\n
\t\tvar col = els[name];\r\n
\t\tif(!col) return "";\r\n
\t\tif(col.length){\r\n
\t\t\tif(multiselect){\r\n
\t\t\t\tvar res = [];\r\n
\t\t\t\tfor (var i = 0; i < col.length; i++)\r\n
\t\t\t\t\tif (col[i].checked) res.push(col[i].value);\r\n
\r\n
\t\t\t\treturn res;\r\n
\t\t\t}else{\r\n
\t\t\t\tfor (var i = 0; i < col.length; i++)\r\n
\t\t\t\t\tif (col[i].checked) return col[i].value;\r\n
\t\t\t}\r\n
\t\t}\r\n
\r\n
\t\tif(col.value)\r\n
\t\t\treturn !multiselect ? col.value : [col.value];\r\n
\t},\r\n
\r\n
\t_set_node_value: function(els, name, value){\r\n
\t\tvar col = els[name];\r\n
\t\tif(!col) return;\r\n
\r\n
\t\tif(col.name == name){\r\n
\t\t\tcol.value = value;\r\n
\t\t}else if(col.length){\r\n
\t\t\tvar hash_value = typeof value == "object";\r\n
\t\t\tfor (var i = 0; i < col.length; i++)\r\n
\t\t\t\tif (hash_value || col[i].value == value){\r\n
\t\t\t\t\tcol[i].checked = hash_value ? !!value[col[i].value] : !!value;\r\n
\t\t\t\t}\r\n
\t\t}\r\n
\t},\r\n
\r\n
\t_init_set_value:function(node, value, ev) {\r\n
\t\tvar block = scheduler.form_blocks["recurring"];\r\n
\t\tvar get_value = block._get_node_value;\r\n
\t\tvar set_value = block._set_node_value;\r\n
\t\tscheduler.form_blocks["recurring"]._ds = {start:ev.start_date, end:ev._end_date};\r\n
\r\n
\t\tvar str_date_format = scheduler.date.str_to_date(scheduler.config.repeat_date);\r\n
\t\tvar str_date = function(str_date) {\r\n
\t\t\tvar date = str_date_format(str_date);\r\n
\t\t\tif (scheduler.config.include_end_by)\r\n
\t\t\t\tdate = scheduler.date.add(date, 1, \'day\');\r\n
\t\t\treturn date;\r\n
\t\t};\r\n
\r\n
\t\tvar date_str = scheduler.date.date_to_str(scheduler.config.repeat_date);\r\n
\r\n
\t\tvar top = node.getElementsByTagName("FORM")[0];\r\n
\t\tvar els = {};\r\n
\r\n
\t\tfunction register_els(inps) {\r\n
\t\t\tfor (var i = 0; i < inps.length; i++) {\r\n
\t\t\t\tvar inp = inps[i];\r\n
\r\n
\t\t\t\tif(inp.name){\r\n
\t\t\t\t\tif(!els[inp.name]){\r\n
\t\t\t\t\t\tels[inp.name] = inp;\r\n
\t\t\t\t\t}else if(els[inp.name].nodeType){\r\n
\t\t\t\t\t\tvar node = els[inp.name];\r\n
\t\t\t\t\t\tels[inp.name] = [node, inp];\r\n
\r\n
\t\t\t\t\t}else{\r\n
\t\t\t\t\t\tels[inp.name].push(inp);\r\n
\t\t\t\t\t}\r\n
\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\t\t}\r\n
\r\n
\t\tregister_els(top.getElementsByTagName("INPUT"));\r\n
\t\tregister_els(top.getElementsByTagName("SELECT"));\r\n
\r\n
\t\tif (!scheduler.config.repeat_date_of_end) {\r\n
\t\t\tvar formatter = scheduler.date.date_to_str(scheduler.config.repeat_date);\r\n
\t\t\tscheduler.config.repeat_date_of_end = formatter(scheduler.date.add(scheduler._currentDate(), 30, "day"));\r\n
\t\t}\r\n
\t\tset_value(els, "date_of_end", scheduler.config.repeat_date_of_end);\r\n
\r\n
\t\tvar $ = function(a) {\r\n
\t\t\treturn document.getElementById(a) || { style:{} };//return fake object if node not found\r\n
\t\t};\r\n
\r\n
\t\tfunction change_current_view() {\r\n
\t\t\t$("dhx_repeat_day").style.display = "none";\r\n
\t\t\t$("dhx_repeat_week").style.display = "none";\r\n
\t\t\t$("dhx_repeat_month").style.display = "none";\r\n
\t\t\t$("dhx_repeat_year").style.display = "none";\r\n
\t\t\t$("dhx_repeat_" + this.value).style.display = "block";\r\n
\t\t\tscheduler.setLightboxSize();\r\n
\t\t}\r\n
\r\n
\t\tfunction get_repeat_code(dates) {\r\n
\t\t\tvar code = [get_value(els, "repeat")];\r\n
\t\t\tget_rcode[code[0]](code, dates);\r\n
\r\n
\t\t\twhile (code.length < 5) code.push("");\r\n
\t\t\tvar repeat = "";\r\n
\r\n
\t\t\tvar end = get_end_rule(els);\r\n
\r\n
\t\t\tif (end == "no") {\r\n
\t\t\t\tdates.end = new Date(9999, 1, 1);\r\n
\t\t\t\trepeat = "no";\r\n
\t\t\t}\r\n
\t\t\telse if (end == "date_of_end") {\r\n
\t\t\t\tdates.end = str_date(get_value(els, "date_of_end"));\r\n
\t\t\t}\r\n
\t\t\telse {\r\n
\t\t\t\tscheduler.transpose_type(code.join("_"));\r\n
\t\t\t\trepeat = Math.max(1, get_value(els, "occurences_count"));\r\n
\r\n
\t\t\t\tvar transp = 0;\r\n
\r\n
\t\t\t\t//var transp = ((code[0] == "week" && code[4] && code[4].toString().indexOf(scheduler.config.start_on_monday ? 1 : 0) == -1) ? 1 : 0);\r\n
\r\n
\t\t\t\t// which is equal to following code, seems to produce extra instance, not clear why needed\r\n
\r\n
\t\t\t\t/*if(code[0] == "week"){\r\n
\t\t\t\t\tvar days = code[4] || "";\r\n
\t\t\t\t\tif(scheduler.config.start_on_monday){\r\n
\t\t\t\t\t\tif(days.indexOf(1) == -1)\r\n
\t\t\t\t\t\ttransp = 1;\r\n
\t\t\t\t\t}else{\r\n
\t\t\t\t\t\tif(days.indexOf(0) == -1)\r\n
\t\t\t\t\t\ttransp = 1;\r\n
\t\t\t\t\t}\r\n
\t\t\t\t}*/\r\n
\r\n
\t\t\t\tdates.end = scheduler.date.add(new Date(dates.start), repeat + transp, code.join("_"));\r\n
\t\t\t}\r\n
\r\n
\t\t\treturn code.join("_") + "#" + repeat;\r\n
\t\t}\r\n
\t\tfunction get_end_rule(els){\r\n
\t\t\tvar end = els["end"];\r\n
\t\t\tif(end.length){\r\n
\t\t\t\tfor(var i =0; i < end.length; i++){\r\n
\t\t\t\t\tif(end[i].checked){\r\n
\t\t\t\t\t\tif(end[i].value && end[i].value != "on"){//seems to be default value:var input = document.createElement("input"); input.type = "radio"; input.value\r\n
\t\t\t\t\t\t\treturn end[i].value;\r\n
\t\t\t\t\t\t}else{\r\n
\t\t\t\t\t\t\tif(!i){\r\n
\t\t\t\t\t\t\t\treturn "no";\r\n
\t\t\t\t\t\t\t}else if(i == 2){\r\n
\t\t\t\t\t\t\t\treturn "date_of_end";\r\n
\t\t\t\t\t\t\t}else{\r\n
\t\t\t\t\t\t\t\treturn "occurences_count";\r\n
\t\t\t\t\t\t\t}\r\n
\t\t\t\t\t\t}\r\n
\t\t\t\t\t}\r\n
\t\t\t\t}\r\n
\t\t\t}else{\r\n
\t\t\t\tif(end.value)\r\n
\t\t\t\t\treturn end.value;\r\n
\t\t\t}\r\n
\t\t\treturn "no";\r\n
\t\t}\r\n
\t\tfunction set_end_rule(els, value){\r\n
\t\t\tvar end = els["end"];\r\n
\r\n
\t\t\tif(end.length){\r\n
\t\t\t\tvar has_values = !!end[0].value && end[0].value != "on";\r\n
\t\t\t\tif(has_values){\r\n
\t\t\t\t\tfor(var i =0; i < end.length; i++){\r\n
\t\t\t\t\t\tif(end[i].value == value)\r\n
\t\t\t\t\t\t\tend[i].checked = true;\r\n
\t\t\t\t\t}\r\n
\t\t\t\t}else{\r\n
\t\t\t\t\tvar ind = 0;\r\n
\t\t\t\t\tswitch(value){\r\n
\t\t\t\t\t\tcase "no":\r\n
\t\t\t\t\t\t\tind = 0;\r\n
\t\t\t\t\t\t\tbreak;\r\n
\t\t\t\t\t\tcase "date_of_end":\r\n
\t\t\t\t\t\t\tind = 2;\r\n
\t\t\t\t\t\t\tbreak;\r\n
\t\t\t\t\t\tdefault:\r\n
\t\t\t\t\t\t\tind = 1;\r\n
\t\t\t\t\t\t\tbreak;\r\n
\t\t\t\t\t}\r\n
\t\t\t\t\tend[ind].checked = true;\r\n
\t\t\t\t}\r\n
\t\t\t}else{\r\n
\t\t\t\tend.value = value;\r\n
\t\t\t}\r\n
\t\t}\r\n
\r\n
\r\n
\t\tscheduler.form_blocks["recurring"]._get_repeat_code = get_repeat_code;\r\n
\t\tvar get_rcode = {\r\n
\t\t\tmonth:function(code, dates) {\r\n
\t\t\t\tvar get_value = scheduler.form_blocks["recurring"]._get_node_value;\r\n
\t\t\t\tif (get_value(els, "month_type") == "d") {\r\n
\t\t\t\t\tcode.push(Math.max(1, get_value(els, "month_count")));\r\n
\t\t\t\t\tdates.start.setDate(get_value(els, "month_day"));\r\n
\t\t\t\t} else {\r\n
\t\t\t\t\tcode.push(Math.max(1, get_value(els, "month_count2")));\r\n
\t\t\t\t\tcode.push( get_value(els, "month_day2"));\r\n
\t\t\t\t\tcode.push(Math.max(1, get_value(els, "month_week2")));\r\n
\t\t\t\t\tif (!scheduler.config.repeat_precise){\r\n
\t\t\t\t\t\tdates.start.setDate(1);\r\n
\t\t\t\t\t}\r\n
\t\t\t\t}\r\n
\t\t\t\tdates._start = true;\r\n
\t\t\t},\r\n
\t\t\tweek:function(code, dates) {\r\n
\t\t\t\tvar get_value = scheduler.form_blocks["recurring"]._get_node_value;\r\n
\r\n
\t\t\t\tcode.push(Math.max(1, get_value(els, "week_count")));\r\n
\t\t\t\tcode.push("");\r\n
\t\t\t\tcode.push("");\r\n
\t\t\t\tvar t = [];\r\n
\r\n
\t\t\t\tvar col = get_value(els, "week_day", true);\r\n
\t\t\t\t//var col = els["week_day"];\r\n
\t\t\t\tvar day = dates.start.getDay();\r\n
\t\t\t\tvar start_exists = false;\r\n
\r\n
\t\t\t\tfor (var i = 0; i < col.length; i++){\r\n
\t\t\t\t\tt.push(col[i]);\r\n
\t\t\t\t\tstart_exists = start_exists || col[i] == day;\r\n
\t\t\t\t}\r\n
\t\t\t\tif (!t.length){\r\n
\t\t\t\t\tt.push(day);\r\n
\t\t\t\t\tstart_exists = true;\r\n
\t\t\t\t}\r\n
\t\t\t\tt.sort();\r\n
\r\n
\r\n
\t\t\t\tif (!scheduler.config.repeat_precise){\r\n
\t\t\t\t\tdates.start = scheduler.date.week_start(dates.start);\r\n
\t\t\t\t\tdates._start = true;\r\n
\t\t\t\t} else if (!start_exists){\r\n
\t\t\t\t\tscheduler.transpose_day_week(dates.start, t, 1, 7);\r\n
\t\t\t\t\tdates._start = true;\r\n
\t\t\t\t}\r\n
\r\n
\t\t\t\tcode.push(t.join(","));\r\n
\t\t\t},\r\n
\t\t\tday:function(code) {\r\n
\t\t\t\tvar get_value = scheduler.form_blocks["recurring"]._get_node_value;\r\n
\r\n
\t\t\t\tif (get_value(els, "day_type") == "d") {\r\n
\t\t\t\t\tcode.push(Math.max(1, get_value(els, "day_count")));\r\n
\t\t\t\t}\r\n
\t\t\t\telse {\r\n
\t\t\t\t\tcode.push("week");\r\n
\t\t\t\t\tcode.push(1);\r\n
\t\t\t\t\tcode.push("");\r\n
\t\t\t\t\tcode.push("");\r\n
\t\t\t\t\tcode.push(scheduler.config.recurring_workdays.join(","));\r\n
\t\t\t\t\tcode.splice(0, 1);\r\n
\t\t\t\t}\r\n
\t\t\t},\r\n
\t\t\tyear:function(code, dates) {\r\n
\t\t\t\tvar get_value = scheduler.form_blocks["recurring"]._get_node_value;\r\n
\r\n
\t\t\t\tif (get_value(els, "year_type") == "d") {\r\n
\t\t\t\t\tcode.push("1");\r\n
\t\t\t\t\tdates.start.setMonth(0);\r\n
\t\t\t\t\tdates.start.setDate(get_value(els, "year_day"));\r\n
\t\t\t\t\tdates.start.setMonth(get_value(els, "year_month"));\r\n
\r\n
\t\t\t\t} else {\r\n
\t\t\t\t\tcode.push("1");\r\n
\t\t\t\t\tcode.push(get_value(els, "year_day2"));\r\n
\t\t\t\t\tcode.push(get_value(els, "year_week2"));\r\n
\t\t\t\t\tdates.start.setDate(1);\r\n
\t\t\t\t\tdates.start.setMonth(get_value(els, "year_month2"));\r\n
\t\t\t\t}\r\n
\t\t\t\tdates._start = true;\r\n
\t\t\t}\r\n
\t\t};\r\n
\t\tvar set_rcode = {\r\n
\t\t\tweek:function(code, dates) {\r\n
\t\t\t\tvar set_value = scheduler.form_blocks["recurring"]._set_node_value;\r\n
\t\t\t\tset_value(els, "week_count", code[1]);\r\n
\r\n
\t\t\t\tvar t = code[4].split(",");\r\n
\t\t\t\tvar d = {};\r\n
\t\t\t\tfor (var i = 0; i < t.length; i++) d[t[i]] = true;\r\n
\r\n
\t\t\t\tset_value(els, "week_day", d);\r\n
\r\n
\t\t\t\t//for (var i = 0; i < col.length; i++)\r\n
\t\t\t\t//\tcol[i].checked = (!!d[col[i].value]);\r\n
\t\t\t},\r\n
\t\t\tmonth:function(code, dates) {\r\n
\t\t\t\tvar set_value = scheduler.form_blocks["recurring"]._set_node_value;\r\n
\r\n
\t\t\t\tif (code[2] === "") {\r\n
\t\t\t\t\tset_value(els, "month_type", "d");\r\n
\t\t\t\t\tset_value(els, "month_count", code[1]);\r\n
\t\t\t\t\tset_value(els, "month_day", dates.start.getDate());\r\n
\t\t\t\t} else {\r\n
\t\t\t\t\tset_value(els, "month_type", "w");\r\n
\t\t\t\t\tset_value(els, "month_count2", code[1]);\r\n
\t\t\t\t\tset_value(els, "month_week2",  code[3]);\r\n
\t\t\t\t\tset_value(els, "month_day2", code[2]);\r\n
\t\t\t\t}\r\n
\t\t\t},\r\n
\t\t\tday:function(code, dates) {\r\n
\t\t\t\tvar set_value = scheduler.form_blocks["recurring"]._set_node_value;\r\n
\t\t\t\tset_value(els, "day_type", "d");\r\n
\t\t\t\tset_value(els, "day_count", code[1]);\r\n
\t\t\t},\r\n
\t\t\tyear:function(code, dates) {\r\n
\t\t\t\tvar set_value = scheduler.form_blocks["recurring"]._set_node_value;\r\n
\r\n
\t\t\t\tif (code[2] === "") {\r\n
\t\t\t\t\tset_value(els, "year_type", "d");\r\n
\t\t\t\t\tset_value(els, "year_day", dates.start.getDate());\r\n
\t\t\t\t\tset_value(els, "year_month", dates.start.getMonth());\r\n
\r\n
\t\t\t\t} else {\r\n
\t\t\t\t\tset_value(els, "year_type", "w");\r\n
\t\t\t\t\tset_value(els, "year_week2", code[3]);\r\n
\t\t\t\t\tset_value(els, "year_day2", code[2]);\r\n
\t\t\t\t\tset_value(els, "year_month2", dates.start.getMonth());\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\t\t};\r\n
\r\n
\t\tfunction set_repeat_code(code, dates) {\r\n
\t\t\tvar set_value = scheduler.form_blocks["recurring"]._set_node_value;\r\n
\t\t\tvar data = code.split("#");\r\n
\t\t\tcode = data[0].split("_");\r\n
\t\t\tset_rcode[code[0]](code, dates);\r\n
\r\n
\r\n
\t\t\tswitch (data[1]) {\r\n
\t\t\t\tcase "no":\r\n
\t\t\t\t\tset_end_rule(els, "no");\r\n
\t\t\t\t\tbreak;\r\n
\t\t\t\tcase "":\r\n
\t\t\t\t\tset_end_rule(els, "date_of_end");\r\n
\r\n
\t\t\t\t\tvar end_date = dates.end;\r\n
\t\t\t\t\tif (scheduler.config.include_end_by){\r\n
\t\t\t\t\t\tend_date = scheduler.date.add(end_date, -1, \'day\');\r\n
\t\t\t\t\t}\r\n
\t\t\t\t\tset_value(els, "date_of_end", date_str(end_date));\r\n
\r\n
\t\t\t\t\tbreak;\r\n
\t\t\t\tdefault:\r\n
\t\t\t\t\tset_end_rule(els, "occurences_count");\r\n
\t\t\t\t\tset_value(els, "occurences_count", data[1]);\r\n
\r\n
\t\t\t\t\tbreak;\r\n
\t\t\t}\r\n
\r\n
\t\t\tset_value(els, "repeat", code[0]);\r\n
\t\t\t//e.checked = true;\r\n
\r\n
\t\t\tvar node = scheduler.form_blocks["recurring"]._get_form_node(els, "repeat", code[0]);\r\n
\t\t\tif(node.nodeName == "SELECT" && node.onchange){\r\n
\t\t\t\tnode.onchange();\r\n
\t\t\t}else if(node.onclick){\r\n
\t\t\t\tnode.onclick();\r\n
\t\t\t}\r\n
\t\t}\r\n
\t\tfunction activate(els, mode){\r\n
\r\n
\t\t}\r\n
\t\tscheduler.form_blocks["recurring"]._set_repeat_code = set_repeat_code;\r\n
\r\n
\t\tfor (var i = 0; i < top.elements.length; i++) {\r\n
\t\t\tvar el = top.elements[i];\r\n
\t\t\tswitch (el.name) {\r\n
\t\t\t\tcase "repeat":\r\n
\t\t\t\t\tif(el.nodeName == "SELECT"){\r\n
\t\t\t\t\t\tel.onchange = change_current_view;\r\n
\t\t\t\t\t}else{\r\n
\t\t\t\t\t\tel.onclick = change_current_view;\r\n
\t\t\t\t\t}\r\n
\r\n
\r\n
\t\t\t\t\tbreak;\r\n
\t\t\t}\r\n
\t\t}\r\n
\t\tscheduler._lightbox._rec_init_done = true;\r\n
\t},\r\n
\tset_value:function(node, value, ev) {\r\n
\t\tvar rf = scheduler.form_blocks["recurring"];\r\n
\t\tif (!scheduler._lightbox._rec_init_done)\r\n
\t\t\trf._init_set_value(node, value, ev);\r\n
\t\tnode.open = !ev.rec_type;\r\n
\t\tif (this._is_modified_occurence(ev))\r\n
\t\t\tnode.blocked = true;\r\n
\t\telse node.blocked = false;\r\n
\r\n
\t\tvar ds = rf._ds;\r\n
\t\tds.start = ev.start_date;\r\n
\t\tds.end = ev._end_date;\r\n
\r\n
\t\trf.button_click(0, node.previousSibling.firstChild.firstChild, node, node);\r\n
\t\tif (value)\r\n
\t\t\trf._set_repeat_code(value, ds);\r\n
\t},\r\n
\tget_value:function(node, ev) {\r\n
\t\tif (node.open) {\r\n
\t\t\tvar ds = scheduler.form_blocks["recurring"]._ds;\r\n
\t\t\tvar actual_dates = {};\r\n
\t\t\tthis.formSection(\'time\').getValue(actual_dates);\r\n
\t\t\tds.start = actual_dates.start_date;\r\n
\t\t\tev.rec_type = scheduler.form_blocks["recurring"]._get_repeat_code(ds);\r\n
\t\t\tif (ds._start) {\r\n
\t\t\t\tev.start_date = new Date(ds.start);\r\n
\t\t\t\tev._start_date = new Date(ds.start);\r\n
\t\t\t\tds._start = false;\r\n
\t\t\t} else\r\n
\t\t\t\tev._start_date = null;\r\n
\r\n
\t\t\tev._end_date = ds.end;\r\n
\t\t\tev.rec_pattern = ev.rec_type.split("#")[0];\r\n
\t\t} else {\r\n
\t\t\tev.rec_type = ev.rec_pattern = "";\r\n
\t\t\tev._end_date = ev.end_date;\r\n
\t\t}\r\n
\t\treturn ev.rec_type;\r\n
\t},\r\n
\t_get_button: function(){\r\n
\t\tvar node = scheduler.formSection("recurring").header;\r\n
\t\treturn node.firstChild.firstChild;\r\n
\t},\r\n
\t_get_form: function(){\r\n
\t\treturn scheduler.formSection("recurring").node;\r\n
\t},\r\n
\topen:function(){\r\n
\t\tvar block = scheduler.form_blocks.recurring;\r\n
\r\n
\t\tvar cont = block._get_form();\r\n
\t\tif(!cont.open)\r\n
\t\t\tblock._toggle_block();\r\n
\t},\r\n
\tclose: function(){\r\n
\t\tvar block = scheduler.form_blocks.recurring;\r\n
\r\n
\t\tvar cont = block._get_form();\r\n
\r\n
\t\tif(cont.open)\r\n
\t\t\tblock._toggle_block();\r\n
\t},\r\n
\t_toggle_block: function(){\r\n
\t\tvar block = scheduler.form_blocks.recurring;\r\n
\r\n
\t\tvar cont = block._get_form(),\r\n
\t\t\tel = block._get_button();\r\n
\t\tif (!cont.open && !cont.blocked) {\r\n
\t\t\tcont.style.height = "auto";//reset to default value\r\n
\t\t\tif(el){\r\n
\t\t\t\tel.style.backgroundPosition = "-5px 0px";\r\n
\t\t\t\tel.nextSibling.innerHTML = scheduler.locale.labels.button_recurring_open;\r\n
\t\t\t}\r\n
\t\t} else {\r\n
\t\t\tcont.style.height = "0px";\r\n
\t\t\tif(el){\r\n
\t\t\t\tel.style.backgroundPosition = "-5px 20px";\r\n
\t\t\t\tel.nextSibling.innerHTML = scheduler.locale.labels.button_recurring;\r\n
\t\t\t}\r\n
\t\t}\r\n
\t\tcont.open = !cont.open;\r\n
\r\n
\t\tscheduler.setLightboxSize();\r\n
\t},\r\n
\tfocus:function(node) {\r\n
\t},\r\n
\tbutton_click:function(index, el, section, cont) {\r\n
\t\tscheduler.form_blocks.recurring._toggle_block();\r\n
\t}\r\n
};\r\n
\r\n
\r\n
//problem may occur if we will have two repeating events in the same moment of time\r\n
scheduler._rec_markers = {};\r\n
scheduler._rec_markers_pull = {};\r\n
scheduler._add_rec_marker = function(ev, time) {\r\n
\tev._pid_time = time;\r\n
\tthis._rec_markers[ev.id] = ev;\r\n
\tif (!this._rec_markers_pull[ev.event_pid]) this._rec_markers_pull[ev.event_pid] = {};\r\n
\tthis._rec_markers_pull[ev.event_pid][time] = ev;\r\n
};\r\n
scheduler._get_rec_marker = function(time, id) {\r\n
\tvar ch = this._rec_markers_pull[id];\r\n
\tif (ch) return ch[time];\r\n
\treturn null;\r\n
};\r\n
scheduler._get_rec_markers = function(id) {\r\n
\treturn (this._rec_markers_pull[id] || []);\r\n
};\r\n
scheduler._rec_temp = [];\r\n
(function() {\r\n
\tvar old_add_event = scheduler.addEvent;\r\n
\tscheduler.addEvent = function(start_date, end_date, text, id, extra_data) {\r\n
\t\tvar ev_id = old_add_event.apply(this, arguments);\r\n
\r\n
\t\tif (ev_id) {\r\n
\t\t\tvar ev = scheduler.getEvent(ev_id);\r\n
\t\t\tif (this._is_modified_occurence(ev))\r\n
\t\t\t\tscheduler._add_rec_marker(ev, ev.event_length * 1000);\r\n
\t\t\tif (ev.rec_type)\r\n
\t\t\t\tev.rec_pattern = ev.rec_type.split("#")[0];\r\n
\t\t}\r\n
\t\treturn ev_id;\r\n
\t};\r\n
})();\r\n
scheduler.attachEvent("onEventIdChange", function(id, new_id) {\r\n
\tif (this._ignore_call) return;\r\n
\tthis._ignore_call = true;\r\n
\r\n
\tif(scheduler._rec_markers[id]){\r\n
\t\t//important for for correct work of scheduler.getEvents(from, to) and collision detection\r\n
\t\tscheduler._rec_markers[new_id] = scheduler._rec_markers[id];\r\n
\t\tdelete scheduler._rec_markers[id];\r\n
\t}\r\n
\r\n
\tfor (var i = 0; i < this._rec_temp.length; i++) {\r\n
\t\tvar tev = this._rec_temp[i];\r\n
\t\tif (tev.event_pid == id) {\r\n
\t\t\ttev.event_pid = new_id;\r\n
\t\t\tthis.changeEventId(tev.id, new_id + "#" + tev.id.split("#")[1]);\r\n
\t\t}\r\n
\t}\r\n
\r\n
\tdelete this._ignore_call;\r\n
});\r\n
scheduler.attachEvent("onConfirmedBeforeEventDelete", function(id) {\r\n
\tvar ev = this.getEvent(id);\r\n
\tif (this._is_virtual_event(id) || (this._is_modified_occurence(ev) && ev.rec_type && ev.rec_type != \'none\')) {\r\n
\t\tid = id.split("#");\r\n
\t\tvar nid = this.uid();\r\n
\t\tvar tid = (id[1]) ? id[1] : (ev._pid_time / 1000);\r\n
\r\n
\t\tvar nev = this._copy_event(ev);\r\n
\t\tnev.id = nid;\r\n
\t\tnev.event_pid = ev.event_pid || id[0];\r\n
\t\tvar timestamp = tid;\r\n
\t\tnev.event_length = timestamp;\r\n
\t\tnev.rec_type = nev.rec_pattern = "none";\r\n
\t\tthis.addEvent(nev);\r\n
\r\n
\t\tthis._add_rec_marker(nev, timestamp * 1000);\r\n
\t} else {\r\n
\t\tif (ev.rec_type && this._lightbox_id)\r\n
\t\t\tthis._roll_back_dates(ev);\r\n
\t\tvar sub = this._get_rec_markers(id);\r\n
\t\tfor (var i in sub) {\r\n
\t\t\tif (sub.hasOwnProperty(i)) {\r\n
\t\t\t\tid = sub[i].id;\r\n
\t\t\t\tif (this.getEvent(id))\r\n
\t\t\t\t\tthis.deleteEvent(id, true);\r\n
\t\t\t}\r\n
\t\t}\r\n
\t}\r\n
\treturn true;\r\n
});\r\n
scheduler.attachEvent("onEventDeleted", function(id, ev){\r\n
\tif(!this._is_virtual_event(id) && this._is_modified_occurence(ev)){\r\n
\t\tif(!scheduler._events[id]){\r\n
\t\t\tev.rec_type = ev.rec_pattern = "none";\r\n
\t\t\tthis.setEvent(id, ev);\r\n
\t\t}\r\n
\t}\r\n
});\r\n
scheduler.attachEvent("onEventChanged", function(id) {\r\n
\tif (this._loading) return true;\r\n
\r\n
\tvar ev = this.getEvent(id);\r\n
\r\n
\tif (this._is_virtual_event(id)) {\r\n
\t\tvar id = id.split("#");\r\n
\t\tvar nid = this.uid();\r\n
\t\tthis._not_render = true;\r\n
\r\n
\t\tvar nev = this._copy_event(ev);\r\n
\t\tnev.id = nid;\r\n
\t\tnev.event_pid = id[0];\r\n
\t\tvar timestamp = id[1];\r\n
\t\tnev.event_length = timestamp;\r\n
\t\tnev.rec_type = nev.rec_pattern = "";\r\n
\r\n
\t\tthis._add_rec_marker(nev, timestamp * 1000);\r\n
\t\tthis.addEvent(nev);\r\n
\r\n
\t\tthis._not_render = false;\r\n
\r\n
\t} else {\r\n
\t\tif (ev.rec_type && this._lightbox_id)\r\n
\t\t\tthis._roll_back_dates(ev);\r\n
\t\tvar sub = this._get_rec_markers(id);\r\n
\t\tfor (var i in sub) {\r\n
\t\t\tif (sub.hasOwnProperty(i)) {\r\n
\t\t\t\tdelete this._rec_markers[sub[i].id];\r\n
\t\t\t\tthis.deleteEvent(sub[i].id, true);\r\n
\t\t\t}\r\n
\t\t}\r\n
\t\tdelete this._rec_markers_pull[id];\r\n
\r\n
\t\t// it\'s possible that after editing event is no longer exists, in such case we need to remove _select_id flag\r\n
\t\tvar isEventFound = false;\r\n
\t\tfor (var k = 0; k < this._rendered.length; k++) {\r\n
\t\t\tif (this._rendered[k].getAttribute(\'event_id\') == id)\r\n
\t\t\t\tisEventFound = true;\r\n
\t\t}\r\n
\t\tif (!isEventFound)\r\n
\t\t\tthis._select_id = null;\r\n
\t}\r\n
\treturn true;\r\n
});\r\n
scheduler.attachEvent("onEventAdded", function(id) {\r\n
\tif (!this._loading) {\r\n
\t\tvar ev = this.getEvent(id);\r\n
\t\tif (ev.rec_type && !ev.event_length)\r\n
\t\t\tthis._roll_back_dates(ev);\r\n
\t}\r\n
\treturn true;\r\n
});\r\n
scheduler.attachEvent("onEventSave", function(id, data, is_new_event) {\r\n
\tvar ev = this.getEvent(id);\r\n
\tif (!ev.rec_type && data.rec_type && !this._is_virtual_event(id))\r\n
\t\tthis._select_id = null;\r\n
\treturn true;\r\n
});\r\n
scheduler.attachEvent("onEventCreated", function(id) {\r\n
\tvar ev = this.getEvent(id);\r\n
\tif (!ev.rec_type)\r\n
\t\tev.rec_type = ev.rec_pattern = ev.event_length = ev.event_pid = "";\r\n
\treturn true;\r\n
});\r\n
scheduler.attachEvent("onEventCancel", function(id) {\r\n
\tvar ev = this.getEvent(id);\r\n
\tif (ev.rec_type) {\r\n
\t\tthis._roll_back_dates(ev);\r\n
\t\t// a bit expensive, but we need to be sure that event re-rendered, because view can be corrupted by resize , during edit process\r\n
\t\tthis.render_view_data();\r\n
\t}\r\n
});\r\n
scheduler._roll_back_dates = function(ev) {\r\n
\tev.event_length = (ev.end_date.valueOf() - ev.start_date.valueOf()) / 1000;\r\n
\tev.end_date = ev._end_date;\r\n
\tif (ev._start_date) {\r\n
\t\tev.start_date.setMonth(0);\r\n
\t\tev.start_date.setDate(ev._start_date.getDate());\r\n
\t\tev.start_date.setMonth(ev._start_date.getMonth());\r\n
\t\tev.start_date.setFullYear(ev._start_date.getFullYear());\r\n
\r\n
\t}\r\n
};\r\n
\r\n
scheduler._is_virtual_event = function(id){\r\n
\treturn id.toString().indexOf("#") != -1;\r\n
};\r\n
scheduler._is_modified_occurence = function(ev){\r\n
\treturn (ev.event_pid && ev.event_pid != "0");\r\n
};\r\n
\r\n
scheduler._validId = function(id) {\r\n
\treturn !this._is_virtual_event(id);\r\n
};\r\n
\r\n
scheduler.showLightbox_rec = scheduler.showLightbox;\r\n
scheduler.showLightbox = function(id) {\r\n
\tvar locale = this.locale;\r\n
\tvar c = scheduler.config.lightbox_recurring;\r\n
\tvar ev = this.getEvent(id);\r\n
\tvar pid = ev.event_pid;\r\n
\tvar isVirtual = this._is_virtual_event(id);\r\n
\tif (isVirtual)\r\n
\t\tpid = id.split("#")[0];\r\n
\r\n
\t// show series\r\n
\tvar showSeries = function(id) {\r\n
\t\tvar event = scheduler.getEvent(id);\r\n
\t\tevent._end_date = event.end_date;\r\n
\t\tevent.end_date = new Date(event.start_date.valueOf() + event.event_length * 1000);\r\n
\t\treturn scheduler.showLightbox_rec(id); // editing series\r\n
\t};\r\n
\r\n
\tif ( (pid || pid*1 === 0) && ev.rec_type) {\r\n
\t\t// direct API call on series id\r\n
\t\treturn showSeries(id);\r\n
\t}\r\n
\tif ( !pid || pid === \'0\' || ( (!locale.labels.confirm_recurring || c == \'instance\') || (c == \'series\' && !isVirtual)) ) {\r\n
\t\t// editing instance or non recurring event\r\n
\t\treturn this.showLightbox_rec(id);\r\n
\t}\r\n
\tif (c == \'ask\') {\r\n
\t\tvar that = this;\r\n
\t\tdhtmlx.modalbox({\r\n
\t\t\ttext: locale.labels.confirm_recurring,\r\n
\t\t\ttitle: locale.labels.title_confirm_recurring,\r\n
\t\t\twidth: "500px",\r\n
\t\t\tposition: "middle",\r\n
\t\t\tbuttons:[locale.labels.button_edit_series, locale.labels.button_edit_occurrence, locale.labels.icon_cancel],\r\n
\t\t\tcallback: function(index) {\r\n
\t\t\t\tswitch(+index) {\r\n
\t\t\t\t\tcase 0:\r\n
\t\t\t\t\t\treturn showSeries(pid);\r\n
\t\t\t\t\tcase 1:\r\n
\t\t\t\t\t\treturn that.showLightbox_rec(id);\r\n
\t\t\t\t\tcase 2:\r\n
\t\t\t\t\t\treturn;\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\t\t});\r\n
\t} else {\r\n
\t\tshowSeries(pid);\r\n
\t}\r\n
};\r\n
\r\n
\r\n
scheduler.get_visible_events_rec = scheduler.get_visible_events;\r\n
scheduler.get_visible_events = function(only_timed) {\r\n
\tfor (var i = 0; i < this._rec_temp.length; i++)\r\n
\t\tdelete this._events[this._rec_temp[i].id];\r\n
\tthis._rec_temp = [];\r\n
\r\n
\tvar stack = this.get_visible_events_rec(only_timed);\r\n
\tvar out = [];\r\n
\tfor (var i = 0; i < stack.length; i++) {\r\n
\t\tif (stack[i].rec_type) {\r\n
\t\t\t//deleted element of serie\r\n
\t\t\tif (stack[i].rec_pattern != "none")\r\n
\t\t\t\tthis.repeat_date(stack[i], out);\r\n
\t\t}\r\n
\t\telse out.push(stack[i]);\r\n
\t}\r\n
\treturn out;\r\n
};\r\n
\r\n
\r\n
(function() {\r\n
\tvar old = scheduler.isOneDayEvent;\r\n
\tscheduler.isOneDayEvent = function(ev) {\r\n
\t\tif (ev.rec_type) return true;\r\n
\t\treturn old.call(this, ev);\r\n
\t};\r\n
\tvar old_update_event = scheduler.updateEvent;\r\n
\tscheduler.updateEvent = function(id) {\r\n
\t\tvar ev = scheduler.getEvent(id);\r\n
\t\tif(ev && ev.rec_type){\r\n
\t\t\t//rec_type can be changed without the lightbox,\r\n
\t\t\t// make sure rec_pattern updated as well\r\n
\t\t\tev.rec_pattern = (ev.rec_type || "").split("#")[0];\r\n
\t\t}\r\n
\t\tif (ev && ev.rec_type && !this._is_virtual_event(id)) {\r\n
\t\t\tscheduler.update_view();\r\n
\t\t} else {\r\n
\t\t\told_update_event.call(this, id);\r\n
\t\t}\r\n
\t};\r\n
})();\r\n
\r\n
scheduler.transponse_size = {\r\n
\tday:1, week:7, month:1, year:12\r\n
};\r\n
scheduler.date.day_week = function(sd, day, week) {\r\n
\tsd.setDate(1);\r\n
\tweek = (week - 1) * 7;\r\n
\tvar cday = sd.getDay();\r\n
\tvar nday = day * 1 + week - cday + 1;\r\n
\tsd.setDate(nday <= week ? (nday + 7) : nday);\r\n
};\r\n
scheduler.transpose_day_week = function(sd, list, cor, size, cor2) {\r\n
\tvar cday = (sd.getDay() || (scheduler.config.start_on_monday ? 7 : 0)) - cor;\r\n
\tfor (var i = 0; i < list.length; i++) {\r\n
\t\tif (list[i] > cday)\r\n
\t\t\treturn sd.setDate(sd.getDate() + list[i] * 1 - cday - (size ? cor : cor2));\r\n
\t}\r\n
\tthis.transpose_day_week(sd, list, cor + size, null, cor);\r\n
};\r\n
scheduler.transpose_type = function(type) {\r\n
\tvar f = "transpose_" + type;\r\n
\tif (!this.date[f]) {\r\n
\t\tvar str = type.split("_");\r\n
\t\tvar day = 60 * 60 * 24 * 1000;\r\n
\t\tvar gf = "add_" + type;\r\n
\t\tvar step = this.transponse_size[str[0]] * str[1];\r\n
\r\n
\t\tif (str[0] == "day" || str[0] == "week") {\r\n
\t\t\tvar days = null;\r\n
\t\t\tif (str[4]) {\r\n
\t\t\t\tdays = str[4].split(",");\r\n
\t\t\t\tif (scheduler.config.start_on_monday) {\r\n
\t\t\t\t\tfor (var i = 0; i < days.length; i++)\r\n
\t\t\t\t\t\tdays[i] = (days[i] * 1) || 7;\r\n
\t\t\t\t\tdays.sort();\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\r\n
\t\t\tthis.date[f] = function(nd, td) { \r\n
\t\t\t\tvar delta = Math.floor((td.valueOf() - nd.valueOf()) / (day * step));\r\n
\t\t\t\tif (delta > 0)\r\n
\t\t\t\t\tnd.setDate(nd.getDate() + delta * step);\r\n
\t\t\t\tif (days)\r\n
\t\t\t\t\tscheduler.transpose_day_week(nd, days, 1, step);\r\n
\t\t\t};\r\n
\t\t\tthis.date[gf] = function(sd, inc) {\r\n
\t\t\t\tvar nd = new Date(sd.valueOf());\r\n
\t\t\t\tif (days) {\r\n
\t\t\t\t\tfor (var count = 0; count < inc; count++)\r\n
\t\t\t\t\t\tscheduler.transpose_day_week(nd, days, 0, step);\r\n
\t\t\t\t} else\r\n
\t\t\t\t\tnd.setDate(nd.getDate() + inc * step);\r\n
\r\n
\t\t\t\treturn nd;\r\n
\t\t\t};\r\n
\t\t}\r\n
\t\telse if (str[0] == "month" || str[0] == "year") {\r\n
\t\t\tthis.date[f] = function(nd, td) {\r\n
\t\t\t\tvar delta = Math.ceil(((td.getFullYear() * 12 + td.getMonth() * 1) - (nd.getFullYear() * 12 + nd.getMonth() * 1)) / (step));\r\n
\t\t\t\tif (delta >= 0)\r\n
\t\t\t\t\tnd.setMonth(nd.getMonth() + delta * step);\r\n
\t\t\t\tif (str[3])\r\n
\t\t\t\t\tscheduler.date.day_week(nd, str[2], str[3]);\r\n
\t\t\t};\r\n
\t\t\tthis.date[gf] = function(sd, inc) {\r\n
\t\t\t\tvar nd = new Date(sd.valueOf());\r\n
\t\t\t\tnd.setMonth(nd.getMonth() + inc * step);\r\n
\t\t\t\tif (str[3])\r\n
\t\t\t\t\tscheduler.date.day_week(nd, str[2], str[3]);\r\n
\t\t\t\treturn nd;\r\n
\t\t\t};\r\n
\t\t}\r\n
\t}\r\n
};\r\n
scheduler.repeat_date = function(ev, stack, non_render, from, to) {\r\n
\r\n
\tfrom = from || this._min_date;\r\n
\tto = to || this._max_date;\r\n
\r\n
\tvar td = new Date(ev.start_date.valueOf());\r\n
\r\n
\tif (!ev.rec_pattern && ev.rec_type)\r\n
\t\tev.rec_pattern = ev.rec_type.split("#")[0];\r\n
\r\n
\tthis.transpose_type(ev.rec_pattern);\r\n
\tscheduler.date["transpose_" + ev.rec_pattern](td, from);\r\n
\twhile (td < ev.start_date || scheduler._fix_daylight_saving_date(td,from,ev,td,new Date(td.valueOf() + ev.event_length * 1000)).valueOf() <= from.valueOf() || td.valueOf() + ev.event_length * 1000 <= from.valueOf())\r\n
\t\ttd = this.date.add(td, 1, ev.rec_pattern);\r\n
\twhile (td < to && td < ev.end_date) {\r\n
\t\tvar timestamp = (scheduler.config.occurrence_timestamp_in_utc) ? Date.UTC(td.getFullYear(), td.getMonth(), td.getDate(), td.getHours(), td.getMinutes(), td.getSeconds()) : td.valueOf();\r\n
\t\tvar ch = this._get_rec_marker(timestamp, ev.id);\r\n
\t\tif (!ch) { // unmodified element of series\r\n
\t\t\tvar ted = new Date(td.valueOf() + ev.event_length * 1000);\r\n
\t\t\tvar copy = this._copy_event(ev);\r\n
\t\t\t//copy._timed = ev._timed;\r\n
\t\t\tcopy.text = ev.text;\r\n
\t\t\tcopy.start_date = td;\r\n
\t\t\tcopy.event_pid = ev.id;\r\n
\t\t\tcopy.id = ev.id + "#" + Math.ceil(timestamp / 1000);\r\n
\t\t\tcopy.end_date = ted;\r\n
\r\n
\t\t\tcopy.end_date = scheduler._fix_daylight_saving_date(copy.start_date, copy.end_date, ev, td, copy.end_date);\r\n
\r\n
\t\t\tcopy._timed = this.isOneDayEvent(copy);\r\n
\r\n
\t\t\tif (!copy._timed && !this._table_view && !this.config.multi_day) return;\r\n
\t\t\tstack.push(copy);\r\n
\r\n
\t\t\tif (!non_render) {\r\n
\t\t\t\tthis._events[copy.id] = copy;\r\n
\t\t\t\tthis._rec_temp.push(copy);\r\n
\t\t\t}\r\n
\r\n
\t\t} else\r\n
\t\tif (non_render) stack.push(ch);\r\n
\r\n
\t\ttd = this.date.add(td, 1, ev.rec_pattern);\r\n
\t}\r\n
};\r\n
scheduler._fix_daylight_saving_date = function(start_date, end_date, ev, counter, default_date) {\r\n
\tvar shift = start_date.getTimezoneOffset() - end_date.getTimezoneOffset();\r\n
\tif (shift) {\r\n
\t\tif (shift > 0) {\r\n
\t\t\t// e.g. 24h -> 23h\r\n
\t\t\treturn new Date(counter.valueOf() + ev.event_length * 1000 - shift * 60 * 1000);\r\n
\t\t}\r\n
\t\telse {\r\n
\t\t\t// e.g. 24h -> 25h\r\n
\t\t\treturn new Date(end_date.valueOf() - shift * 60 * 1000);\r\n
\t\t}\r\n
\t}\r\n
\treturn new Date(default_date.valueOf());\r\n
};\r\n
scheduler.getRecDates = function(id, max) {\r\n
\tvar ev = typeof id == "object" ? id : scheduler.getEvent(id);\r\n
\tvar count = 0;\r\n
\tvar result = [];\r\n
\tmax = max || 100;\r\n
\r\n
\tvar td = new Date(ev.start_date.valueOf());\r\n
\tvar from = new Date(td.valueOf());\r\n
\r\n
\tif (!ev.rec_type) {\r\n
\t\treturn [\r\n
\t\t\t{ start_date: ev.start_date, end_date: ev.end_date }\r\n
\t\t];\r\n
\t}\r\n
\tif (ev.rec_type == "none") {\r\n
\t\treturn [];\r\n
\t}\r\n
\tthis.transpose_type(ev.rec_pattern);\r\n
\tscheduler.date["transpose_" + ev.rec_pattern](td, from);\r\n
\r\n
\twhile (td < ev.start_date || (td.valueOf() + ev.event_length * 1000) <= from.valueOf())\r\n
\t\ttd = this.date.add(td, 1, ev.rec_pattern);\r\n
\twhile (td < ev.end_date) {\r\n
\t\tvar ch = this._get_rec_marker(td.valueOf(), ev.id);\r\n
\t\tvar res = true;\r\n
\t\tif (!ch) { // unmodified element of series\r\n
\t\t\tvar sed = new Date(td);\r\n
\t\t\tvar ted = new Date(td.valueOf() + ev.event_length * 1000);\r\n
\r\n
\t\t\tted = scheduler._fix_daylight_saving_date(sed, ted, ev, td, ted);\r\n
\r\n
\t\t\tresult.push({start_date:sed, end_date:ted});\r\n
\t\t} else if(ch.rec_type == "none") {\r\n
\t\t\tres = false;\r\n
\t\t} else {\r\n
\t\t\tresult.push({ start_date: ch.start_date, end_date: ch.end_date });\r\n
\t\t}\r\n
\t\t\r\n
\t\ttd = this.date.add(td, 1, ev.rec_pattern);\r\n
\t\tif (res) {\r\n
\t\t\tcount++;\r\n
\t\t\tif (count == max)\r\n
\t\t\t\tbreak;\r\n
\t\t}\r\n
\t}\r\n
\treturn result;\r\n
};\r\n
scheduler.getEvents = function(from, to) {\r\n
\tvar result = [];\r\n
\tfor (var a in this._events) {\r\n
\t\tvar ev = this._events[a];\r\n
\t\tif (ev && ev.start_date < to && ev.end_date > from) {\r\n
\t\t\tif (ev.rec_pattern) {\r\n
\t\t\t\tif (ev.rec_pattern == "none") continue;\r\n
\t\t\t\tvar sev = [];\r\n
\t\t\t\tthis.repeat_date(ev, sev, true, from, to);\r\n
\t\t\t\tfor (var i = 0; i < sev.length; i++) {\r\n
\t\t\t\t\t// if event is in rec_markers then it will be checked by himself, here need to skip it\r\n
\t\t\t\t\tif (!sev[i].rec_pattern && sev[i].start_date < to && sev[i].end_date > from && !this._rec_markers[sev[i].id]) {\r\n
\t\t\t\t\t\tresult.push(sev[i]);\r\n
\t\t\t\t\t}\r\n
\t\t\t\t}\r\n
\t\t\t} else if (!this._is_virtual_event(ev.id)) { // if it\'s virtual event we can skip it\r\n
\t\t\t\tresult.push(ev);\r\n
\t\t\t}\r\n
\t\t}\r\n
\t}\r\n
\treturn result;\r\n
};\r\n
\r\n
scheduler.config.repeat_date = "%m.%d.%Y";\r\n
scheduler.config.lightbox.sections = [\r\n
\t{name:"description", height:130, map_to:"text", type:"textarea" , focus:true},\r\n
\t{name:"recurring", type:"recurring", map_to:"rec_type", button:"recurring"},\r\n
\t{name:"time", height:72, type:"time", map_to:"auto"}\r\n
];\r\n
\r\n
\r\n
//drop secondary attributes\r\n
scheduler._copy_dummy = function(ev) {\r\n
\tvar start_date = new Date(this.start_date);\r\n
\tvar end_date = new Date(this.end_date);\r\n
\tthis.start_date = start_date;\r\n
\tthis.end_date = end_date;\r\n
\tthis.event_length = this.event_pid = this.rec_pattern = this.rec_type = null;\r\n
};\r\n
\r\n
scheduler.config.include_end_by = false;\r\n
scheduler.config.lightbox_recurring = \'ask\'; // series, instance\r\n
\r\n
scheduler.attachEvent("onClearAll", function(){\r\n
\tscheduler._rec_markers = {}; //clear recurring events data\r\n
\tscheduler._rec_markers_pull = {};\r\n
\tscheduler._rec_temp = [];\r\n
});\r\n
\r\n
scheduler.__recurring_template=\'<div class="dhx_form_repeat"> <form> <div class="dhx_repeat_left"> <label><input class="dhx_repeat_radio" type="radio" name="repeat" value="day" />Daily</label><br /> <label><input class="dhx_repeat_radio" type="radio" name="repeat" value="week"/>Weekly</label><br /> <label><input class="dhx_repeat_radio" type="radio" name="repeat" value="month" checked />Monthly</label><br /> <label><input class="dhx_repeat_radio" type="radio" name="repeat" value="year" />Yearly</label> </div> <div class="dhx_repeat_divider"></div> <div class="dhx_repeat_center"> <div style="display:none;" id="dhx_repeat_day"> <label><input class="dhx_repeat_radio" type="radio" name="day_type" value="d"/>Every</label><input class="dhx_repeat_text" type="text" name="day_count" value="1" />day<br /> <label><input class="dhx_repeat_radio" type="radio" name="day_type" checked value="w"/>Every workday</label> </div> <div style="display:none;" id="dhx_repeat_week"> Repeat every<input class="dhx_repeat_text" type="text" name="week_count" value="1" />week next days:<br /> <table class="dhx_repeat_days"> <tr> <td> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="1" />Monday</label><br /> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="4" />Thursday</label> </td> <td> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="2" />Tuesday</label><br /> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="5" />Friday</label> </td> <td> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="3" />Wednesday</label><br /> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="6" />Saturday</label> </td> <td> <label><input class="dhx_repeat_checkbox" type="checkbox" name="week_day" value="0" />Sunday</label><br /><br /> </td> </tr> </table> </div> <div id="dhx_repeat_month"> <label><input class="dhx_repeat_radio" type="radio" name="month_type" value="d"/>Repeat</label><input class="dhx_repeat_text" type="text" name="month_day" value="1" />day every<input class="dhx_repeat_text" type="text" name="month_count" value="1" />month<br /> <label><input class="dhx_repeat_radio" type="radio" name="month_type" checked value="w"/>On</label><input class="dhx_repeat_text" type="text" name="month_week2" value="1" /><select name="month_day2"><option value="1" selected >Monday<option value="2">Tuesday<option value="3">Wednesday<option value="4">Thursday<option value="5">Friday<option value="6">Saturday<option value="0">Sunday</select>every<input class="dhx_repeat_text" type="text" name="month_count2" value="1" />month<br /> </div> <div style="display:none;" id="dhx_repeat_year"> <label><input class="dhx_repeat_radio" type="radio" name="year_type" value="d"/>Every</label><input class="dhx_repeat_text" type="text" name="year_day" value="1" />day<select name="year_month"><option value="0" selected >January<option value="1">February<option value="2">March<option value="3">April<option value="4">May<option value="5">June<option value="6">July<option value="7">August<option value="8">September<option value="9">October<option value="10">November<option value="11">December</select>month<br /> <label><input class="dhx_repeat_radio" type="radio" name="year_type" checked value="w"/>On</label><input class="dhx_repeat_text" type="text" name="year_week2" value="1" /><select name="year_day2"><option value="1" selected >Monday<option value="2">Tuesday<option value="3">Wednesday<option value="4">Thursday<option value="5">Friday<option value="6">Saturday<option value="7">Sunday</select>of<select name="year_month2"><option value="0" selected >January<option value="1">February<option value="2">March<option value="3">April<option value="4">May<option value="5">June<option value="6">July<option value="7">August<option value="8">September<option value="9">October<option value="10">November<option value="11">December</select><br /> </div> </div> <div class="dhx_repeat_divider"></div> <div class="dhx_repeat_right"> <label><input class="dhx_repeat_radio" type="radio" name="end" checked/>No end date</label><br /> <label><input class="dhx_repeat_radio" type="radio" name="end" />After</label><input class="dhx_repeat_text" type="text" name="occurences_count" value="1" />occurrences<br /> <label><input class="dhx_repeat_radio" type="radio" name="end" />End by</label><input class="dhx_repeat_date" type="text" name="date_of_end" value="\'+scheduler.config.repeat_date_of_end+\'" /><br /> </div> </form> </div> <div style="clear:both"> </div>\';\r\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>35071</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
