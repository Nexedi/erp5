<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts65189552.9</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>dhtmlxscheduler_all_timed.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*\r\n
@license\r\n
dhtmlxScheduler v.4.3.1 \r\n
\r\n
This software is covered by GPL license. You also can obtain Commercial or Enterprise license to use it in non-GPL project - please contact sales@dhtmlx.com. Usage without proper license is prohibited.\r\n
\r\n
(c) Dinamenta, UAB.\r\n
*/\r\n
(function(){\r\n
\r\n
\tscheduler.config.all_timed = "short";\r\n
\r\n
\tvar is_event_short = function (ev) {\r\n
\t\treturn \t!((ev.end_date - ev.start_date)/(1000*60*60) >= 24);\r\n
\t};\r\n
\r\n
\t// copy of usual events and recurring instances;\r\n
\t// regular copy causes problems with recurrings which have series event as a prototype\r\n
\tscheduler._safe_copy = function(event){\r\n
\t\tvar proto = null,\r\n
\t\t\tcopy = null;\r\n
\t\tif(event.event_pid){\r\n
\t\t\tproto = scheduler.getEvent(event.event_pid);\r\n
\t\t}\r\n
\r\n
\t\tif (proto && proto.isPrototypeOf(event)) {\r\n
\t\t\tcopy = scheduler._copy_event(event);\r\n
\t\t\tdelete copy.event_length;\r\n
\t\t\tdelete copy.event_pid;\r\n
\t\t\tdelete copy.rec_pattern;\r\n
\t\t\tdelete copy.rec_type;\r\n
\t\t} else {\r\n
\t\t\tcopy = scheduler._lame_clone(event);\r\n
\t\t}\r\n
\t\treturn copy;\r\n
\t};\r\n
\r\n
\tvar old_prerender_events_line = scheduler._pre_render_events_line;\r\n
\tscheduler._pre_render_events_line = function(evs, hold){\r\n
\t\tif (!this.config.all_timed)\r\n
\t\t\treturn old_prerender_events_line.call(this, evs, hold);\r\n
\r\n
\t\tfor (var i=0; i < evs.length; i++) {\r\n
\t\t\tvar ev=evs[i];\r\n
\r\n
\t\t\tif (ev._timed)\r\n
\t\t\t\tcontinue;\r\n
\r\n
\t\t\tif (this.config.all_timed == "short") {\r\n
\t\t\t\tif (!is_event_short(ev)) {\r\n
\t\t\t\t\tevs.splice(i--,1);\r\n
\t\t\t\t\tcontinue;\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\r\n
\t\t\tvar ce = this._safe_copy(ev); // current event (event for one specific day) is copy of original with modified dates\r\n
\r\n
\t\t\tce.start_date = new Date(ce.start_date); // as lame copy doesn\'t copy date objects\r\n
\r\n
\t\t\tif (!isOvernightEvent(ev)) {\r\n
\t\t\t\tce.end_date = new Date(ev.end_date);\r\n
\t\t\t}\r\n
\t\t\telse {\r\n
\t\t\t\tce.end_date = getNextDay(ce.start_date);\r\n
\t\t\t\tif (this.config.last_hour != 24) { // if specific last_hour was set (e.g. 20)\r\n
\t\t\t\t\tce.end_date = setDateTime(ce.start_date, this.config.last_hour);\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\r\n
\t\t\tvar event_changed = false;\r\n
\t\t\tif (ce.start_date < this._max_date && ce.end_date > this._min_date && ce.start_date < ce.end_date) {\r\n
\t\t\t\tevs[i] = ce; // adding another event in collection\r\n
\t\t\t\tevent_changed = true;\r\n
\t\t\t}\r\n
\t\t//\tif (ce.start_date > ce.end_date) {\r\n
\t\t//\t\tevs.splice(i--,1);\r\n
\t\t//\t}\r\n
\r\n
\t\t\tvar re = this._safe_copy(ev); // remaining event, copy of original with modified start_date (making range more narrow)\r\n
\t\t\tre.end_date = new Date(re.end_date);\r\n
\t\t\tif (re.start_date < this._min_date)\r\n
\t\t\t\tre.start_date = setDateTime(this._min_date, this.config.first_hour);// as we are starting only with whole hours\r\n
\t\t\telse\r\n
\t\t\t\tre.start_date = setDateTime(getNextDay(ev.start_date), this.config.first_hour);\r\n
\r\n
\t\t\tif (re.start_date < this._max_date && re.start_date < re.end_date) {\r\n
\t\t\t\tif (event_changed)\r\n
\t\t\t\t\tevs.splice(i+1,0,re);//insert part\r\n
\t\t\t\telse {\r\n
\t\t\t\t\tevs[i--] = re;\r\n
\t\t\t\t\tcontinue;\r\n
\t\t\t\t}\r\n
\t\t\t}\r\n
\r\n
\t\t}\r\n
\t\t// in case of all_timed pre_render is not applied to the original event\r\n
\t\t// so we need to force redraw in case of dnd\r\n
\t\tvar redraw = (this._drag_mode == \'move\')?false:hold;\r\n
\t\treturn old_prerender_events_line.call(this, evs, redraw);\r\n
\r\n
\r\n
\t\tfunction isOvernightEvent(ev){\r\n
\t\t\tvar next_day = getNextDay(ev.start_date);\r\n
\t\t\treturn (+ev.end_date > +next_day);\r\n
\t\t}\r\n
\t\tfunction getNextDay(date){\r\n
\t\t\tvar next_day = scheduler.date.add(date, 1, "day");\r\n
\t\t\tnext_day = scheduler.date.date_part(next_day);\r\n
\t\t\treturn next_day;\r\n
\t\t}\r\n
\t\tfunction setDateTime(date, hours){\r\n
\t\t\tvar val = scheduler.date.date_part(new Date(date));\r\n
\t\t\tval.setHours(hours);\r\n
\t\t\treturn val;\r\n
\t\t}\r\n
\t};\r\n
\tvar old_get_visible_events = scheduler.get_visible_events;\r\n
\tscheduler.get_visible_events = function(only_timed){\r\n
\t\tif (!(this.config.all_timed && this.config.multi_day))\r\n
\t\t\treturn old_get_visible_events.call(this, only_timed);\t\r\n
\t\treturn old_get_visible_events.call(this, false); // only timed = false\r\n
\t};\r\n
\tscheduler.attachEvent("onBeforeViewChange", function (old_mode, old_date, mode, date) {\r\n
\t\tscheduler._allow_dnd = (mode == "day" || mode == "week");\r\n
\t\treturn true;\r\n
\t});\r\n
\r\n
\tscheduler._is_main_area_event = function(ev){\r\n
\t\treturn !!(ev._timed || this.config.all_timed === true || (this.config.all_timed == "short" && is_event_short(ev)) );\r\n
\t};\r\n
\r\n
\tvar oldUpdate = scheduler.updateEvent;\r\n
\tscheduler.updateEvent = function(id){\r\n
\t\t// full redraw(update_render=true) messes events order while dnd.\r\n
\t\t// individual redraw(update_render=false) of multiday event, which happens on select/unselect, expands event to full width of the cell and can be fixes only with full redraw.\r\n
\t\t// so for now full redraw is always enabled for not-dnd updates\r\n
\t\tvar fullRedrawNeeded = (scheduler.config.all_timed && !(scheduler.isOneDayEvent(scheduler._events[id]) || scheduler.getState().drag_id));\r\n
\t\tvar initial;\r\n
\t\tif(fullRedrawNeeded){\r\n
\t\t\tinitial = scheduler.config.update_render;\r\n
\t\t\tscheduler.config.update_render = true;\r\n
\t\t}\r\n
\t\toldUpdate.apply(scheduler, arguments);\r\n
\r\n
\t\tif(fullRedrawNeeded){\r\n
\t\t\tscheduler.config.update_render = initial;\r\n
\t\t}\r\n
\t};\r\n
})();

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>5052</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
