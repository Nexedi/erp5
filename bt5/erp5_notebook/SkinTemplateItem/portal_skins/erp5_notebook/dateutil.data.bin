# coding: utf-8
# file generated by setuptools_scm
# don't change, don't track in version control
version = '2.7.2'
# -*- coding: utf-8 -*-
"""
The rrule module offers a small, complete, and very fast, implementation of
the recurrence rules documented in the
`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
including support for caching of results.
"""
import itertools
import datetime
import calendar
import re
import sys

try:
    from math import gcd
except ImportError:
    from fractions import gcd

from six import advance_iterator, integer_types
try:
    from six.moves._thread import allocate_lock
except ModuleNotFoundError:
    class allocate_lock:
       def locked(self):
           return False

       def release(self):
           pass

       def acquire(self):
           pass

from six.moves import range
import heapq

from ._common import weekday as weekdaybase
from .tz import tzutc, tzlocal

# For warning about deprecation of until and count
from warnings import warn

__all__ = ["rrule", "rruleset", "rrulestr",
           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
           "HOURLY", "MINUTELY", "SECONDLY",
           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]

# Every mask is 7 days longer to handle cross-year weekly periods.
M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +
                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
M365MASK = list(M366MASK)
M29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))
MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
MDAY365MASK = list(MDAY366MASK)
M29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))
NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
NMDAY365MASK = list(NMDAY366MASK)
M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
WDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55
del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
MDAY365MASK = tuple(MDAY365MASK)
M365MASK = tuple(M365MASK)

FREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']

(YEARLY,
 MONTHLY,
 WEEKLY,
 DAILY,
 HOURLY,
 MINUTELY,
 SECONDLY) = list(range(7))

# Imported on demand.
easter = None
parser = None


class weekday(weekdaybase):
    """
    This version of weekday does not allow n = 0.
    """
    def __init__(self, wkday, n=None):
        if n == 0:
            raise ValueError("Can't create weekday with n==0")

        super(weekday, self).__init__(wkday, n)


MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))


def _invalidates_cache(f):
    """
    Decorator for rruleset methods which may invalidate the
    cached length.
    """
    def inner_func(self, *args, **kwargs):
        rv = f(self, *args, **kwargs)
        self._invalidate_cache()
        return rv

    return inner_func


class rrulebase(object):
    def __init__(self, cache=False):
        if cache:
            self._cache = []
            self._cache_lock = allocate_lock()
            self._invalidate_cache()
        else:
            self._cache = None
            self._cache_complete = False
            self._len = None

    def __iter__(self):
        if self._cache_complete:
            return iter(self._cache)
        elif self._cache is None:
            return self._iter()
        else:
            return self._iter_cached()

    def _invalidate_cache(self):
        if self._cache is not None:
            self._cache = []
            self._cache_complete = False
            self._cache_gen = self._iter()

            if self._cache_lock.locked():
                self._cache_lock.release()

        self._len = None

    def _iter_cached(self):
        i = 0
        gen = self._cache_gen
        cache = self._cache
        acquire = self._cache_lock.acquire
        release = self._cache_lock.release
        while gen:
            if i == len(cache):
                acquire()
                if self._cache_complete:
                    break
                try:
                    for j in range(10):
                        cache.append(advance_iterator(gen))
                except StopIteration:
                    self._cache_gen = gen = None
                    self._cache_complete = True
                    break
                release()
            yield cache[i]
            i += 1
        while i < self._len:
            yield cache[i]
            i += 1

    def __getitem__(self, item):
        if self._cache_complete:
            return self._cache[item]
        elif isinstance(item, slice):
            if item.step and item.step < 0:
                return list(iter(self))[item]
            else:
                return list(itertools.islice(self,
                                             item.start or 0,
                                             item.stop or sys.maxsize,
                                             item.step or 1))
        elif item >= 0:
            gen = iter(self)
            try:
                for i in range(item+1):
                    res = advance_iterator(gen)
            except StopIteration:
                raise IndexError
            return res
        else:
            return list(iter(self))[item]

    def __contains__(self, item):
        if self._cache_complete:
            return item in self._cache
        else:
            for i in self:
                if i == item:
                    return True
                elif i > item:
                    return False
        return False

    # __len__() introduces a large performance penality.
    def count(self):
        """ Returns the number of recurrences in this set. It will have go
            trough the whole recurrence, if this hasn't been done before. """
        if self._len is None:
            for x in self:
                pass
        return self._len

    def before(self, dt, inc=False):
        """ Returns the last recurrence before the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned. """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        last = None
        if inc:
            for i in gen:
                if i > dt:
                    break
                last = i
        else:
            for i in gen:
                if i >= dt:
                    break
                last = i
        return last

    def after(self, dt, inc=False):
        """ Returns the first recurrence after the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned.  """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        if inc:
            for i in gen:
                if i >= dt:
                    return i
        else:
            for i in gen:
                if i > dt:
                    return i
        return None

    def xafter(self, dt, count=None, inc=False):
        """
        Generator which yields up to `count` recurrences after the given
        datetime instance, equivalent to `after`.

        :param dt:
            The datetime at which to start generating recurrences.

        :param count:
            The maximum number of recurrences to generate. If `None` (default),
            dates are generated until the recurrence rule is exhausted.

        :param inc:
            If `dt` is an instance of the rule and `inc` is `True`, it is
            included in the output.

        :yields: Yields a sequence of `datetime` objects.
        """

        if self._cache_complete:
            gen = self._cache
        else:
            gen = self

        # Select the comparison function
        if inc:
            comp = lambda dc, dtc: dc >= dtc
        else:
            comp = lambda dc, dtc: dc > dtc

        # Generate dates
        n = 0
        for d in gen:
            if comp(d, dt):
                if count is not None:
                    n += 1
                    if n > count:
                        break

                yield d

    def between(self, after, before, inc=False, count=1):
        """ Returns all the occurrences of the rrule between after and before.
        The inc keyword defines what happens if after and/or before are
        themselves occurrences. With inc=True, they will be included in the
        list, if they are found in the recurrence set. """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        started = False
        l = []
        if inc:
            for i in gen:
                if i > before:
                    break
                elif not started:
                    if i >= after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        else:
            for i in gen:
                if i >= before:
                    break
                elif not started:
                    if i > after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        return l


class rrule(rrulebase):
    """
    That's the base of the rrule operation. It accepts all the keywords
    defined in the RFC as its constructor parameters (except byday,
    which was renamed to byweekday) and more. The constructor prototype is::

            rrule(freq)

    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
    or SECONDLY.

    .. note::
        Per RFC section 3.3.10, recurrence instances falling on invalid dates
        and times are ignored rather than coerced:

            Recurrence rules may generate recurrence instances with an invalid
            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
            on a day where the local time is moved forward by an hour at 1:00
            AM).  Such recurrence instances MUST be ignored and MUST NOT be
            counted as part of the recurrence set.

        This can lead to possibly surprising behavior when, for example, the
        start date occurs at the end of the month:

        >>> from dateutil.rrule import rrule, MONTHLY
        >>> from datetime import datetime
        >>> start_date = datetime(2014, 12, 31)
        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
        ... # doctest: +NORMALIZE_WHITESPACE
        [datetime.datetime(2014, 12, 31, 0, 0),
         datetime.datetime(2015, 1, 31, 0, 0),
         datetime.datetime(2015, 3, 31, 0, 0),
         datetime.datetime(2015, 5, 31, 0, 0)]

    Additionally, it supports the following keyword arguments:

    :param cache:
        If given, it must be a boolean value specifying to enable or disable
        caching of results. If you will use the same rrule instance multiple
        times, enabling caching will improve the performance considerably.
    :param dtstart:
        The recurrence start. Besides being the base for the recurrence,
        missing parameters in the final recurrence instances will also be
        extracted from this date. If not given, datetime.now() will be used
        instead.
    :param interval:
        The interval between each freq iteration. For example, when using
        YEARLY, an interval of 2 means once every two years, but with HOURLY,
        it means once every two hours. The default interval is 1.
    :param wkst:
        The week start day. Must be one of the MO, TU, WE constants, or an
        integer, specifying the first day of the week. This will affect
        recurrences based on weekly periods. The default week start is got
        from calendar.firstweekday(), and may be modified by
        calendar.setfirstweekday().
    :param count:
        How many occurrences will be generated.

        .. note::
            As of version 2.5.0, the use of the ``until`` keyword together
            with the ``count`` keyword is deprecated per RFC-5545 Sec. 3.3.10.
    :param until:
        If given, this must be a datetime instance, that will specify the
        limit of the recurrence. The last recurrence in the rule is the greatest
        datetime that is less than or equal to the value specified in the
        ``until`` parameter.

        .. note::
            As of version 2.5.0, the use of the ``until`` keyword together
            with the ``count`` keyword is deprecated per RFC-5545 Sec. 3.3.10.
    :param bysetpos:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each given integer will specify an occurrence
        number, corresponding to the nth occurrence of the rule inside the
        frequency period. For example, a bysetpos of -1 if combined with a
        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
        result in the last work day of every month.
    :param bymonth:
        If given, it must be either an integer, or a sequence of integers,
        meaning the months to apply the recurrence to.
    :param bymonthday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the month days to apply the recurrence to.
    :param byyearday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the year days to apply the recurrence to.
    :param byweekno:
        If given, it must be either an integer, or a sequence of integers,
        meaning the week numbers to apply the recurrence to. Week numbers
        have the meaning described in ISO8601, that is, the first week of
        the year is that containing at least four days of the new year.
    :param byweekday:
        If given, it must be either an integer (0 == MO), a sequence of
        integers, one of the weekday constants (MO, TU, etc), or a sequence
        of these constants. When given, these variables will define the
        weekdays where the recurrence will be applied. It's also possible to
        use an argument n for the weekday instances, which will mean the nth
        occurrence of this weekday in the period. For example, with MONTHLY,
        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
        first friday of the month where the recurrence happens. Notice that in
        the RFC documentation, this is specified as BYDAY, but was renamed to
        avoid the ambiguity of that keyword.
    :param byhour:
        If given, it must be either an integer, or a sequence of integers,
        meaning the hours to apply the recurrence to.
    :param byminute:
        If given, it must be either an integer, or a sequence of integers,
        meaning the minutes to apply the recurrence to.
    :param bysecond:
        If given, it must be either an integer, or a sequence of integers,
        meaning the seconds to apply the recurrence to.
    :param byeaster:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each integer will define an offset from the
        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
        Sunday itself. This is an extension to the RFC specification.
     """
    def __init__(self, freq, dtstart=None,
                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
                 byweekno=None, byweekday=None,
                 byhour=None, byminute=None, bysecond=None,
                 cache=False):
        super(rrule, self).__init__(cache)
        global easter
        if not dtstart:
            dtstart = datetime.datetime.now().replace(microsecond=0)
        elif not isinstance(dtstart, datetime.datetime):
            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
        else:
            dtstart = dtstart.replace(microsecond=0)
        self._dtstart = dtstart
        self._tzinfo = dtstart.tzinfo
        self._freq = freq
        self._interval = interval
        self._count = count

        # Cache the original byxxx rules, if they are provided, as the _byxxx
        # attributes do not necessarily map to the inputs, and this can be
        # a problem in generating the strings. Only store things if they've
        # been supplied (the string retrieval will just use .get())
        self._original_rule = {}

        if until and not isinstance(until, datetime.datetime):
            until = datetime.datetime.fromordinal(until.toordinal())
        self._until = until

        if self._dtstart and self._until:
            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):
                # According to RFC5545 Section 3.3.10:
                # https://tools.ietf.org/html/rfc5545#section-3.3.10
                #
                # > If the "DTSTART" property is specified as a date with UTC
                # > time or a date with local time and time zone reference,
                # > then the UNTIL rule part MUST be specified as a date with
                # > UTC time.
                raise ValueError(
                    'RRULE UNTIL values must be specified in UTC when DTSTART '
                    'is timezone-aware'
                )

        if count is not None and until:
            warn("Using both 'count' and 'until' is inconsistent with RFC 5545"
                 " and has been deprecated in dateutil. Future versions will "
                 "raise an error.", DeprecationWarning)

        if wkst is None:
            self._wkst = calendar.firstweekday()
        elif isinstance(wkst, integer_types):
            self._wkst = wkst
        else:
            self._wkst = wkst.weekday

        if bysetpos is None:
            self._bysetpos = None
        elif isinstance(bysetpos, integer_types):
            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
                raise ValueError("bysetpos must be between 1 and 366, "
                                 "or between -366 and -1")
            self._bysetpos = (bysetpos,)
        else:
            self._bysetpos = tuple(bysetpos)
            for pos in self._bysetpos:
                if pos == 0 or not (-366 <= pos <= 366):
                    raise ValueError("bysetpos must be between 1 and 366, "
                                     "or between -366 and -1")

        if self._bysetpos:
            self._original_rule['bysetpos'] = self._bysetpos

        if (byweekno is None and byyearday is None and bymonthday is None and
                byweekday is None and byeaster is None):
            if freq == YEARLY:
                if bymonth is None:
                    bymonth = dtstart.month
                    self._original_rule['bymonth'] = None
                bymonthday = dtstart.day
                self._original_rule['bymonthday'] = None
            elif freq == MONTHLY:
                bymonthday = dtstart.day
                self._original_rule['bymonthday'] = None
            elif freq == WEEKLY:
                byweekday = dtstart.weekday()
                self._original_rule['byweekday'] = None

        # bymonth
        if bymonth is None:
            self._bymonth = None
        else:
            if isinstance(bymonth, integer_types):
                bymonth = (bymonth,)

            self._bymonth = tuple(sorted(set(bymonth)))

            if 'bymonth' not in self._original_rule:
                self._original_rule['bymonth'] = self._bymonth

        # byyearday
        if byyearday is None:
            self._byyearday = None
        else:
            if isinstance(byyearday, integer_types):
                byyearday = (byyearday,)

            self._byyearday = tuple(sorted(set(byyearday)))
            self._original_rule['byyearday'] = self._byyearday

        # byeaster
        if byeaster is not None:
            if not easter:
                from dateutil import easter
            if isinstance(byeaster, integer_types):
                self._byeaster = (byeaster,)
            else:
                self._byeaster = tuple(sorted(byeaster))

            self._original_rule['byeaster'] = self._byeaster
        else:
            self._byeaster = None

        # bymonthday
        if bymonthday is None:
            self._bymonthday = ()
            self._bynmonthday = ()
        else:
            if isinstance(bymonthday, integer_types):
                bymonthday = (bymonthday,)

            bymonthday = set(bymonthday)            # Ensure it's unique

            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))
            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))

            # Storing positive numbers first, then negative numbers
            if 'bymonthday' not in self._original_rule:
                self._original_rule['bymonthday'] = tuple(
                    itertools.chain(self._bymonthday, self._bynmonthday))

        # byweekno
        if byweekno is None:
            self._byweekno = None
        else:
            if isinstance(byweekno, integer_types):
                byweekno = (byweekno,)

            self._byweekno = tuple(sorted(set(byweekno)))

            self._original_rule['byweekno'] = self._byweekno

        # byweekday / bynweekday
        if byweekday is None:
            self._byweekday = None
            self._bynweekday = None
        else:
            # If it's one of the valid non-sequence types, convert to a
            # single-element sequence before the iterator that builds the
            # byweekday set.
            if isinstance(byweekday, integer_types) or hasattr(byweekday, "n"):
                byweekday = (byweekday,)

            self._byweekday = set()
            self._bynweekday = set()
            for wday in byweekday:
                if isinstance(wday, integer_types):
                    self._byweekday.add(wday)
                elif not wday.n or freq > MONTHLY:
                    self._byweekday.add(wday.weekday)
                else:
                    self._bynweekday.add((wday.weekday, wday.n))

            if not self._byweekday:
                self._byweekday = None
            elif not self._bynweekday:
                self._bynweekday = None

            if self._byweekday is not None:
                self._byweekday = tuple(sorted(self._byweekday))
                orig_byweekday = [weekday(x) for x in self._byweekday]
            else:
                orig_byweekday = ()

            if self._bynweekday is not None:
                self._bynweekday = tuple(sorted(self._bynweekday))
                orig_bynweekday = [weekday(*x) for x in self._bynweekday]
            else:
                orig_bynweekday = ()

            if 'byweekday' not in self._original_rule:
                self._original_rule['byweekday'] = tuple(itertools.chain(
                    orig_byweekday, orig_bynweekday))

        # byhour
        if byhour is None:
            if freq < HOURLY:
                self._byhour = {dtstart.hour}
            else:
                self._byhour = None
        else:
            if isinstance(byhour, integer_types):
                byhour = (byhour,)

            if freq == HOURLY:
                self._byhour = self.__construct_byset(start=dtstart.hour,
                                                      byxxx=byhour,
                                                      base=24)
            else:
                self._byhour = set(byhour)

            self._byhour = tuple(sorted(self._byhour))
            self._original_rule['byhour'] = self._byhour

        # byminute
        if byminute is None:
            if freq < MINUTELY:
                self._byminute = {dtstart.minute}
            else:
                self._byminute = None
        else:
            if isinstance(byminute, integer_types):
                byminute = (byminute,)

            if freq == MINUTELY:
                self._byminute = self.__construct_byset(start=dtstart.minute,
                                                        byxxx=byminute,
                                                        base=60)
            else:
                self._byminute = set(byminute)

            self._byminute = tuple(sorted(self._byminute))
            self._original_rule['byminute'] = self._byminute

        # bysecond
        if bysecond is None:
            if freq < SECONDLY:
                self._bysecond = ((dtstart.second,))
            else:
                self._bysecond = None
        else:
            if isinstance(bysecond, integer_types):
                bysecond = (bysecond,)

            self._bysecond = set(bysecond)

            if freq == SECONDLY:
                self._bysecond = self.__construct_byset(start=dtstart.second,
                                                        byxxx=bysecond,
                                                        base=60)
            else:
                self._bysecond = set(bysecond)

            self._bysecond = tuple(sorted(self._bysecond))
            self._original_rule['bysecond'] = self._bysecond

        if self._freq >= HOURLY:
            self._timeset = None
        else:
            self._timeset = []
            for hour in self._byhour:
                for minute in self._byminute:
                    for second in self._bysecond:
                        self._timeset.append(
                            datetime.time(hour, minute, second,
                                          tzinfo=self._tzinfo))
            self._timeset.sort()
            self._timeset = tuple(self._timeset)

    def __str__(self):
        """
        Output a string that would generate this RRULE if passed to rrulestr.
        This is mostly compatible with RFC5545, except for the
        dateutil-specific extension BYEASTER.
        """

        output = []
        h, m, s = [None] * 3
        if self._dtstart:
            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))
            h, m, s = self._dtstart.timetuple()[3:6]

        parts = ['FREQ=' + FREQNAMES[self._freq]]
        if self._interval != 1:
            parts.append('INTERVAL=' + str(self._interval))

        if self._wkst:
            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])

        if self._count is not None:
            parts.append('COUNT=' + str(self._count))

        if self._until:
            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))

        if self._original_rule.get('byweekday') is not None:
            # The str() method on weekday objects doesn't generate
            # RFC5545-compliant strings, so we should modify that.
            original_rule = dict(self._original_rule)
            wday_strings = []
            for wday in original_rule['byweekday']:
                if wday.n:
                    wday_strings.append('{n:+d}{wday}'.format(
                        n=wday.n,
                        wday=repr(wday)[0:2]))
                else:
                    wday_strings.append(repr(wday))

            original_rule['byweekday'] = wday_strings
        else:
            original_rule = self._original_rule

        partfmt = '{name}={vals}'
        for name, key in [('BYSETPOS', 'bysetpos'),
                          ('BYMONTH', 'bymonth'),
                          ('BYMONTHDAY', 'bymonthday'),
                          ('BYYEARDAY', 'byyearday'),
                          ('BYWEEKNO', 'byweekno'),
                          ('BYDAY', 'byweekday'),
                          ('BYHOUR', 'byhour'),
                          ('BYMINUTE', 'byminute'),
                          ('BYSECOND', 'bysecond'),
                          ('BYEASTER', 'byeaster')]:
            value = original_rule.get(key)
            if value:
                parts.append(partfmt.format(name=name, vals=(','.join(str(v)
                                                             for v in value))))

        output.append('RRULE:' + ';'.join(parts))
        return '\n'.join(output)

    def replace(self, **kwargs):
        """Return new rrule with same attributes except for those attributes given new
           values by whichever keyword arguments are specified."""
        new_kwargs = {"interval": self._interval,
                      "count": self._count,
                      "dtstart": self._dtstart,
                      "freq": self._freq,
                      "until": self._until,
                      "wkst": self._wkst,
                      "cache": False if self._cache is None else True }
        new_kwargs.update(self._original_rule)
        new_kwargs.update(kwargs)
        return rrule(**new_kwargs)

    def _iter(self):
        year, month, day, hour, minute, second, weekday, yearday, _ = \
            self._dtstart.timetuple()

        # Some local variables to speed things up a bit
        freq = self._freq
        interval = self._interval
        wkst = self._wkst
        until = self._until
        bymonth = self._bymonth
        byweekno = self._byweekno
        byyearday = self._byyearday
        byweekday = self._byweekday
        byeaster = self._byeaster
        bymonthday = self._bymonthday
        bynmonthday = self._bynmonthday
        bysetpos = self._bysetpos
        byhour = self._byhour
        byminute = self._byminute
        bysecond = self._bysecond

        ii = _iterinfo(self)
        ii.rebuild(year, month)

        getdayset = {YEARLY: ii.ydayset,
                     MONTHLY: ii.mdayset,
                     WEEKLY: ii.wdayset,
                     DAILY: ii.ddayset,
                     HOURLY: ii.ddayset,
                     MINUTELY: ii.ddayset,
                     SECONDLY: ii.ddayset}[freq]

        if freq < HOURLY:
            timeset = self._timeset
        else:
            gettimeset = {HOURLY: ii.htimeset,
                          MINUTELY: ii.mtimeset,
                          SECONDLY: ii.stimeset}[freq]
            if ((freq >= HOURLY and
                 self._byhour and hour not in self._byhour) or
                (freq >= MINUTELY and
                 self._byminute and minute not in self._byminute) or
                (freq >= SECONDLY and
                 self._bysecond and second not in self._bysecond)):
                timeset = ()
            else:
                timeset = gettimeset(hour, minute, second)

        total = 0
        count = self._count
        while True:
            # Get dayset with the right frequency
            dayset, start, end = getdayset(year, month, day)

            # Do the "hard" work ;-)
            filtered = False
            for i in dayset[start:end]:
                if ((bymonth and ii.mmask[i] not in bymonth) or
                    (byweekno and not ii.wnomask[i]) or
                    (byweekday and ii.wdaymask[i] not in byweekday) or
                    (ii.nwdaymask and not ii.nwdaymask[i]) or
                    (byeaster and not ii.eastermask[i]) or
                    ((bymonthday or bynmonthday) and
                     ii.mdaymask[i] not in bymonthday and
                     ii.nmdaymask[i] not in bynmonthday) or
                    (byyearday and
                     ((i < ii.yearlen and i+1 not in byyearday and
                       -ii.yearlen+i not in byyearday) or
                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):
                    dayset[i] = None
                    filtered = True

            # Output results
            if bysetpos and timeset:
                poslist = []
                for pos in bysetpos:
                    if pos < 0:
                        daypos, timepos = divmod(pos, len(timeset))
                    else:
                        daypos, timepos = divmod(pos-1, len(timeset))
                    try:
                        i = [x for x in dayset[start:end]
                             if x is not None][daypos]
                        time = timeset[timepos]
                    except IndexError:
                        pass
                    else:
                        date = datetime.date.fromordinal(ii.yearordinal+i)
                        res = datetime.datetime.combine(date, time)
                        if res not in poslist:
                            poslist.append(res)
                poslist.sort()
                for res in poslist:
                    if until and res > until:
                        self._len = total
                        return
                    elif res >= self._dtstart:
                        if count is not None:
                            count -= 1
                            if count < 0:
                                self._len = total
                                return
                        total += 1
                        yield res
            else:
                for i in dayset[start:end]:
                    if i is not None:
                        date = datetime.date.fromordinal(ii.yearordinal + i)
                        for time in timeset:
                            res = datetime.datetime.combine(date, time)
                            if until and res > until:
                                self._len = total
                                return
                            elif res >= self._dtstart:
                                if count is not None:
                                    count -= 1
                                    if count < 0:
                                        self._len = total
                                        return

                                total += 1
                                yield res

            # Handle frequency and interval
            fixday = False
            if freq == YEARLY:
                year += interval
                if year > datetime.MAXYEAR:
                    self._len = total
                    return
                ii.rebuild(year, month)
            elif freq == MONTHLY:
                month += interval
                if month > 12:
                    div, mod = divmod(month, 12)
                    month = mod
                    year += div
                    if month == 0:
                        month = 12
                        year -= 1
                    if year > datetime.MAXYEAR:
                        self._len = total
                        return
                ii.rebuild(year, month)
            elif freq == WEEKLY:
                if wkst > weekday:
                    day += -(weekday+1+(6-wkst))+self._interval*7
                else:
                    day += -(weekday-wkst)+self._interval*7
                weekday = wkst
                fixday = True
            elif freq == DAILY:
                day += interval
                fixday = True
            elif freq == HOURLY:
                if filtered:
                    # Jump to one iteration before next day
                    hour += ((23-hour)//interval)*interval

                if byhour:
                    ndays, hour = self.__mod_distance(value=hour,
                                                      byxxx=self._byhour,
                                                      base=24)
                else:
                    ndays, hour = divmod(hour+interval, 24)

                if ndays:
                    day += ndays
                    fixday = True

                timeset = gettimeset(hour, minute, second)
            elif freq == MINUTELY:
                if filtered:
                    # Jump to one iteration before next day
                    minute += ((1439-(hour*60+minute))//interval)*interval

                valid = False
                rep_rate = (24*60)
                for j in range(rep_rate // gcd(interval, rep_rate)):
                    if byminute:
                        nhours, minute = \
                            self.__mod_distance(value=minute,
                                                byxxx=self._byminute,
                                                base=60)
                    else:
                        nhours, minute = divmod(minute+interval, 60)

                    div, hour = divmod(hour+nhours, 24)
                    if div:
                        day += div
                        fixday = True
                        filtered = False

                    if not byhour or hour in byhour:
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval and ' +
                                     'byhour resulting in empty rule.')

                timeset = gettimeset(hour, minute, second)
            elif freq == SECONDLY:
                if filtered:
                    # Jump to one iteration before next day
                    second += (((86399 - (hour * 3600 + minute * 60 + second))
                                // interval) * interval)

                rep_rate = (24 * 3600)
                valid = False
                for j in range(0, rep_rate // gcd(interval, rep_rate)):
                    if bysecond:
                        nminutes, second = \
                            self.__mod_distance(value=second,
                                                byxxx=self._bysecond,
                                                base=60)
                    else:
                        nminutes, second = divmod(second+interval, 60)

                    div, minute = divmod(minute+nminutes, 60)
                    if div:
                        hour += div
                        div, hour = divmod(hour, 24)
                        if div:
                            day += div
                            fixday = True

                    if ((not byhour or hour in byhour) and
                            (not byminute or minute in byminute) and
                            (not bysecond or second in bysecond)):
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval, ' +
                                     'byhour and byminute resulting in empty' +
                                     ' rule.')

                timeset = gettimeset(hour, minute, second)

            if fixday and day > 28:
                daysinmonth = calendar.monthrange(year, month)[1]
                if day > daysinmonth:
                    while day > daysinmonth:
                        day -= daysinmonth
                        month += 1
                        if month == 13:
                            month = 1
                            year += 1
                            if year > datetime.MAXYEAR:
                                self._len = total
                                return
                        daysinmonth = calendar.monthrange(year, month)[1]
                    ii.rebuild(year, month)

    def __construct_byset(self, start, byxxx, base):
        """
        If a `BYXXX` sequence is passed to the constructor at the same level as
        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
        specifications which cannot be reached given some starting conditions.

        This occurs whenever the interval is not coprime with the base of a
        given unit and the difference between the starting position and the
        ending position is not coprime with the greatest common denominator
        between the interval and the base. For example, with a FREQ of hourly
        starting at 17:00 and an interval of 4, the only valid values for
        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
        coprime.

        :param start:
            Specifies the starting position.
        :param byxxx:
            An iterable containing the list of allowed values.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        This does not preserve the type of the iterable, returning a set, since
        the values should be unique and the order is irrelevant, this will
        speed up later lookups.

        In the event of an empty set, raises a :exception:`ValueError`, as this
        results in an empty rrule.
        """

        cset = set()

        # Support a single byxxx value.
        if isinstance(byxxx, integer_types):
            byxxx = (byxxx, )

        for num in byxxx:
            i_gcd = gcd(self._interval, base)
            # Use divmod rather than % because we need to wrap negative nums.
            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:
                cset.add(num)

        if len(cset) == 0:
            raise ValueError("Invalid rrule byxxx generates an empty set.")

        return cset

    def __mod_distance(self, value, byxxx, base):
        """
        Calculates the next value in a sequence where the `FREQ` parameter is
        specified along with a `BYXXX` parameter at the same "level"
        (e.g. `HOURLY` specified with `BYHOUR`).

        :param value:
            The old value of the component.
        :param byxxx:
            The `BYXXX` set, which should have been generated by
            `rrule._construct_byset`, or something else which checks that a
            valid rule is present.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        If a valid value is not found after `base` iterations (the maximum
        number before the sequence would start to repeat), this raises a
        :exception:`ValueError`, as no valid values were found.

        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
        smallest number of `interval` repetitions until the next specified
        value in `byxxx` is found.
        """
        accumulator = 0
        for ii in range(1, base + 1):
            # Using divmod() over % to account for negative intervals
            div, value = divmod(value + self._interval, base)
            accumulator += div
            if value in byxxx:
                return (accumulator, value)


class _iterinfo(object):
    __slots__ = ["rrule", "lastyear", "lastmonth",
                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
                 "mmask", "mrange", "mdaymask", "nmdaymask",
                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]

    def __init__(self, rrule):
        for attr in self.__slots__:
            setattr(self, attr, None)
        self.rrule = rrule

    def rebuild(self, year, month):
        # Every mask is 7 days longer to handle cross-year weekly periods.
        rr = self.rrule
        if year != self.lastyear:
            self.yearlen = 365 + calendar.isleap(year)
            self.nextyearlen = 365 + calendar.isleap(year + 1)
            firstyday = datetime.date(year, 1, 1)
            self.yearordinal = firstyday.toordinal()
            self.yearweekday = firstyday.weekday()

            wday = datetime.date(year, 1, 1).weekday()
            if self.yearlen == 365:
                self.mmask = M365MASK
                self.mdaymask = MDAY365MASK
                self.nmdaymask = NMDAY365MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M365RANGE
            else:
                self.mmask = M366MASK
                self.mdaymask = MDAY366MASK
                self.nmdaymask = NMDAY366MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M366RANGE

            if not rr._byweekno:
                self.wnomask = None
            else:
                self.wnomask = [0]*(self.yearlen+7)
                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7
                if no1wkst >= 4:
                    no1wkst = 0
                    # Number of days in the year, plus the days we got
                    # from last year.
                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7
                else:
                    # Number of days in the year, minus the days we
                    # left in last year.
                    wyearlen = self.yearlen-no1wkst
                div, mod = divmod(wyearlen, 7)
                numweeks = div+mod//4
                for n in rr._byweekno:
                    if n < 0:
                        n += numweeks+1
                    if not (0 < n <= numweeks):
                        continue
                    if n > 1:
                        i = no1wkst+(n-1)*7
                        if no1wkst != firstwkst:
                            i -= 7-firstwkst
                    else:
                        i = no1wkst
                    for j in range(7):
                        self.wnomask[i] = 1
                        i += 1
                        if self.wdaymask[i] == rr._wkst:
                            break
                if 1 in rr._byweekno:
                    # Check week number 1 of next year as well
                    # TODO: Check -numweeks for next year.
                    i = no1wkst+numweeks*7
                    if no1wkst != firstwkst:
                        i -= 7-firstwkst
                    if i < self.yearlen:
                        # If week starts in next year, we
                        # don't care about it.
                        for j in range(7):
                            self.wnomask[i] = 1
                            i += 1
                            if self.wdaymask[i] == rr._wkst:
                                break
                if no1wkst:
                    # Check last week number of last year as
                    # well. If no1wkst is 0, either the year
                    # started on week start, or week number 1
                    # got days from last year, so there are no
                    # days from last year's last week number in
                    # this year.
                    if -1 not in rr._byweekno:
                        lyearweekday = datetime.date(year-1, 1, 1).weekday()
                        lno1wkst = (7-lyearweekday+rr._wkst) % 7
                        lyearlen = 365+calendar.isleap(year-1)
                        if lno1wkst >= 4:
                            lno1wkst = 0
                            lnumweeks = 52+(lyearlen +
                                            (lyearweekday-rr._wkst) % 7) % 7//4
                        else:
                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4
                    else:
                        lnumweeks = -1
                    if lnumweeks in rr._byweekno:
                        for i in range(no1wkst):
                            self.wnomask[i] = 1

        if (rr._bynweekday and (month != self.lastmonth or
                                year != self.lastyear)):
            ranges = []
            if rr._freq == YEARLY:
                if rr._bymonth:
                    for month in rr._bymonth:
                        ranges.append(self.mrange[month-1:month+1])
                else:
                    ranges = [(0, self.yearlen)]
            elif rr._freq == MONTHLY:
                ranges = [self.mrange[month-1:month+1]]
            if ranges:
                # Weekly frequency won't get here, so we may not
                # care about cross-year weekly periods.
                self.nwdaymask = [0]*self.yearlen
                for first, last in ranges:
                    last -= 1
                    for wday, n in rr._bynweekday:
                        if n < 0:
                            i = last+(n+1)*7
                            i -= (self.wdaymask[i]-wday) % 7
                        else:
                            i = first+(n-1)*7
                            i += (7-self.wdaymask[i]+wday) % 7
                        if first <= i <= last:
                            self.nwdaymask[i] = 1

        if rr._byeaster:
            self.eastermask = [0]*(self.yearlen+7)
            eyday = easter.easter(year).toordinal()-self.yearordinal
            for offset in rr._byeaster:
                self.eastermask[eyday+offset] = 1

        self.lastyear = year
        self.lastmonth = month

    def ydayset(self, year, month, day):
        return list(range(self.yearlen)), 0, self.yearlen

    def mdayset(self, year, month, day):
        dset = [None]*self.yearlen
        start, end = self.mrange[month-1:month+1]
        for i in range(start, end):
            dset[i] = i
        return dset, start, end

    def wdayset(self, year, month, day):
        # We need to handle cross-year weeks here.
        dset = [None]*(self.yearlen+7)
        i = datetime.date(year, month, day).toordinal()-self.yearordinal
        start = i
        for j in range(7):
            dset[i] = i
            i += 1
            # if (not (0 <= i < self.yearlen) or
            #    self.wdaymask[i] == self.rrule._wkst):
            # This will cross the year boundary, if necessary.
            if self.wdaymask[i] == self.rrule._wkst:
                break
        return dset, start, i

    def ddayset(self, year, month, day):
        dset = [None] * self.yearlen
        i = datetime.date(year, month, day).toordinal() - self.yearordinal
        dset[i] = i
        return dset, i, i + 1

    def htimeset(self, hour, minute, second):
        tset = []
        rr = self.rrule
        for minute in rr._byminute:
            for second in rr._bysecond:
                tset.append(datetime.time(hour, minute, second,
                                          tzinfo=rr._tzinfo))
        tset.sort()
        return tset

    def mtimeset(self, hour, minute, second):
        tset = []
        rr = self.rrule
        for second in rr._bysecond:
            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
        tset.sort()
        return tset

    def stimeset(self, hour, minute, second):
        return (datetime.time(hour, minute, second,
                tzinfo=self.rrule._tzinfo),)


class rruleset(rrulebase):
    """ The rruleset type allows more complex recurrence setups, mixing
    multiple rules, dates, exclusion rules, and exclusion dates. The type
    constructor takes the following keyword arguments:

    :param cache: If True, caching of results will be enabled, improving
                  performance of multiple queries considerably. """

    class _genitem(object):
        def __init__(self, genlist, gen):
            try:
                self.dt = advance_iterator(gen)
                genlist.append(self)
            except StopIteration:
                pass
            self.genlist = genlist
            self.gen = gen

        def __next__(self):
            try:
                self.dt = advance_iterator(self.gen)
            except StopIteration:
                if self.genlist[0] is self:
                    heapq.heappop(self.genlist)
                else:
                    self.genlist.remove(self)
                    heapq.heapify(self.genlist)

        next = __next__

        def __lt__(self, other):
            return self.dt < other.dt

        def __gt__(self, other):
            return self.dt > other.dt

        def __eq__(self, other):
            return self.dt == other.dt

        def __ne__(self, other):
            return self.dt != other.dt

    def __init__(self, cache=False):
        super(rruleset, self).__init__(cache)
        self._rrule = []
        self._rdate = []
        self._exrule = []
        self._exdate = []

    @_invalidates_cache
    def rrule(self, rrule):
        """ Include the given :py:class:`rrule` instance in the recurrence set
            generation. """
        self._rrule.append(rrule)

    @_invalidates_cache
    def rdate(self, rdate):
        """ Include the given :py:class:`datetime` instance in the recurrence
            set generation. """
        self._rdate.append(rdate)

    @_invalidates_cache
    def exrule(self, exrule):
        """ Include the given rrule instance in the recurrence set exclusion
            list. Dates which are part of the given recurrence rules will not
            be generated, even if some inclusive rrule or rdate matches them.
        """
        self._exrule.append(exrule)

    @_invalidates_cache
    def exdate(self, exdate):
        """ Include the given datetime instance in the recurrence set
            exclusion list. Dates included that way will not be generated,
            even if some inclusive rrule or rdate matches them. """
        self._exdate.append(exdate)

    def _iter(self):
        rlist = []
        self._rdate.sort()
        self._genitem(rlist, iter(self._rdate))
        for gen in [iter(x) for x in self._rrule]:
            self._genitem(rlist, gen)
        exlist = []
        self._exdate.sort()
        self._genitem(exlist, iter(self._exdate))
        for gen in [iter(x) for x in self._exrule]:
            self._genitem(exlist, gen)
        lastdt = None
        total = 0
        heapq.heapify(rlist)
        heapq.heapify(exlist)
        while rlist:
            ritem = rlist[0]
            if not lastdt or lastdt != ritem.dt:
                while exlist and exlist[0] < ritem:
                    exitem = exlist[0]
                    advance_iterator(exitem)
                    if exlist and exlist[0] is exitem:
                        heapq.heapreplace(exlist, exitem)
                if not exlist or ritem != exlist[0]:
                    total += 1
                    yield ritem.dt
                lastdt = ritem.dt
            advance_iterator(ritem)
            if rlist and rlist[0] is ritem:
                heapq.heapreplace(rlist, ritem)
        self._len = total


class _rrulestr(object):

    _freq_map = {"YEARLY": YEARLY,
                 "MONTHLY": MONTHLY,
                 "WEEKLY": WEEKLY,
                 "DAILY": DAILY,
                 "HOURLY": HOURLY,
                 "MINUTELY": MINUTELY,
                 "SECONDLY": SECONDLY}

    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
                    "FR": 4, "SA": 5, "SU": 6}

    def _handle_int(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = int(value)

    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]

    _handle_INTERVAL = _handle_int
    _handle_COUNT = _handle_int
    _handle_BYSETPOS = _handle_int_list
    _handle_BYMONTH = _handle_int_list
    _handle_BYMONTHDAY = _handle_int_list
    _handle_BYYEARDAY = _handle_int_list
    _handle_BYEASTER = _handle_int_list
    _handle_BYWEEKNO = _handle_int_list
    _handle_BYHOUR = _handle_int_list
    _handle_BYMINUTE = _handle_int_list
    _handle_BYSECOND = _handle_int_list

    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
        rrkwargs["freq"] = self._freq_map[value]

    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
        global parser
        if not parser:
            from dateutil import parser
        try:
            rrkwargs["until"] = parser.parse(value,
                                             ignoretz=kwargs.get("ignoretz"),
                                             tzinfos=kwargs.get("tzinfos"))
        except ValueError:
            raise ValueError("invalid until date")

    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
        rrkwargs["wkst"] = self._weekday_map[value]

    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
        """
        Two ways to specify this: +1MO or MO(+1)
        """
        l = []
        for wday in value.split(','):
            if '(' in wday:
                # If it's of the form TH(+1), etc.
                splt = wday.split('(')
                w = splt[0]
                n = int(splt[1][:-1])
            elif len(wday):
                # If it's of the form +1MO
                for i in range(len(wday)):
                    if wday[i] not in '+-0123456789':
                        break
                n = wday[:i] or None
                w = wday[i:]
                if n:
                    n = int(n)
            else:
                raise ValueError("Invalid (empty) BYDAY specification.")

            l.append(weekdays[self._weekday_map[w]](n))
        rrkwargs["byweekday"] = l

    _handle_BYDAY = _handle_BYWEEKDAY

    def _parse_rfc_rrule(self, line,
                         dtstart=None,
                         cache=False,
                         ignoretz=False,
                         tzinfos=None):
        if line.find(':') != -1:
            name, value = line.split(':')
            if name != "RRULE":
                raise ValueError("unknown parameter name")
        else:
            value = line
        rrkwargs = {}
        for pair in value.split(';'):
            name, value = pair.split('=')
            name = name.upper()
            value = value.upper()
            try:
                getattr(self, "_handle_"+name)(rrkwargs, name, value,
                                               ignoretz=ignoretz,
                                               tzinfos=tzinfos)
            except AttributeError:
                raise ValueError("unknown parameter '%s'" % name)
            except (KeyError, ValueError):
                raise ValueError("invalid '%s': %s" % (name, value))
        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)

    def _parse_rfc(self, s,
                   dtstart=None,
                   cache=False,
                   unfold=False,
                   forceset=False,
                   compatible=False,
                   ignoretz=False,
                   tzids=None,
                   tzinfos=None):
        global parser
        if compatible:
            forceset = True
            unfold = True

        TZID_NAMES = dict(map(
            lambda x: (x.upper(), x),
            re.findall('TZID=(?P<name>[^:]+):', s)
        ))
        s = s.upper()
        if not s.strip():
            raise ValueError("empty string")
        if unfold:
            lines = s.splitlines()
            i = 0
            while i < len(lines):
                line = lines[i].rstrip()
                if not line:
                    del lines[i]
                elif i > 0 and line[0] == " ":
                    lines[i-1] += line[1:]
                    del lines[i]
                else:
                    i += 1
        else:
            lines = s.split()
        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or
                                                  s.startswith('RRULE:'))):
            return self._parse_rfc_rrule(lines[0], cache=cache,
                                         dtstart=dtstart, ignoretz=ignoretz,
                                         tzinfos=tzinfos)
        else:
            rrulevals = []
            rdatevals = []
            exrulevals = []
            exdatevals = []
            for line in lines:
                if not line:
                    continue
                if line.find(':') == -1:
                    name = "RRULE"
                    value = line
                else:
                    name, value = line.split(':', 1)
                parms = name.split(';')
                if not parms:
                    raise ValueError("empty property name")
                name = parms[0]
                parms = parms[1:]
                if name == "RRULE":
                    for parm in parms:
                        raise ValueError("unsupported RRULE parm: "+parm)
                    rrulevals.append(value)
                elif name == "RDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError("unsupported RDATE parm: "+parm)
                    rdatevals.append(value)
                elif name == "EXRULE":
                    for parm in parms:
                        raise ValueError("unsupported EXRULE parm: "+parm)
                    exrulevals.append(value)
                elif name == "EXDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError("unsupported EXDATE parm: "+parm)
                    exdatevals.append(value)
                elif name == "DTSTART":
                    # RFC 5445 3.8.2.4: The VALUE parameter is optional, but
                    # may be found only once.
                    value_found = False
                    TZID = None
                    valid_values = {"VALUE=DATE-TIME", "VALUE=DATE"}
                    for parm in parms:
                        if parm.startswith("TZID="):
                            try:
                                tzkey = TZID_NAMES[parm.split('TZID=')[-1]]
                            except KeyError:
                                continue
                            if tzids is None:
                                from . import tz
                                tzlookup = tz.gettz
                            elif callable(tzids):
                                tzlookup = tzids
                            else:
                                tzlookup = getattr(tzids, 'get', None)
                                if tzlookup is None:
                                    msg = ('tzids must be a callable, ' +
                                           'mapping, or None, ' +
                                           'not %s' % tzids)
                                    raise ValueError(msg)

                            TZID = tzlookup(tzkey)
                            continue
                        if parm not in valid_values:
                            raise ValueError("unsupported DTSTART parm: "+parm)
                        else:
                            if value_found:
                                msg = ("Duplicate value parameter found in " +
                                       "DTSTART: " + parm)
                                raise ValueError(msg)
                            value_found = True
                    if not parser:
                        from dateutil import parser
                    dtstart = parser.parse(value, ignoretz=ignoretz,
                                           tzinfos=tzinfos)
                    if TZID is not None:
                        if dtstart.tzinfo is None:
                            dtstart = dtstart.replace(tzinfo=TZID)
                        else:
                            raise ValueError('DTSTART specifies multiple timezones')
                else:
                    raise ValueError("unsupported property: "+name)
            if (forceset or len(rrulevals) > 1 or rdatevals
                    or exrulevals or exdatevals):
                if not parser and (rdatevals or exdatevals):
                    from dateutil import parser
                rset = rruleset(cache=cache)
                for value in rrulevals:
                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                     ignoretz=ignoretz,
                                                     tzinfos=tzinfos))
                for value in rdatevals:
                    for datestr in value.split(','):
                        rset.rdate(parser.parse(datestr,
                                                ignoretz=ignoretz,
                                                tzinfos=tzinfos))
                for value in exrulevals:
                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                      ignoretz=ignoretz,
                                                      tzinfos=tzinfos))
                for value in exdatevals:
                    for datestr in value.split(','):
                        rset.exdate(parser.parse(datestr,
                                                 ignoretz=ignoretz,
                                                 tzinfos=tzinfos))
                if compatible and dtstart:
                    rset.rdate(dtstart)
                return rset
            else:
                return self._parse_rfc_rrule(rrulevals[0],
                                             dtstart=dtstart,
                                             cache=cache,
                                             ignoretz=ignoretz,
                                             tzinfos=tzinfos)

    def __call__(self, s, **kwargs):
        return self._parse_rfc(s, **kwargs)


rrulestr = _rrulestr()

# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
import datetime
import calendar

import operator
from math import copysign

from six import integer_types
from warnings import warn

from ._common import weekday

MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))

__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]


class relativedelta(object):
    """
    The relativedelta type is based on the specification of the excellent
    work done by M.-A. Lemburg in his
    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
    However, notice that this type does *NOT* implement the same algorithm as
    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.

    There are two different ways to build a relativedelta instance. The
    first one is passing it two date/datetime classes::

        relativedelta(datetime1, datetime2)

    The second one is passing it any number of the following keyword arguments::

        relativedelta(arg1=x,arg2=y,arg3=z...)

        year, month, day, hour, minute, second, microsecond:
            Absolute information (argument is singular); adding or subtracting a
            relativedelta with absolute information does not perform an arithmetic
            operation, but rather REPLACES the corresponding value in the
            original datetime with the value(s) in relativedelta.

        years, months, weeks, days, hours, minutes, seconds, microseconds:
            Relative information, may be negative (argument is plural); adding
            or subtracting a relativedelta with relative information performs
            the corresponding aritmetic operation on the original datetime value
            with the information in the relativedelta.

        weekday:
            One of the weekday instances (MO, TU, etc). These instances may
            receive a parameter N, specifying the Nth weekday, which could
            be positive or negative (like MO(+1) or MO(-2). Not specifying
            it is the same as specifying +1. You can also use an integer,
            where 0=MO.

        leapdays:
            Will add given days to the date found, if year is a leap
            year, and the date found is post 28 of february.

        yearday, nlyearday:
            Set the yearday or the non-leap year day (jump leap days).
            These are converted to day/month/leapdays information.

    Here is the behavior of operations with relativedelta:

    1. Calculate the absolute year, using the 'year' argument, or the
       original datetime year, if the argument is not present.

    2. Add the relative 'years' argument to the absolute year.

    3. Do steps 1 and 2 for month/months.

    4. Calculate the absolute day, using the 'day' argument, or the
       original datetime day, if the argument is not present. Then,
       subtract from the day until it fits in the year and month
       found after their operations.

    5. Add the relative 'days' argument to the absolute day. Notice
       that the 'weeks' argument is multiplied by 7 and added to
       'days'.

    6. Do steps 1 and 2 for hour/hours, minute/minutes, second/seconds,
       microsecond/microseconds.

    7. If the 'weekday' argument is present, calculate the weekday,
       with the given (wday, nth) tuple. wday is the index of the
       weekday (0-6, 0=Mon), and nth is the number of weeks to add
       forward or backward, depending on its signal. Notice that if
       the calculated date is already Monday, for example, using
       (0, 1) or (0, -1) won't change the day.
    """

    def __init__(self, dt1=None, dt2=None,
                 years=0, months=0, days=0, leapdays=0, weeks=0,
                 hours=0, minutes=0, seconds=0, microseconds=0,
                 year=None, month=None, day=None, weekday=None,
                 yearday=None, nlyearday=None,
                 hour=None, minute=None, second=None, microsecond=None):

        if dt1 and dt2:
            # datetime is a subclass of date. So both must be date
            if not (isinstance(dt1, datetime.date) and
                    isinstance(dt2, datetime.date)):
                raise TypeError("relativedelta only diffs datetime/date")

            # We allow two dates, or two datetimes, so we coerce them to be
            # of the same type
            if (isinstance(dt1, datetime.datetime) !=
                    isinstance(dt2, datetime.datetime)):
                if not isinstance(dt1, datetime.datetime):
                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
                elif not isinstance(dt2, datetime.datetime):
                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())

            self.years = 0
            self.months = 0
            self.days = 0
            self.leapdays = 0
            self.hours = 0
            self.minutes = 0
            self.seconds = 0
            self.microseconds = 0
            self.year = None
            self.month = None
            self.day = None
            self.weekday = None
            self.hour = None
            self.minute = None
            self.second = None
            self.microsecond = None
            self._has_time = 0

            # Get year / month delta between the two
            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)
            self._set_months(months)

            # Remove the year/month delta so the timedelta is just well-defined
            # time units (seconds, days and microseconds)
            dtm = self.__radd__(dt2)

            # If we've overshot our target, make an adjustment
            if dt1 < dt2:
                compare = operator.gt
                increment = 1
            else:
                compare = operator.lt
                increment = -1

            while compare(dt1, dtm):
                months += increment
                self._set_months(months)
                dtm = self.__radd__(dt2)

            # Get the timedelta between the "months-adjusted" date and dt1
            delta = dt1 - dtm
            self.seconds = delta.seconds + delta.days * 86400
            self.microseconds = delta.microseconds
        else:
            # Check for non-integer values in integer-only quantities
            if any(x is not None and x != int(x) for x in (years, months)):
                raise ValueError("Non-integer years and months are "
                                 "ambiguous and not currently supported.")

            # Relative information
            self.years = int(years)
            self.months = int(months)
            self.days = days + weeks * 7
            self.leapdays = leapdays
            self.hours = hours
            self.minutes = minutes
            self.seconds = seconds
            self.microseconds = microseconds

            # Absolute information
            self.year = year
            self.month = month
            self.day = day
            self.hour = hour
            self.minute = minute
            self.second = second
            self.microsecond = microsecond

            if any(x is not None and int(x) != x
                   for x in (year, month, day, hour,
                             minute, second, microsecond)):
                # For now we'll deprecate floats - later it'll be an error.
                warn("Non-integer value passed as absolute information. " +
                     "This is not a well-defined condition and will raise " +
                     "errors in future versions.", DeprecationWarning)

            if isinstance(weekday, integer_types):
                self.weekday = weekdays[weekday]
            else:
                self.weekday = weekday

            yday = 0
            if nlyearday:
                yday = nlyearday
            elif yearday:
                yday = yearday
                if yearday > 59:
                    self.leapdays = -1
            if yday:
                ydayidx = [31, 59, 90, 120, 151, 181, 212,
                           243, 273, 304, 334, 366]
                for idx, ydays in enumerate(ydayidx):
                    if yday <= ydays:
                        self.month = idx+1
                        if idx == 0:
                            self.day = yday
                        else:
                            self.day = yday-ydayidx[idx-1]
                        break
                else:
                    raise ValueError("invalid year day (%d)" % yday)

        self._fix()

    def _fix(self):
        if abs(self.microseconds) > 999999:
            s = _sign(self.microseconds)
            div, mod = divmod(self.microseconds * s, 1000000)
            self.microseconds = mod * s
            self.seconds += div * s
        if abs(self.seconds) > 59:
            s = _sign(self.seconds)
            div, mod = divmod(self.seconds * s, 60)
            self.seconds = mod * s
            self.minutes += div * s
        if abs(self.minutes) > 59:
            s = _sign(self.minutes)
            div, mod = divmod(self.minutes * s, 60)
            self.minutes = mod * s
            self.hours += div * s
        if abs(self.hours) > 23:
            s = _sign(self.hours)
            div, mod = divmod(self.hours * s, 24)
            self.hours = mod * s
            self.days += div * s
        if abs(self.months) > 11:
            s = _sign(self.months)
            div, mod = divmod(self.months * s, 12)
            self.months = mod * s
            self.years += div * s
        if (self.hours or self.minutes or self.seconds or self.microseconds
                or self.hour is not None or self.minute is not None or
                self.second is not None or self.microsecond is not None):
            self._has_time = 1
        else:
            self._has_time = 0

    @property
    def weeks(self):
        return int(self.days / 7.0)

    @weeks.setter
    def weeks(self, value):
        self.days = self.days - (self.weeks * 7) + value * 7

    def _set_months(self, months):
        self.months = months
        if abs(self.months) > 11:
            s = _sign(self.months)
            div, mod = divmod(self.months * s, 12)
            self.months = mod * s
            self.years = div * s
        else:
            self.years = 0

    def normalized(self):
        """
        Return a version of this object represented entirely using integer
        values for the relative attributes.

        >>> relativedelta(days=1.5, hours=2).normalized()
        relativedelta(days=1, hours=14)

        :return:
            Returns a :class:`dateutil.relativedelta.relativedelta` object.
        """
        # Cascade remainders down (rounding each to roughly nearest microsecond)
        days = int(self.days)

        hours_f = round(self.hours + 24 * (self.days - days), 11)
        hours = int(hours_f)

        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)
        minutes = int(minutes_f)

        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)
        seconds = int(seconds_f)

        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))

        # Constructor carries overflow back up with call to _fix()
        return self.__class__(years=self.years, months=self.months,
                              days=days, hours=hours, minutes=minutes,
                              seconds=seconds, microseconds=microseconds,
                              leapdays=self.leapdays, year=self.year,
                              month=self.month, day=self.day,
                              weekday=self.weekday, hour=self.hour,
                              minute=self.minute, second=self.second,
                              microsecond=self.microsecond)

    def __add__(self, other):
        if isinstance(other, relativedelta):
            return self.__class__(years=other.years + self.years,
                                 months=other.months + self.months,
                                 days=other.days + self.days,
                                 hours=other.hours + self.hours,
                                 minutes=other.minutes + self.minutes,
                                 seconds=other.seconds + self.seconds,
                                 microseconds=(other.microseconds +
                                               self.microseconds),
                                 leapdays=other.leapdays or self.leapdays,
                                 year=(other.year if other.year is not None
                                       else self.year),
                                 month=(other.month if other.month is not None
                                        else self.month),
                                 day=(other.day if other.day is not None
                                      else self.day),
                                 weekday=(other.weekday if other.weekday is not None
                                          else self.weekday),
                                 hour=(other.hour if other.hour is not None
                                       else self.hour),
                                 minute=(other.minute if other.minute is not None
                                         else self.minute),
                                 second=(other.second if other.second is not None
                                         else self.second),
                                 microsecond=(other.microsecond if other.microsecond
                                              is not None else
                                              self.microsecond))
        if isinstance(other, datetime.timedelta):
            return self.__class__(years=self.years,
                                  months=self.months,
                                  days=self.days + other.days,
                                  hours=self.hours,
                                  minutes=self.minutes,
                                  seconds=self.seconds + other.seconds,
                                  microseconds=self.microseconds + other.microseconds,
                                  leapdays=self.leapdays,
                                  year=self.year,
                                  month=self.month,
                                  day=self.day,
                                  weekday=self.weekday,
                                  hour=self.hour,
                                  minute=self.minute,
                                  second=self.second,
                                  microsecond=self.microsecond)
        if not isinstance(other, datetime.date):
            return NotImplemented
        elif self._has_time and not isinstance(other, datetime.datetime):
            other = datetime.datetime.fromordinal(other.toordinal())
        year = (self.year or other.year)+self.years
        month = self.month or other.month
        if self.months:
            assert 1 <= abs(self.months) <= 12
            month += self.months
            if month > 12:
                year += 1
                month -= 12
            elif month < 1:
                year -= 1
                month += 12
        day = min(calendar.monthrange(year, month)[1],
                  self.day or other.day)
        repl = {"year": year, "month": month, "day": day}
        for attr in ["hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                repl[attr] = value
        days = self.days
        if self.leapdays and month > 2 and calendar.isleap(year):
            days += self.leapdays
        ret = (other.replace(**repl)
               + datetime.timedelta(days=days,
                                    hours=self.hours,
                                    minutes=self.minutes,
                                    seconds=self.seconds,
                                    microseconds=self.microseconds))
        if self.weekday:
            weekday, nth = self.weekday.weekday, self.weekday.n or 1
            jumpdays = (abs(nth) - 1) * 7
            if nth > 0:
                jumpdays += (7 - ret.weekday() + weekday) % 7
            else:
                jumpdays += (ret.weekday() - weekday) % 7
                jumpdays *= -1
            ret += datetime.timedelta(days=jumpdays)
        return ret

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return self.__neg__().__radd__(other)

    def __sub__(self, other):
        if not isinstance(other, relativedelta):
            return NotImplemented   # In case the other object defines __rsub__
        return self.__class__(years=self.years - other.years,
                             months=self.months - other.months,
                             days=self.days - other.days,
                             hours=self.hours - other.hours,
                             minutes=self.minutes - other.minutes,
                             seconds=self.seconds - other.seconds,
                             microseconds=self.microseconds - other.microseconds,
                             leapdays=self.leapdays or other.leapdays,
                             year=(self.year if self.year is not None
                                   else other.year),
                             month=(self.month if self.month is not None else
                                    other.month),
                             day=(self.day if self.day is not None else
                                  other.day),
                             weekday=(self.weekday if self.weekday is not None else
                                      other.weekday),
                             hour=(self.hour if self.hour is not None else
                                   other.hour),
                             minute=(self.minute if self.minute is not None else
                                     other.minute),
                             second=(self.second if self.second is not None else
                                     other.second),
                             microsecond=(self.microsecond if self.microsecond
                                          is not None else
                                          other.microsecond))

    def __abs__(self):
        return self.__class__(years=abs(self.years),
                              months=abs(self.months),
                              days=abs(self.days),
                              hours=abs(self.hours),
                              minutes=abs(self.minutes),
                              seconds=abs(self.seconds),
                              microseconds=abs(self.microseconds),
                              leapdays=self.leapdays,
                              year=self.year,
                              month=self.month,
                              day=self.day,
                              weekday=self.weekday,
                              hour=self.hour,
                              minute=self.minute,
                              second=self.second,
                              microsecond=self.microsecond)

    def __neg__(self):
        return self.__class__(years=-self.years,
                             months=-self.months,
                             days=-self.days,
                             hours=-self.hours,
                             minutes=-self.minutes,
                             seconds=-self.seconds,
                             microseconds=-self.microseconds,
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    def __bool__(self):
        return not (not self.years and
                    not self.months and
                    not self.days and
                    not self.hours and
                    not self.minutes and
                    not self.seconds and
                    not self.microseconds and
                    not self.leapdays and
                    self.year is None and
                    self.month is None and
                    self.day is None and
                    self.weekday is None and
                    self.hour is None and
                    self.minute is None and
                    self.second is None and
                    self.microsecond is None)
    # Compatibility with Python 2.x
    __nonzero__ = __bool__

    def __mul__(self, other):
        try:
            f = float(other)
        except TypeError:
            return NotImplemented

        return self.__class__(years=int(self.years * f),
                             months=int(self.months * f),
                             days=int(self.days * f),
                             hours=int(self.hours * f),
                             minutes=int(self.minutes * f),
                             seconds=int(self.seconds * f),
                             microseconds=int(self.microseconds * f),
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    __rmul__ = __mul__

    def __eq__(self, other):
        if not isinstance(other, relativedelta):
            return NotImplemented
        if self.weekday or other.weekday:
            if not self.weekday or not other.weekday:
                return False
            if self.weekday.weekday != other.weekday.weekday:
                return False
            n1, n2 = self.weekday.n, other.weekday.n
            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
                return False
        return (self.years == other.years and
                self.months == other.months and
                self.days == other.days and
                self.hours == other.hours and
                self.minutes == other.minutes and
                self.seconds == other.seconds and
                self.microseconds == other.microseconds and
                self.leapdays == other.leapdays and
                self.year == other.year and
                self.month == other.month and
                self.day == other.day and
                self.hour == other.hour and
                self.minute == other.minute and
                self.second == other.second and
                self.microsecond == other.microsecond)

    def __hash__(self):
        return hash((
            self.weekday,
            self.years,
            self.months,
            self.days,
            self.hours,
            self.minutes,
            self.seconds,
            self.microseconds,
            self.leapdays,
            self.year,
            self.month,
            self.day,
            self.hour,
            self.minute,
            self.second,
            self.microsecond,
        ))

    def __ne__(self, other):
        return not self.__eq__(other)

    def __div__(self, other):
        try:
            reciprocal = 1 / float(other)
        except TypeError:
            return NotImplemented

        return self.__mul__(reciprocal)

    __truediv__ = __div__

    def __repr__(self):
        l = []
        for attr in ["years", "months", "days", "leapdays",
                     "hours", "minutes", "seconds", "microseconds"]:
            value = getattr(self, attr)
            if value:
                l.append("{attr}={value:+g}".format(attr=attr, value=value))
        for attr in ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                l.append("{attr}={value}".format(attr=attr, value=repr(value)))
        return "{classname}({attrs})".format(classname=self.__class__.__name__,
                                             attrs=", ".join(l))


def _sign(x):
    return int(copysign(1, x))

# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from datetime import datetime, time


def today(tzinfo=None):
    """
    Returns a :py:class:`datetime` representing the current day at midnight

    :param tzinfo:
        The time zone to attach (also used to determine the current day).

    :return:
        A :py:class:`datetime.datetime` object representing the current day
        at midnight.
    """

    dt = datetime.now(tzinfo)
    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))


def default_tzinfo(dt, tzinfo):
    """
    Sets the the ``tzinfo`` parameter on naive datetimes only

    This is useful for example when you are provided a datetime that may have
    either an implicit or explicit time zone, such as when parsing a time zone
    string.

    .. doctest::

        >>> from dateutil.tz import tzoffset
        >>> from dateutil.parser import parse
        >>> from dateutil.utils import default_tzinfo
        >>> dflt_tz = tzoffset("EST", -18000)
        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
        2014-01-01 12:30:00+00:00
        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
        2014-01-01 12:30:00-05:00

    :param dt:
        The datetime on which to replace the time zone

    :param tzinfo:
        The :py:class:`datetime.tzinfo` subclass instance to assign to
        ``dt`` if (and only if) it is naive.

    :return:
        Returns an aware :py:class:`datetime.datetime`.
    """
    if dt.tzinfo is not None:
        return dt
    else:
        return dt.replace(tzinfo=tzinfo)


def within_delta(dt1, dt2, delta):
    """
    Useful for comparing two datetimes that may a negilible difference
    to be considered equal.
    """
    delta = abs(delta)
    difference = dt1 - dt2
    return -delta <= difference <= delta
# tzwin has moved to dateutil.tz.win
from .tz.win import *
"""
Common code used in multiple modules.
"""


class weekday(object):
    __slots__ = ["weekday", "n"]

    def __init__(self, weekday, n=None):
        self.weekday = weekday
        self.n = n

    def __call__(self, n):
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n)

    def __eq__(self, other):
        try:
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __hash__(self):
        return hash((
          self.weekday,
          self.n,
        ))

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
        if not self.n:
            return s
        else:
            return "%s(%+d)" % (s, self.n)

# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
"""
This module offers a generic easter computing method for any given year, using
Western, Orthodox or Julian algorithms.
"""

import datetime

__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]

EASTER_JULIAN = 1
EASTER_ORTHODOX = 2
EASTER_WESTERN = 3


def easter(year, method=EASTER_WESTERN):
    """
    This method was ported from the work done by GM Arts,
    on top of the algorithm by Claus Tondering, which was
    based in part on the algorithm of Ouding (1940), as
    quoted in "Explanatory Supplement to the Astronomical
    Almanac", P.  Kenneth Seidelmann, editor.

    This algorithm implements three different easter
    calculation methods:

    1 - Original calculation in Julian calendar, valid in
        dates after 326 AD
    2 - Original method, with date converted to Gregorian
        calendar, valid in years 1583 to 4099
    3 - Revised method, in Gregorian calendar, valid in
        years 1583 to 4099 as well

    These methods are represented by the constants:

    * ``EASTER_JULIAN   = 1``
    * ``EASTER_ORTHODOX = 2``
    * ``EASTER_WESTERN  = 3``

    The default method is method 3.

    More about the algorithm may be found at:

    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_

    and

    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_

    """

    if not (1 <= method <= 3):
        raise ValueError("invalid method")

    # g - Golden year - 1
    # c - Century
    # h - (23 - Epact) mod 30
    # i - Number of days from March 21 to Paschal Full Moon
    # j - Weekday for PFM (0=Sunday, etc)
    # p - Number of days from March 21 to Sunday on or before PFM
    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
    # e - Extra days to add for method 2 (converting Julian
    #     date to Gregorian date)

    y = year
    g = y % 19
    e = 0
    if method < 3:
        # Old method
        i = (19*g + 15) % 30
        j = (y + y//4 + i) % 7
        if method == 2:
            # Extra dates to convert Julian to Gregorian date
            e = 10
            if y > 1600:
                e = e + y//100 - 16 - (y//100 - 16)//4
    else:
        # New method
        c = y//100
        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30
        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))
        j = (y + y//4 + i + 2 - c + c//4) % 7

    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
    # (later dates apply to method 2, although 23 May never actually occurs)
    p = i - j + e
    d = 1 + (p + 27 + (p + 6)//40) % 31
    m = 3 + (p + 26)//30
    return datetime.date(int(y), int(m), int(d))
# -*- coding: utf-8 -*-
try:
    from ._version import version as __version__
except ImportError:
    __version__ = 'unknown'

__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',
           'utils', 'zoneinfo']
import logging
import os
import tempfile
import shutil
import json
from subprocess import check_call
from tarfile import TarFile

from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME


def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*

    filename is the timezone tarball from ``ftp.iana.org/tz``.

    """
    tmpdir = tempfile.mkdtemp()
    zonedir = os.path.join(tmpdir, "zoneinfo")
    moduledir = os.path.dirname(__file__)
    try:
        with TarFile.open(filename) as tf:
            for name in zonegroups:
                tf.extract(name, tmpdir)
            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
            try:
                check_call(["zic", "-d", zonedir] + filepaths)
            except OSError as e:
                _print_on_nosuchfile(e)
                raise
        # write metadata file
        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
            json.dump(metadata, f, indent=4, sort_keys=True)
        target = os.path.join(moduledir, ZONEFILENAME)
        with TarFile.open(target, "w:%s" % format) as tf:
            for entry in os.listdir(zonedir):
                entrypath = os.path.join(zonedir, entry)
                tf.add(entrypath, entry)
    finally:
        shutil.rmtree(tmpdir)


def _print_on_nosuchfile(e):
    """Print helpful troubleshooting message

    e is an exception raised by subprocess.check_call()

    """
    if e.errno == 2:
        logging.error(
            "Could not find zic. Perhaps you need to install "
            "libc-bin or some other package that provides it, "
            "or it's not in your PATH?")
1rZdateutil-zoneinfo.tar ]`5&e7Pm PB}Q*m@DPJAk m"uD?dgs~|mC#hLz7}Lx#_c
_ I1I6bxRTHM?8$~'1
IJL2~hBo}S]1Qc8~'H\?.>i~z'CV_Q	Q&~xWo76~po}M>t;|@T/@~1>~>A~QQ~X@hS`llhhsT`T90&O/_PLpLoL>Q~&@ST`pLto?66?(* _@[8t:C?*qJo?=8fDP5&'	CD?3|\?!f#1I1FO944qTE_J1x7@?}#>se>#^vyu?p'00o]u3~g#g>.u-fmNtky2qoPb_7RR?hfrurR:J=n)Sb:&UqtW/*O26Z WFujVtw*tC^V<]FJTZj5wBN2TSt&oL_.\4WoOW~.s|+NZ7VVL6%jI]CTCwCqZ]Uvi+m+bVOv^uEd-O<y/?_|P{"$3)\H~tfdU$z5W9IH)W-Y?Ji)G'zN-Zc
BC#AR.q'_qocc#?F<4y<iL2dcm<Vyi2e0#cF<yL3fg8#sF<yi3g$02F#"~02G'F#sy$02!F#sbd^12_1F#scd12@ #H\dd>22'MOO&;z~9Fz]zHHNO$c?~}s39!~M?1IwObFe+}_g#e>61u9N4W3p[b;ua;A5E5=zLp|i{oMu.>-gYwXny3a_l&$@"^c\v.q$L:^^l;7;v5l?W1;$gANo;o_e?x`EFcn[#5E.n-6M<Z"{saJ{qT+euR?W*>VzeYBu]v;]nrmv~}n|}Bl6Qey&L\\uO}py>v{g@yJRO^ph\ r"fY?#f31a {/7OIh-+0#s5-8<bd.VE|B8Bg5F8cd12CF"#9ddn22?S qed22waF1#739qyfd~32u50{: i # #k##k##kXP+$@t5B7Qc@4H ijO6XP} iRMN6,jgdQL /G~zi"
@MH;Y?756n1<V	
| |fV8M?^}czJO^ 0[/IQo3K?q
?S4^JIYJ:e	9?g/_L})$b0E*[b3?5uv|L~r}|-3_9JyLB<\{~erxo5%Orn/\0m=S.Myo+`XMW\.Bg:4S(T w`\NzGe-! M27fo=# F>@:|D0aG %dtB6;^p9':ool2_CeMem>ujt8_zUw]GR;k'>\'}6Zu}QnLi#w?4 6)%>P3r/2va
i5u]qWG5j]_V*~lV"+w.'Kv%$2)!XU 
D@F6:(AE,mtpQdbh`_>|3	`F'O7:)otb 	IbF'N47:qot"IDN$;LdtB2EN;}f4"N#	m3;;po'3_W`q5mV!/sOTNHT}eTrN]~Pua/p}OmF{5uJ^\j5<z6jZt5uM]~.{.g)][;M_Mfu[n;=~}kwZ;w_km8wgDiqNGIN7]{E8:8QK7k]*>W[.P9|m+'VM2N.a|F|]bq_}+}g3VR2
W2R~<wW9wrO(?+[\~yre$jNSt7JF7:74
\[*2TRIA.G1^2mTz2n2eloWYt\i<4]2yY(W_&R(TQ7PYCU7D{{(*^gMzoO{'mMtGd5_r@9roxoln>%Il7ZWodr3%lRe^=$Y=4}>fR-nJ{=<.2\L&}kl{@wNtN=rLzlz\%]-:LRc=aQ'y*:9@[FSYN
%(.d)9=<}t"yw?-P]'3p?xp?or<Y_WTrs.gt?A+!C|(?,h"~GFz9A4pI$,X@E
$X@E
$X@"/	%$h`K/	'EEEHBb)	0#0#1<-1#2#2#3#3ii1YQs%hAM<.8DHb$QgdaM$'(>8>8	h|  R @)0{Sp MA7xo
4MHA	7xo
(T){Sp MAx
4hSaAy
<hSa AH6	T~Eez(eqBChr])xNu
b`;44).h'_HY4Ce`EO4Ct`E&!>
~SE}.t`_Y4QhE=E P`K(Y4u`E.}u`o{3]4+^]`=hSh+u
Nw69)3rPg<#yF9CA?#F6 l0 !`dS#F6	l,0a@J#F6l"`d3$CH#F6l4l0@+t<=Nn[M>u{si\<wvG],,\&Ic6K'wm-ZRF D>L>F>T|H#?+k@;wvOVK?Z(]zm7=$5=K,t}\"Ev5ao+s-U+|7_L*lZA ;1d#&Yz+'O{X7O|r
?;TT.NSH)RM<]63f%dy,_\v`/G  %@KJ V" %ULfRL&u@bG
T)8R$n@R$nHH= a#AFJ"5@VLt=+T	)*R$R8"Z-jhf "	H +*R#$THHHP2!"uBD
$zLdR08eD&%&'DaeDM$N+$8!I$N"I\,/'Ir@	5zyL__;rl20eHKKn?PTXWO*Te jDZO+WZ#,NYGTj3g:~s'>jRh!fh</Y/\/M@<`w>v}B9`s%r9asK7~fPE%G}lo6f~90wQ}1>1':/vL-/t;YtX7vdn]{i%
r)#nkyyw|;z~I-zA\Rvw-
9|*On/[bS_KJGuJEK{Ie<Br=WkN*+WVy9]\I
Zr;5[-jBK%EJuj_Q|&Kk~aZG{T_[6W!l$7<Qj78Gj	enYZzH8zhZzcEH.Z?;EoWnh;&:UGvA[LUrR%X{P5i{TOAC2EWo?.^.Zyvu5U(*IV]*ak'oi)[>GLF9M;~>.6O>/11sp+x]2."2m]a4xz{O!b$-J[be}gbHLEz
1HE/,hFf5#7f70otDa(*Kx|qb=#3C@R [H(d9E>z]BDaiH)Fuj!aVQD>*:JA IQPO!UA=R"f       B67P"OHH	uR'QHPG!BeXSj:
)(Zr:MguxJ&(7:geux
'(sNQ&=+OQ=+ (@RBOH*IQG!uDuRIQH)~H-QG!D64%VNQH=QG!E$~Bj
$EETH:
+(BJ:
-(~:
)/(B*:JQb5^+Ve.Qbu.+ViQHQG!F%YXQG":J+8(Dx_UxRgun+VyQ
2^U_KN
*O}gn^Hxl&1Bk}Ggl*X?{Yg"O:,yYg8gup>w?Y\YD[bls0VSll
VTY=~Fsjn(Tl^smuM{%lLC|Zmvw-t=g%9_qlzEmll<ek2t>W;[>kll!MfZT,ab/:O6EsRz}\uYi`md)lsK.:<p*[=>}s^S_yg6$gT:~]=m;bor]	8tm=AwlgtOF~jSma9-oov&)I9.[;G:#m7:,	t]6njYZ&<[>Csi.Y+I6\g:>T?~g|Vl}IpP 7J|%N/FpQ(n7J|%oQ87J<BO@(
n7J%Fkp7Q(n7J%EpIQ%(qn	7J%W!WQ,(n7J%eR3(qnx7J%~FpuQ;(qnx7J% I#=!+!q^YF:7:SWQQQ8pq^YG"+	8+p7J7J:7JZ7Jz7J7J7J7J7J7J:7JZJzit	n	]='ZSpUpWpYp[p]p_papcpepgipk@6F7Q8Q9Q:Q;Q<Q=Q>Q? .\&||4jRm0pQlFuNW7_P3|$52VvmUCNt6`mmu%-}e@n?glkY'O|E_W_mEmuo{\kp_4.IfrH&4^(9rq	Z<'(8!MG,?$V-!JfLQlqD4edb5\m+}XH4@2V:(Dk$jcu XH4@:V*(<Hi{4+'Ii?D2_gtI??gubbUhW_?e+&8vgK+hK7T8;a{s.rKK|PI@jPB||kWy>w5ZqWk5WOjMg.PljjIZhjbZX?5D)"O)5pj0xI^wO)$Yru:fr^RwKV=sX}@RT]v5(Eo)&]%:jq~p]WZxbk_C}IS'OU8"%R7(%l(?GJw% kJ9%\5ib-?6.)%J/]lloH6=v'1gsWFa5+CB
5(44KC.AC3{iib!C E\-#GCRL|IM_bKIL|/bBY1.<0_xub[Rbk.1ELh!-&	M<12ILxK<CxXLhb
	ML;bBS8EcjG	MLxfbBSX2:&<0DLhbJOZbBS8B*<-!&41W& <>1RLhbJODOx`(<p1
@Lhb"*bBSH4&*"[0Dox?yz`VA?Fu=X/eJz87vx/hyK}-%a5ia7yk~N,U[nY
jd3)#|D4
Znk_z=z-$^N3umfm)BiRMtMs}djO_2=COXV:k]<S;J`6rw
Wb=(HG]nD<fOe

Cq+8'vJFkRFyH`$4Q=eX@	_|]	_#Y8yDW]6nL[b8ra:e:D<;#	<]6L:$ane&	w,sA!lq2$/[+/k:pbq:>L6$l-s5IH\i\V6u35af	]_&6
q:a83TFq:pbqCeq90WurvC6`4?/g|]V%Z KiWa*t8BZ>Czi/LX+lrG]9|.QR3.K+GvEV,WwJQs;""Ar@lNzeW
6*}vKQe1]IT}~^KrJVZ*/^urQ\?Fzs4G7>qo(k~aI|zG%7CoV;g[*m5oXnmWeFIK!-#e<>zV?[^m98Po;m6z^#zFbC#U=n%K7znt_Z${LOJd[F~FztFLXw=$#+_I_n<@4#F(ISVvRBJ.*II
f|Rve1$}qi>	%Q--FhkdZ_smYs=0rTRTvG_]=Mfc]#<y>_YIL5*kQ1#qab%.:LE01&?:kd[X\X$^\#kdqLfL Fc4A4wfc(]x`f=gR FVL-<0iU4>4*ijiAif`z&qNx`VL e4RLX-<0Fx`V6fBiHDnS^Jm	$rYDn#<0m"b]6!rYDn#<0m|t<$!!#!CnCJ)rR=6|mHHmH	iHmH:"!DnC*%rRL6mH9z"!EnC*HjHH,rRZ6mHq"!EnC0rRb 1rRd 2rRf 3rRh6s_Y|eFnC^fk.|6FE=yl)(g@ |]8q|2w)8O{7UO/<nme
P,{;W*lVqhWye,VyMQ[U;uVoUfe_@?`:]Cc_V=>hBWxBVQY\[\."H`:6wH| !v5G
hCGeXG_"I://|TKBG_NH#AG<.}]:O,z9%g}k=2j`so_c+X&mgNDx/VWo.}z>{y{^,p_y?[sZEQ	OC>|s7&C[;Uy,:S8~D\s+febT+BQ_
xQ.N f{/}u_XK{[E
z,oYj9Vp[.wd[!j#EqjLt:Oq,z{mg/W2^\ey*-fsUm\KSy\sSgo77UQ	[zXN^rB>
0gvzzv!g|D=M*w bK?
~;zRr<u?9t,;vuL Plb?V=R:z~ytrnjWNmie>g;ex<22;
}Y^ltVzQy[VkuVWz[k0jJM
]t:xq~f*:curw{'|Qg}G@mWYR?r6p\T.ik66VL|Am:v2<Pmf]hku)$0);I-/w]^W#vZmj-oMOY4w58BQlSGK"j&hJy}u^cM^slR5{\}5e]C[8w]1Ci/W)I;}FpU6YG!/N$ha^cn"%w(^JKM#=.)Y4f<ui^WyG IU1jx'
k'} ;;C<q^q
!qW^2L]l[K|.H9`;L&bH\-&>kg^IOl_/d*:WttoI&Lb%12HKFx"^xHFJ'qN9NqN;*yT:ttY=/FSKN-:5>SKN-:~tjI3PI%@%TtjIC# IOYe]AZtjIc5Bstj9ZsaAZ tjI%-S{Ae]7YFOFgD:N	:Yn=R1&B4!cd-CHm)X.k:GZN-:ySKN-:-Y%-D5ZE i###:NSKZN-%:nSKN-':SKZ-),i*:@VthI_SKZN--:3Xw%EW_`wonO|'/ggC+7x\c%n\^,E~b/6^"UZ+${cvz-,u\54Aft4?5G<W=<0s.Ag]67P,o<&ckZwZC|~9vcn6Ok;emxd[{&uh=$ckia\.R.w5sw*{zZzGH,uizT+~fgx:%c
s',<.s[\b /|CMO~!mhyXhkuLO*{8mD#n6'glHyiZ&66zib7c_ }V'm|	Q}<y=7q3V/5sHnL@~A(F^hDBH#5EF)j04R ii	'HNF0 b8Ap4qlhD	'HNF8 rF@p4i	'H$	p8Ab 1N'H#S-pz8=b1NG#Mpz(8=b/1NGipz68=bNG#pzF8=b$N	G#\T8=b+1NXG#pzd8=b31NXG#vL@b:G#HHH	HHtE{#&O4l6mcreZ
|+9{_&vpN/Jyh7$[5P-VZ|5K;RvMaB38=]:2cob^7U3[8|mhQU9zdrt#oV/t5{r_+nRTg<ld*Xsws?6}Rppq#ri5qe$NSfuVWn6nVur{q')Tyd{G<!2W\g	~ gNlh'1mm0I'bt1N2	<*<t4 D
4P'
<i`IO {4HP'lNA
4x4PA'&Q<P'.>iIOh(|`C
4P'><i b{y@XBCSBi@b	Jypbyf~8n<P<Vl3O64p<^lF @n4ho3h4oC#{crBm-3_b|wNhj>4K;\
i.f,>v/\PTx{|g3mdi?Vye{0d"imi{^7dfqPsO7j7,y+|zwN]|ww{[-`nkr8wB4gi{&-oX|Anx\0_g|Ys<
6:x3L(/B"5dxNLp
F>Zy]6RDg:tjm")FhKZk\D4m-@ahKCAD@ahKC-D[&4Tmi AhKC-%D[N4miX!BhKC-5D[n4mi!C!hK"-GlJCD(#SFD',l[ThiJCXY=eLh:(P<Q,abYmwl%$? ?}_sIW>sOs7Ck?l%Y?t~'?_xr39'dy|o2e+u02{c9Ow14,iS>,]WY|@)]me)?l0FSL7*:qZXCYgFZ1>QR6l:U_;k
g)3GS6JB+sOekm4.]Kzfw}]+%}G?;{K{+{D8|[fKo[9-s7Np$"uoaLe
^JsFB)^T\drqm{+y+QzSb)M9}MmnUxuSZ+
6P^VXQ)(V
W]B&FJa'Fv((xUTziV.lzWnb^K>*WUrDuZ
=j=^t?^_Qw&4un:[C}DM\#5(w!T#&
oQrdnzE}M&7[b&[C+-jCC-n+]:#G}&GN[}zGrm_&[:_o [M;t}Y88F4Xlw.NRKrw+RvcOzr/{krvq~M{+4^XU{z|(}H}!/5uae>[]JOvSS_.G.}s}9Q	M|x3O?;ozVTl=aq>IG?gK5|yKq_ak	Zw-6,*hK6,,#k-#-r .#k/#/#k0tHz+FcIil8IZ'I$i66$b!7XH+cIr 96$MN^cIwl8I'I$i=6$ptNc)=Mq@9 )& NqihOS|@{b'X4 )npNs(S{{KPHx/W~mM15):m[SA!
PH8B:")N1	tKh[SlR|B!b
PHXB:+)fNqt](SB!b#mke)=Hb#mku)Nqr}(SCb 
9WLW9G)F2rPdx1;9~2re8)#T UF_92reXc.#]F93rfXc22#f gF9V3rfqb7X18#rF9)3r|Rg8=#|F93`d^ #{!_yH' +0_`d#F#K0`dOON# yFC%2)dI}#{FA0ad?}	#{F'Q 3ff^?Q\<#F._0ad/~=#F6oad$~H}#{F?E^csC>	^P_yPx?>AA9^?d~NVOuP'}VSX|XP]O%SZB||=_S_g7-P@04J
dk*,k.@>T{WTJ+~N-SiTq-
mQ-4n_c?N|]78oql{m;rZk.feTz6].4t9uUS2jNw\v#pPV|n
vv^o>NtQ=QIuR[g/+ZjK%).=Bg
L+G-uG.9S+;j	JJ{N+c*s;\**wlVF
[$U4_}W-NSfRFVoH5y5kvj5B7E'ZmiM:P~<\)Wi4o4guoKAmAX6xpFcmamVf;iCgh{>s5xngVn>&jn6o[;0;;-tt-x -	2kVP\8?Ym?8iicu41?^w'^2\9$^7}>nO|'o;p=N!}>q	nO[@>qnxO\'as{qOcd"+ '/X"n/6qH<EV@\EV@|EV@EV!sq83 CISbno":8x`GV@GVNy? d
H@M@V@ X#@d
>Y$d%HO  ]A6@,5H:,Hzl4 d?H! -B6@zl4	 &x'dQ@)F* ,d[H~Icpe@3 ittM$lOax@Sc/cfKYoYW%u`aMC;kXwnoe!h![^,p;Nji|e=Kz5os|/K[
(XcwX]-G&[[n`/jU7R9G>;|^4v^BKG3Mx:*exQiEKU^W,J k-B:8RfZ^vx9e>8ld~3S=>q]99-X}S[v:g;,w4hbDGXtXb{:B[XCMs(c;vh1kCmvp}qG:vhTqak
?F9d0kn<~=G=Ou>>c}ZX7?5H/kLXUk&87k.5~Yn3fTvcHHXchSt$^j# G/'?hM2:f1[om&[g05~<Y25
`,l[#s]dw.?`RO\DJ/Y@'<+qH<7%_1g89+8@1"q^HW$^+2 ~8@<W$
)"q^xBW$# IDkfUT	|> {xExZcAtHzHHHHHH:HZHzHHX]\^4^tHZHz
2i"i""i""i"i""i"q@2Q95MTYDXq"qCT{Y}kIEe2|62L0i$*V2Lz	oH	~nI;Q&"L:
$-EeaTTIWQ&mEeaXTIgQ&Eex58gk/*@`T=IQ&]FeagTIQ^!,`Fe GmTIQ&|d|d=n|d]Gex#;*YQ&G^_|w  N';gGP@o@F?4jxRLbs)?Sva
2_Xa{{Yq;]v)xjV{nKD[g_{Nj&-"mrj%-?~KY0Rl*<x[&l&lHeUJR*{{"g[iNE6|*r6n*r	n&lwL04K>5zqdv7>^g_{3O5iS,>CS}mLB-LE,Ab|tp{{w/lo2pK{N_6oijH%_KYe	v9)J%bPS,6+Xnojg}~Tk#cu~tYkSGCSM3nS_$mUv68h[-SjlZeR"u;,~J8eSGIfJ]|*^ZoJ6x49>"|iM>3SG.kU|TecYm:.e*jY?gi,h|)|lpsz.4_CQH z0}3>[EBD<B\BRKH)Xr$r$r$r$H=HCD,,9q99q99q99q8HD\#1gHGr$#9q8HD~$G"?##yJ{H}#}"GZ"Gz	YD4Y H##N5L"GjH7PG'@nD$AD:9	r$H+H[# G"A=ttrIs;J{ iCHC!"MBR	9ir()PUHCf!n1vI+I3!g"=CDt9ir&7LqH3I3I0HY4@ALH3&"g"]DD9i$r&IL-%r&L &i'p'k(ti)9i*r&ULH_3"g"bQuoD?kHM5S[m@e24!)>!&!)ilG/G?^|)^:_fO3r-ITj-a5^/muggn~9or{e =p>:!~L"9!?5*medbE
q+OXqB/Ha~s+>XA5V|!7V~EnqH|G_8/J0\('rr^.'7g_$_$'D%DEG=_I'&<?S@cCv/'d6V7Gi;z/_\ W.<\*"R)$
TV+XV);@/p^q_ig+oU:J7Q<*lIUjQ{q^'lYi?^7Mj=~az;wxtQ}3f\1l>[^	sVnvQjY&6zU=n4Do~0B[CW,_D,GNn={@v{43u7:&zW.]N7PU"w~Jk^J-3>+}mmOQSFETc;%7bwVc63A`J%[9%KG&jZEil$[GYf|}i;>3=Cw{}~~~FfjXK#uP3LM#mI9lo1|NsD T339riQ(crft_d33Ffs|gY	'w_j38Q	cP-?%+Lh\1qX
?v\/kr>{g_5}Ct(8[D/.yPh(7dg?,3By"sv+jsFv\S
C+(OP.	)W'($R~	^Ay&rMx
9w+(WP	^Ay(|rshssh871\sbm\sbm\sbm\sb1y~ae5
gkk)19N},C{EIsh5
 R/	W`NNd&\>A Aa5c!pCxa
!S'%+O0#v2`NK`;c${a=c,'b3&`s"v3aN;0MSjbN%v0N	 Z9|`&A9x'psjv0aNmv0aNmv2aNsS{;	06;	06;	0R	w0{VZ7`k22nh}A'62(C-x\@
r`u}EJwMWV{ZU{]Z]wWW.k0~{],nXjeW^83jMtF\c/{;u:%REee:}`lzntc]'u1A3 A}}o|g;5VXq`qWu+&30=6+
#o"l"m"!o;R+2d1QBOwI")9Dcr659DwO^;8{i=M9s<*J+;Pc4+jKgDw_lwDNH9rf+&zgM3"g6DlwD91rfk&zM3$g6Hvo;I"d6`	#!AC)'&&'&:6Eg<]s3/{|ssu&g3eK-k6l]nxU#7ks#5+M3vOg~g@Kx{(Z8/r`o-G(?,=mV+Gf?N~87|7oo:d^KS's7T9<w/n85pxr+Gdfbn[,:hu0)!f3[K
[+V-U*SyQ	cO].z	1
ea s
Rx!%.;M<8^f2HF~s"]Pq^!j?+dA	uPFB~&jO%k$4BFB%8INn!H( `9ZrR%'15o@5j2n\B9t8q\3v((S0!xBEY(2
LW80ZuQS,PW=eT,EeT,MjhP[NZ>vde kQrC=
,{zI-x{D/?7tE?mlg\sWJNwgh%;lm-}wv0iz7C31ne_r:nWfOEXZ2"	?,^3mXvOq/_V~t+?>q~ae+~&|P6'G	[lmWn.{{nwKw&f%yw`JH=N$~J_-Wd#GWf\Ve%]L82s&M=609C?|K'nK0Ohsj_9rd[Y&'Y>R>[iBi'2%	ez)3BxCQ	-[a=VgW~idDfxr}MZdN~Uvsmn9Z*	R	+'!tPk*oO'8~q)Yv0cfYSca	{,A{fd4_zO&hTrI3\}{,rQE|%9c'7+X\:<r{Z-}7{\qS{S2NM;ftpur7N=<{<rr3{{io>z&NHs2[kYw~yo]s[SfH7gjI	x%$WMr7a	iKy'S/g,3riVvzsfOsF=yx3$d_mHGNtLk;',a{VK4 ;y\p6O.U}xLU}{<.x\A\QFUn}A8w}73p\{O)OzH2aa8C3a8C#a8B1KBw928AK$sX!pY6 g@-e at@-]m:vK[ @8.\u LGuA.A8/	zNKw0_ t'HWt%Hz &R(6BAA
PPj(T/D!T;D!j/;P$yPtOBB 
5ruF
5P(@JD=LPH5
EVPr5	
^8J	P(xP b
Er!^($@B18
E
El(sPBQ/
El(erpn6&G5N
sPP(TDbIWP(f&@xbT
l(=P(PB#
'
ET6(UPTkPPBQE~QQ&Jz*
TQ(Bx;
*/,`zB
cP(=P(Bn2P
EF{P$e@".
Ed(k5Xy~P(5nQ(~Cx8@5rTPk
;;{P,B
(PBJB1
P(Bd~P({Pk^@f@E	P(
Eu(~B\yb\z
2y
l(Y9P(fC0sPBqoP(xP$%@B b
E($P(&P(yPPk(erPd5[Pr(fCX"Yy=bJ
+mP _yk(W^@k^8K	"-8"7JL;2cPG?b.b%S:;e{07?>}b<B>/XYq\y'*h8QrF)iQu0)~=b?GJzT'uRhTO[k7p\&ZBWo]NXFugfM)K:}>u.^huNAhZo4E7iz&{M'YzDT%rzTP%	=&,A7+Pq]-9b^c7?5/m>3'wh@uJ|DZt8%3y8q6zigS3
WhFRzoou~yh=a+HY3h2ppZ7A_77R)2p=uH+SYO[>|N_eD#=H2:;s22^3sw=zp"SkB>q}=+[;~k0O5:oq
J4R2Ai8%E&RSX)Mo8xo^ZsPcuSX: c0rT<8ALt>
@c0rch@Fnh0$@:v@C5 c0$HU`t#@ya1MFAc0 $(
@$'t4
 h7,0 <@B4C
 q,0   )tW` x:qc(&#C@7@c6:XS#C#0`dDh7F J
: @R1/2:X:EZ1/2xtc}4+9@`1A`:Ej1+C6t:|e(C2xo!fk`/?X4oldp_\-xjNoeg/m?%i4^}aYo^|eW+_^]T]aWKI|eO^O.X]fX%mU.-{J|m4`e]e7u)5S?iMhk>L}T>@[CiK>/6;P qKQy/jPvt5\9#Y'jnQwOj}&uo{olG?i>M+mRXQP|Cq\h	Ok?|zYTn,:yk:>][jo9%gWjyjIVc;25jYZ9exN
[*SJZ_Vj]5#zBuMZ]_Cj+X5(oW@!?h5vRC7jZkZTga,NvaKc:?jp  yfVZMiZjI]4jjDj9]	kdFfTjl`7?vmVKkWV[S'?Ovhu^xt>b[vCu.OnvkvyT{jWzOQ-)e5w_bErO]a5<8&>\>G&W7US]o>-:|N{G;3CK7Y}lm
kTeNk>eQ3sWzNpVkwR'NJYYK46yCsznkKwN	sET-6YdK4k	(
#`F(, RX0J!M	0YK)S% f-4k	HYK`*ZTiJU%f-4k	hYK`+ZB[xIK[h4k	IK`,MZdi(KY%&-4i	IK`-MZlih%.=% .Xr`1.P 1.>R1.<=344cU{flST_a\<DE36F3qr#rM0f
~R@3v#?f\90fx~RaA3Vq44cY`^~RA3?hRfl?khh'&}
?M_O'0`I?Om~R/o7P=dWC44ch'@5e*{8 #ZQP.`k`,0
`]4j*fI]odg`m?`X`l5h`-5* ?So/Z``m-6]Vk`uTD
TC3v
{TYlh{_loW`#,67
?GOTk`MU[5TVGUZW*#B3+/4`,+/< GB+/L;i`\\
%/
/7"E2Y8>x3B}hk>W/{W}rlvyXjocn[v{{\}K5A9cfM[=MXmi{[9:Vkp>w:?}4}~,bK'R8q&#oe#4(UK-[~p\9^rPyC:z_=.{8VG1z=9{.vXM:zu+;{<@q7=.{8NGcGCE@:z:z~gunuh:U[T7=AiT#.On%Nw{usUkcZz>KI1+okQ92}T>y= *m5q>hmp"}HmZrizJ|k-zjXm-u}g=L	-mIc}os:QlDnT=ot;#HB_m6>k>]gwt&N6i@_}J=E(yF8nyl%.
qQrx	060:/@>`|yzc9w8AXrr-!!72vKD0:MFk`|`|50:_W[rE`|pH6ua [ku`;6"y~30:[fA5q~!EA?~,C[6V-kkz~cZ<_(sVwD#Mz~rpv^_;N/f:
kez~mG~-{q_kA]z_z_z_z_%m*TBJR sai`nt07vvZs;FJ%VZ*5%mmvFs-n_K%
kTuFJ[c-sk seoZ*q`n[.u`n[.y`n[.}`n[.`n[.`n}u0J#X&J&mA#3.P5k*.oG^1j5+W3s-s-+|zN-n{h/oz=Zr8Cytt&q-{i]4G&qkHfUn+^[uU[]Su~_o3? Gxt[?RcGZ-v
lE>+ecr[NXcsVw]9#cY=N={k[]]-/X7l:,+pdgx?8Sa7'z7)-K&]'OtNil[YH1JLbFJTPKy6zJ7e\ox:9l5)oS+ly<PO*3P7pZIknUum\^X\_vUO#vzB75Sk_9sSUw1oZ:_u0%Bmh;WmAQ[<oS,tRk5+}'&4+o,wk~`fZ-G\T;}v(O<vxI+>G ~DS@<}us'qj7xYj9^W}[5)iO%,oo~yOn]-wb$wAo@z'05%OjjMz(yilK61U2dmP3d.WW5[psx&NRLR<GOAE5? W\qS
WTRnK~[^:v`	`W`we^/z	K@[S{D!d	] NkJXJ r)^OJ@Tz%0^/z	TK*=^W~*%H+^]JWz	KXz/f8K$	VP=/PVZP<iA"0"06 n
@
*$U( q( 7P {k[``%"7R1 _gamV =TpgxPAwn=*zi(MT(]P:[PP[P*T"=\") E`AF*7<PPxF/q*PP2PZP(}-(-P[PBPjXP3(;-l=*z;=PrU({U(yG(_ZPiA/ E`zTPU4@BE6M(U(!(,pz|"P"`C-z\D7# E y.P"E y.P%nB	x[*P&wKJ J@ U((PxbC(7Pr<PD7zwKEJ@	n% u(/ZPP^P
%fa" J@Wni1 %	z(P>@	hlA	& %%`] =\+/ _y %ni% 	(W^T@	@J PRXt/HF+mDoz!"'PSVD+3VVk<H;z{?Ju8UAVc**5x=ZO|u2|*OkWlwF0eNC7P`w
vWq??}>'yN8p*~1d^F"89A/pzs%^0 	N8 xH/H/p zA*k^zaeK/y5/X[^t/0)QG5u	RGr'kH\[tm~o~ru<vk9O8'Weuu!}'0O,:{?5ksF}a0%U|YG*l8jW5i6p]lbu5KhFuJsFvExVlWVkuf7?r7hv{q?1uj+:u>P_:d{R\=C]5zL[quC.~p@\v	:Fdu4u93%+eCZ;W[::G|[#KoQoe3{w_5uses	{gw\8xy[\<<wQ,?\f|8[f"s7}]GB}w.'kG}C}D}B}u?B}kNNd{-O	Q&{s"g5'DJ*($RrE	&L,J4l*zaiQ
6R"E(%hZiQbJMT"%h[iQE	+%hZiQE	,%hZiQ2E	-:-8hNt9EM_4-3 :D"`MA1?1<iDikhZ75
43@+2J5hY8	ti},>^k!hZc0\3(A:	r M\3XA!M\3xABfu\3E&4r7B>L)^uT(81I?_nG1(TtDT^$2LH}Cqso28UT@!rlRgx%8Go)'C'7N8<tfzam:6z0k*+;r62*a\M=zu6"$SxuD XG_8#:dbE:uCN#5XGx#`*N/2XG[ z//<8n t#?|3uW`=6|Xn4Q4!an1Q.F?CFy<P ++u<vgk=?j{OS';wzwwW#S?uJ-'z$xN|}2pKU5#:y{	dO%W2,w]:
"3?|
48?Yzat`z_
X3(A 	8rc&^\:~8=f C7@x
F0^	_?FE[?:%e!wr}//KAw*dGtDE{%;smxxW:,G)?1!0""Z3hHb?&:*,28Lv654>y`GoQ_?G_bl`'5`mk~'u1i{pwVY{_Xc>sK}df`Sv>4`G_*{vflvfkvkvNrnjenou%9]]]]y]qi]aY]QI]A9]1)]!]	]]]]]]]]]y]qi]aY]QI]A9]1)]!]	]]]]ubg_vF% k$ XT7QQ3~ u7QUu:i6h6t1Q:m`Ngwz(GuTB$[
-
g<,={7u{3q{7'b=!6xl
P{4`4{8G3} G3#8Q##DB?	eeFC922rdtQ##%GFK592rrdQ##DBSUE"dQUD-BXe!j+ +MB^2@,1C s1T,C2A,C1-C0H-C`!Bm~ -D)! Fra] > #4Se^ e^ e_: 1_H* JUTd*D
2AA :U8CT)dAP!".R!2
"?P%HDH"CTYd V5WAk6 \u01[ 5W!AEU#~$?PeH	CrUJ RU+A5W-AXrCk !M"U5A<n*\01TU<'.U>?<H3;?\gDAeiCHKTd?:2"/ /2_?,x,'nh|Oc9Y2_{P8d	Qq|"~*|s-1gG34a-y_N<0,x`>8Y|p;4~\A#1GXW\X7U>M;y+m1wV.n/@;2s~ltwq#Sqp@+p^Ny]+9ZQ=qlg6o59)p{_wmySl?"d?/E>cUc;:^OB=+L:N=mgFOn=>
Y:>[	%
.||~#X;>sWS;{|>:|F7vI6lWL;{|>x';{|iog_=>]lOC&x<?Xi0h3yoLl\,<rcT7~:uAzxLG\2]wdbd7R!C?S{2,-K'B"&-jM8YoV}#CPO)GY6`YWAGZ^'{kc^T_bWy[/_rtjVdSO]mfjfjfkjfKj^Uc6lA7Tfififif{if[if;i>W[$z~mB>>mS,fkhfKhf+hfhomkXlVllllVllllVlllbVsl`fe^fe\u`'|nl"0&040T0*zfI KXD|"	?0T"XDEXDEXD,	!XDEXDEXDEXDvv_N,p?3sdLe lg i c\3fEXDvEXCK$krUg|E6T.Cza?T5^)TT{U^5^*TD-*TTT^WiPXPm^
#np#P@dCzIQBI*&hP&Da6jDga2AP6TT6TTP"V\D5Z%}WP`EGS\S?`!x9LQ GEFDz76"xsq)x[O?/4iQdl7+uiwH!TQx"gnI (bu%Rpi22cEiFWdw?4}E7bksQ/_+G';^g/4~I-eO_Oj'o_W3,T{U)}e<mUU{-mu\;km~fV9>>^<P*'#)']uVw/O9M;MT,j]Z.h774X?NotR?5SV:{bZ8b#?	ugs4?-jZzZo\4N}XkY}rT?GyKP|yBqBoju<oRxrxeDO,?'DzBs5V;Z^*zBm&;g'4P?=Z	j	j'TWGO(TC/p=!KDNIzBk4:v'km	c`FOhHzBCmJ'GLhIIh+$4P:zB	uJok,zBmf	'ACOP}=Ly~	y	j@O3=PzB'6zB-^'tZGO=\=!FO':zBzpR<)\Gb8{(Oiw'LOltP)&+ZVi'?Q_'OUNl0s0=c0
[[Y}
gVz0pi+ ^f
rD9%XKZZ!f!?"elFZ,B`(\'otF S><{zyJ<b|Q=%/6*P&ZSN-bo*l9_jK9fz3kT7]$kz}vWWoTYG(_H5U}^a_~v[]s~Co<j{p$W_o|GY|#}Q;W_LhwlTI_2q7u7?}G-}j^q^rON]k}}Mw0\6;U|irwC\]u4_eno3G}B{'U>cMr{kWtyr7O==kk@r{.5eCRg+fSR4-Io)8C#}]IQa1sgt232w	wOw8iIf'G@ZdSlO~K0l&}GUdX)Zzn2=nGd%QKOxW@(,jyEeb%-SJN-=[*b%,[@l9bV?--[V lqCl@lYb3n-O{ LvCl2E@lG~'?r  #" B D&E( ,%& 4|s`e>.K]& <257D7|	pDt!2Z| 2IHD$.5Dm2HAte?D& |	 <e~.M bAt2V k?.]lD$y]]~/6#D..] !vAt9e,D,?D>.K_D{] $5+D)d!k[.]N5/D\f kb.!d |b |r?DdD~.
12Wv3>^.>-8o 1?o?;f!:K<pa+Gu_G}_e"<<_N+d;W_a%J>uU~U3^u_=aGUrUmu]ju}vWz*JjgnWsM}~o:3nY'}cuYNWXWay|Bq6k_s6zxCf&GM's+rL+W3&,-kqj~'gB\-}lkzQwSO9}me}f:vxt+>|3~NrvZ.Oy89_7o5*3+w}/)fm[+]/o+naY;$\Ow}?g7$~3jzL]K+L[]Es1;3F*8bwN8T=3#:_fff/|m	'3s{V&LMg H;<_PD-y\KH[m\;.\M/iMM&v.x4`4<,'8?A<hr4 m_mn|XNp>`9y4`4U7hLh#nQ. vTQ@@7@}]5\q|?az|8Av@4'h{>L>&h}> 	`@"M{]ULdz?EI!.QUY]aO2'Lx	4`	4V4~h@+4 P?a h@#,	A'Lh	p4 8xp	41,	SA2'lHT4A@:A@*8A@;Aw4:,	{fm>Lw}&hh@	0gGVlA/3_o;sRMB(30'6zy(AwM:!eRFufA9?R"q<j[guQt/VS6V8r`8rh^kMV;cf(T~nbV?k_AuZq5\o\w4RMQGRJ)shC:]{+u[uTnlSWjomm=W1qh{#FM31\K(PZV{Qbj>FWbLVj<n4?ixrh@Fim
5Cm6WRh\CP;c3->6TU:]l7)]^{Y{F#)^]ht9R<tF)Ff#]>u370o[W~Icm_(8|T:+e=73#JJeW5#u\3	o3F|8Jz)w6i1CSDR2:d6jdk	w^P|15==cLdo4{ZUv,Q8;/u2Qt>,qi3lOGqGN#J2NS#GN-QJ1fB)dM)dN)dO)e[B"S:8SZbkNQc_.PwJWB)mSJ
O),X(;PvJg)B)SjeN).\(;PvJwB)SUHa@(;APv	B	4e'xN!hO0!B(;PvB	:@#U'HP))^fheo!!=T"C({sr@k5CPuAB	$	U'8H$`I(;APv'QB	T	e'N%`K(;A/aB	$	U'8H&`M(;APv7qB		e'N'`O(;APv?B	92
U'8HaQ(;APvGB	&T
e'N)`S(;APvOB	FeUAP*TT"APuUB	^
e'NP+V(;APv]wC[Lc|86
N2'>ze#/<;:*(%(x\ipy)6-	G,GODlddP|bo?"~tJqiC|/rE_uo;blQQ1|//rLvQ7x_DdQ?1?bu;)6A?X6gh"WWSY8]m""QQbS46M`ATYw	3qui%sM`A
qWLK?Ml0 c[G8*gm%s&&E-b9k/A{&6/*n*Yu	3qG	n,,f?Mp(?_Y{)=D_xLOht	g
iEMx  #[bNK?Mx AGu.w3qG	
E-:`%Lm"bx8kc.A{&6"AXo6gm .oV?/?Xmv	3q7k TW?:8W_9k.A{&6E[:'/A{&mA_gGF3QG +(fY{)=?  #Y:9k/g AGu??8 X]?/??8 /O1u`n_+Y/G??^<GG^	rW?f<V`.X]054>ytFusccA's7T9<w/n85pxr+Gdfbn[,:hyYN(=g3[K
[+V-U*SyQ	ckF;Tymfub2/WYf5kQk	m3)u*:^wU78WBtAfFY&gMFIcMvFDc17Q^$gl>Y8g\h)%SZ|xrJ+_5W63O7?Nn{>_FF*V8;UtZ>P7gjt?ibhB[h>]LH[]IuQJ5'(jb9hlcp:HH94Lkiji-I07Iq*wf;G.S82*steLCrff=`1>k9TKs'=j24`9y^CxA+,(VP&()
O_73ID'#'GN(T98rrII#'GN8t|KR
$( %#GNH91%RrrHI#'+GNX9q9rrI#'3GNh99rrsI]"%;GNx99rsd  #G
828pdH B"G882xpd  "#	G*X82pd F"G:x82pd  #G$J828" J"G*V$hqd#G2f!@#)8r$qd.T82qd  #!GD928rd R"%GL8%xrd  #)GTX92rd Vb>W".G^92sd `#H3`)X6Nj81"ID|^%tp[Vi'?Q}^cJ*m4TIKBE. WdFq+z+}feLKf9jYhesb]sys5!XVy\ijNm)k/Iu'\IgPz3xirxXne%X`2cdsd4XE6JjQrS$u;';#YO2f6Z|CIA?iw@N^iwC*^tH?"w^?D
,BRHC!,wH].~C/%x9H)cg>q4K7Q]CtLH/bT )ycAzJqcyQ}<$4'@<GM'CW
F)P3>-|2:l?_<>.%5\,HYr_/A{6w'>'M^2j)!uA\xj !#n	wQxS:~L^,eo./_)8 <+4{MGiUMT=~6@b!*O"@.9	]9]}]|"	`y	?q?l$(u$+e9Wrs2q9s3{II'?#'om F1 G];4?%PDL?T"?@D{BQ?u(4C!PS]BD:$T0|?wP|?G|O]&o#|?NA72#?h #@2G%/S&o/&BI?|?& IG7w18WVMWX'2#?FvDBLL&M"EVC?DF~!~<=dw1#1{;jy55nYC?j5XZ_mA#<y?MX,w/|hL'/?	!Ck lp}8YL]--^[BlEc/6+WmtvZf!?kKDi=%u:4NX>M8{/j/%gA+D'@>#BzHq:Z=nHi^zsq3&8T}VIIo\)`1Vhti4HRi9M7fd^r8{iH/P6ROKpS8_Hh	bZ}
2mkc^t7Fsq$[tvvFL_{z;IN%N^dutuRsoij6#f -2JYlybuRG3ggJr;,k$V4E	ku( \$G2o$Fb4GF#G!
 5?rK%$O>	Jyb"?#Ghi$6p~Hr-D).o_)?G##B#|?(Sq"i"",]GH+G#?u(4OS]CF!F:"T \ P7"4~,38AA"?/-C$Fa#|? t}'?_#?F#S"#_--GD $I"H?
)+
++
,Ah_Qp'KDHBLLD6f{54UK5gqg_wtiOkLsk5<K-bmRG8!z;-i!3{}w?"6|,625M;r;Gvp7wiYe?yN^lcwb,,NENi&uc	wf/j~~yDan/;n/v:o	Xn; -AZpKHt:KPhuqG{hXBqn{Kbd70Kiy>;f}l;g?,3'6KjYwdi"k8e7=ykVF=fFm)IKud%XKRlh%&5$.l+N:}2yIW-e9,-u!cX&.jrkif;wF	1+b%1;y1(3t,#YYiyOku( \"Ys"}X'hwvaGF"2w[ $O>	JF#"Un"nk'455k-j[{Z/o!H?_d!J#MF	7@%&H?MH?B. Of>

5,C!Ou
nT ?u(HCa"E T%E?E#MH_,ok!+e!(?m!|?C9X7&K5n4o/r l!D$k!M( $+?l!U#MG#FQ%MK'~ZW\;^$?BBLL?F$W_}ZK0W/z50.R1>?TU9UC?'FL`C:A_uhjSF_5__pFh_i?lO|a!zW_XG9Ojz%W'PD?*_ZM!<3e_oM&[Rcm>IAC4{pTP(_N7~,x~'UO.7"lnPDk.m^uBes	;wv}~S;\}b?S??VM'I/=Mv
[A
|H{?~&\8\eR/m!YX|=g{e9n\tuvp;>=%b{%zZ=%9~V)1[FF|E&{^;?]dcV\._=kn'Pm^TW=--Z[!&"("*","."0"2"4"6"8":"<Ch}D 	!"1*Bd bt b b0HAhAaQ#M(b+ 
&65_,"-F"F"F"F"FC8D:y}!1
111"1*Bd"bt"b"4>Lo{{|U_X(':X1WHHYS*=a!Tk50aKK"n&?$<\E]}U}R({xO(gOX c}f7ka!b?)djyzLTgSR*BBJ*fsW:wM>8]bO_,Z]O<<0}y|teY<-G: Mt/-f	F[<6W8Ni;}=\4_Y,3sB_sO\sVQVRu=JG~)W4iUw,E_(X[09=yy9Px "$&(*,.02468:<>AQQQQQQ*w^&"=EzT/o@#;1fPU^?<dZB6"F3'eT{\K}?<_8ob!^)k/[%:RUYGs?
.N;2GXsRpQ6lU=`}Ge#-1J]})z5%5m#3reo


jR{<g{/]a)>5kAzw_r\V*Q07NeAGkxk&G>U+wW[F%Cr,0o>TGzbo{-p>
[_C.)WS=wdkEG
6NefzRM)8XEnN?8:Q=LzWvOtLW|3Xo=##}im))9Ual|4k4{#B,R?:dKqddoi6L__{}|Rwj=92?9Rm)$!Wa*/f,.?vnq5?3^in@_ttA#y3c--cR)NSOWQ@)TolHkkRO^%(x ~xxwuF%7({+,ru|6CCKJ*: ;ZO#}Y,_3?D
>.MSo=BDD/&D.pq89m_LelJRg:^P=oBV=9/5V^952k}}}/snm+*7srGLWFEiFy{H[F/WD{j}D'}g+g{4z>nI&b5QN%GzH76lyp|goNMzp6Y4Z{W</nNrE:*Edg}T#=Y5 sCw1}{;<(\;0h1kC?V]ZUUq'<g]}0~-x/--_h{HQ c//`"~gtdWw0Z4="F"F"F"F"F"F[,A5KlD#[,AT5KlD'[,AJlD,[QYF(fhff"A(gk0 Yga3 "	
Dd",aLAD "c5O "RkQ\b	,CD!"qu,BDd""DDf"";RDd*"50!/xkcBPZ#m[bM|`?Uk|'j?uj[Pna]G0W}sG'*
m3FlP)0g6kuon\X4gReLWtW&Yc'7Jx7kO \7V}w}> wQ{jlpoMs3jo|O(Ot#{G0lpJ<B%^ mG!|(71?$+u"E>e!O2dYcE*(_ W/C~kw<*x^j(6-

RIRrB*wF]U/P$xbV"T7Z)W6
(>m=$ w7}TvU<Oz|W_Jq?(|BPD>xDg5JhA=kvJo;)]>v]V}&TYpk'5%rKq%*M!gQn}hU}R?|5vek~j<a~-<w
pja<!HDaf2z\uDIZq4Plm?|rB~}h~5)>HpLSV?+&>|05K	W]n>te'?c}0S^Z-s.=B	?mVS/~2f57F}DDf%E&>7`i`"%--,{cX_AD!"M(Dd9DLD;2X0XRKeG&26"^>\s`&v""CYb""SLDZDd."XLflFDF#"nDd8"lGD#"YvH`?kTi&P^2P_d({
"wD`}yF`}/"5EdQMQQPP
*Jj
*JjT	!"*""*""*""*""*""*""*Kjl5*""*""*""*"3r%Fom,f%n MP|w s3s*k_m\?>\U*0]
uyvhK`)Lo[3K`. R!}Hk-5V%	K3B[+6_:KjjQUu_=J{Zkuj=J!So>_ruz?&RNp/6p[.!\L~
_e&#Sx2#Qe_xO_U-Y0CtsmdT[YJm}6TcU \^aRcWsfj57UJ0U%|O^1W<g%7UUNnZk}nhjefks_?cs=#To]C<]{>KR45`RgPkx*xQTuW|&4o7yj~;&lVyj&O*PP<z8Km.BiDKxIi(vvpOcz?W>_n;J^T;Zt/5K'+4_[BHPa`k+9Dp]3|G7^:
C?PzO\q~O%,;%lu$r9eBO~!57s3eeHcGkW")4QRN><=[kzY1F,<hP(CjJExU%k11FQ;#1	`@Dr0@vXg}t " yX252$%<n
2!	$CD!"pH:D$"	$DD"""!HND$("dED""iH^D$0"dfFDRd 6"	<y :"	GD< GD@D@D!@D1@DA@DQ@Da@Dq`"BbDP4bCMh

""
""
""
""
""
""
K@ J(LAQu&*U%fP?"'SlTUT;YS;COpA)*?jmUiW-y_Rn	o~e?]_n]2p&;>NeY+F]wRwokbYm2OGmvR&~9!sjc}amRC5nG*ospkJ|E@MMxB[n":D}x6.V`Kl8Vv%Z:$l	!f6
-.7rMmgnn=sp&`n_h
~'DDlYZ4?R?jrc g_?
f.CUi9#?)[:4bp-~TN8ckw|oen5MQ'|^xr;Kgo6HrLiB:E|.Z$	g$uzsKN_2qSQP#P|>?y{pJh}':neRCZ|o={V$m|R?F@S
7
zZ+)0|MnKtRBwm}Ori_!Bt&?X\.Wmwj60wwks?//~pqtRw	/o<N61N`BuE]6B9(O=?y\	>*F/lGx_Z|+C<p5.N!	C9%>2\ZOqQHxy0_c&~?UKGu~0 ay[tSv MIn.^Lw*?a|Q&>uf.^\:|c|FjY+cWs?2Q9n2+0{_60W3;!P	h&P
ibCD!"/x@}vH=3!EHG9RjO*bL,"R)XxtfF, f}EHwD<"GD	`} (,^A$ ,0i@Dy`2Rr2Rr$e$e!H""J""J""J""J"C$D% M(OAQJ\!d!l!t!|!<fI)|jeeA;2?4kj_D[]%dA}`(}TN; ;CfD53"& ag_lGUQ?Utg0_j/$$\^%d1?s[3G#e[F]l/K_k5&7u?^k;/~_Y?fl4)muK0(N{R=:94T:NvvR7v;;h>u3xQ	3a3OtG}W|+=v?9&9\cQr{&uu:\kI!k0k}+4
FrxrZka5kM:vk$zZZg9>kIk$j 
Z JVbkp*ZiJri%VC\Q!:HB"+=B\W<NnZ9>kiUksaO+fk	K?Td8a^/XoL(A-yL=7+I<W\{Y3Vj>gEZ]e5 /]1LW1 >.e@7,U'T*kHhX)U/U%|5v-O+'7.f]u5WweXSlBCC_T'{W+/cvWq?[zT
/5\2_eg*\[prKbPWLO"$SR*FWm?ddT	>Vn/'r?Hh
<~yw_[^>@k:J?	u
r}|Of	Nc^+k/?CU)*i6fX17n@CCxh_Hb&YgI`kx'fZu-9_z<gzr!ias\B'"]6>}~ug;nR-*;{NmkKn^{T>aql>rV=oR>LRQeol~;B94R~?~&\8|m,T|R=N6ve91WS:;Ac;(Ap=cGZ5k1BPEX]dR
[Wa+wMi";Z%{_!7Vd]5EUeuB#b0(@H@h`Q"#u@0H)ku@5b](E'.&vktXTD[.D0D2D4P8iyEK 1
1N!"1*Bd"bt2-8LIP[#X)Hz>ULm>W	Gz`3x5Xk*J-oPz]rF*xqY< >a~k+Z{]M&6YI3vn@1?CD&qIB!)b	'tT`$Jo
+6S+o Q9)3\%_Lkj%?^.n}o/epz}5]]	_oj	>2uU]xszwK!v$kUS~,z#IQrW=?>s|,c7T._n__.RbZ.K*_V	}ujT`GhZxe7c=pu7pd@5
/CB_]Rd$J="[?Wa_A<G:|WHC
:LqE:{lUIi=!+hh~_u,iws7Gkwn5}}EZ--[<k9z~6+YYv,mMZ[^:v^_;	ww6_t(.v^f	=@y[-t_G-,x%;Z[]}}b%w.3M9>q$o`7-: }Q-aowv.~*XbgNmjk+(<mDgquQ{`[{lR-q %vh?2.`8>90[EZlgG~M,:?[NL^UK=%GK]{7Zc;N-#.wBXb:Cdo{^9?2}##-3g'r}-sq|	3ZhA(-(Q- 
}7W}a#b,#b<#bL#b\#bl#b|#b#b#b3xGGGGGD "VW 'X]`p	C	'+/ xAD "GLK'D"
BDzxC"ryc	?VlpiYNN""/OD(C)8xED""eD3"ryFD~3#"yD="r:Zz5!"jCDDDDDDDDDD @[ 0ADaz:Z"V#/	)6spgSlPP-bS3m)xk?sWl'6Ei:^5f~b3j7izijf:P^2{uQ/0w8Jm!`yB@3%!(y+8

&UBxsV\].:{6}}As7{=s*8{/6G&E	}G	Q??Tb7T<;<{qAqcwoj0a	?37=.gW+jyVov>mfulW`l'n$$5cE7lg{*$3u>0O:E:%s:rVv3f/2P3v"Y_0g{7)L_n78bf`[C=6<gPYW"D=4TD[qQDsN}
N($H%E)S%KfrN]TrNh).F+9SSKS {LiqS*sj"&M%tEs"JSJi*9%frNrNfrNQ9QfrN~9\d	9{UrNf9'O39{rNqfrNurNA52SS39kd9rN9=^#im8rV]RUrVOYUrV3\UrVrVrVc
zTrVF39rV5|]89*9S.rVOvYPY"gJjtfrVcrVz
frVF 399 #
C
3-jns--8>~6lxrQG~N\{y;zo3|}u+x/Cuy)5:bvX(`TY5d+6??Nd&|07:nah#{}S6#xCID_\}7tw,NIJ]p}ox,:1>"~.?gcUAUYY7~fVf|vV"U^p^0Z=;+	5n	{~og+.)ejzXlRwf]Appl.+.L&yQ:K-9s="Z+CJUE;u}}gmos>}?*<<4?`^j]6/hX"Oo}|6 F : \a~^Wm_;24{x[?8^ZuWoxsMzE]-=~Zzzw6+O,6'nMi~F[j}97BzXh~H79HW^k]s5j?emK~+*g6Q%z3"
C!"""""z'&EM4e/OJfxy\Rh\7p_ov5"6>fUOUkJE[aWp}u^|95%--m;c\}X0mtS*|WN$xeL
'vzboJoQ)C)Y$GZ?$Mj:W\7:W:5Z=jMp$uL&;*R.i+['X..!s..r^\)jjm>h}A?O~uo=3[km%,WZe5	)<o1eYvGg)Y?#~Du2>fgf!|v6~ex3i.DEpycfYj3'4#3YuWG:>Okx/5mci9yGKfRM.i;-;?wyY?;0dchR.>wbQc9.!\&"^*C\V%.	3no9kY->V1q_Yo@/bE73jsZWuNMx~l{u#s=O_!8%<K%NK8{-grY2e]X7{dy{o3l7x:!}F$e^	loxweg-j	;[vuu=_y{O#Lw(Nh0>q_X<W]bZh F,	{7r}--v|`2-FUeB0C-Z	[!""""" """$"&"("*",Ch]#0Che4ChmDlqtlG:h}6k"HQvH`;A4 "tlG:#D"!D	"!D"FC#D[} Q=D-4R,HiI*Y\_Mp?/M#in1Wju}G41r'\Dm?V@V9K,Kc"Kd"2oi+^:M^5*P!IE}5.[hMsxH	/;/G)-<tjyZ?fpBwZw-^6RUjh\wOOp]ci%q**9zP7>Xv,&M(S1T52Xdx/8fYjCQIH=y,!CcM!L^m j,eyMSmXr,sYktvq75U[|K*I5 Xa1(mcdHi}gdKWj^g7K{awR&l<hmfs#Ol$JAs	!%_?CXQ)!\].~u\wKsN{=3\rH}92i7I9ot9R'1I1G-fZ\v}g`4$e6w=)~30fi#}RB	_g'c^~{` ] sO-4:6.&?%q5	w[%*Msf?\tl6yy)e'J/$:ny>&Le+f|
kYphG\"k3OfqNpoi`
_MZ]lQ7X(:=&w`(x;omn,DYlL@Sk XDC6HQ\Dzyj@KSSw0^ :S^c2O<5D+y8p?S?#Vd$Okj!Bt3/yjt!gyj| S6vF "+f ";00OLa<50yj`abN3ISP V1/BDv1/c,CD1O}<:jWdOP"Gy	T +jd'P]KB2Oez?"^ZY<-d6>:3hINfXb`SI?43bni-m#K`
_7~K]_-SmV?{<#''fZ'fV?C?(98PWN?#VNpkA`~4T;&yH^rNAUl~G(u<p46.XnH|,v`U8P5z6"'>?Cr<fnu=)O|'QrL@-6!GJ!RfWYPMxTCzl)X-s?q'(G~]);P`aP}KI^|;bW1b>b&y9pT!S1G2kbQ2)[T_nbTi&TrT5P1b"S13G|TofNTNb~D2K%*5P1#Q1G(*Twlbb~
{?&q2^z/q*J	g_~:F9_7.CjHC}a_KM{t2$~%02]nj0Kl[M`H\>d7v)b=@}	d<9iW#nJVCZsoe496pN2py7lRr,i#	rJ9|
>z&e!Yfm!Yg:Cw!B @X@,%XZFzah?P@@:>,X*tb(?Tu#X4c?%cy>P!"@G,-YjdSrY0E51SCT[5EHr*=gUq&sGb$yx?ZKi}%k=z=#jCz'no<A'D>0$fb?aGy?Wb=J8(iZ9~a\\qqH$CivD72n$2n4c7Q#Jd#q[%qsdJdd&a#0GHfbRM4gaT)
Y \RO3sAx1nhqp_>ma<\q7P~%&mSP.tmlP,;%q\ji|h1<C(%N_p))Y0=97t6#/h@:_;+eEI9'/f/)$;BXqJ9gi :nh :nh :nzP86!^?-u /u=8SL7)C\S!fD79"ufH7:n&Ra<NqyA799QMC5<)_:7qs:l?q:lGqN"u,H7_q3rk.f0OUk|>>7[05+t.M~*y#q5Oq	}O:q	.:>3JP>,i7g?~1pkcez8}}"no"/JljmPZ;FCyo<<CeNWeSE<h5%o^njO39rYLyp]aFC-k?:[K9z6+Yw?vxCcIG~4}F~yg^~g3sv:4[XyE4#DgCM~ao[\u%c/7tW=~sggc_:{}Yoow!ctC1S1dzO'3r4P3i^Y}sHA?'9Rkp'o|1;d:8Fn&4&.1Xb;\g_79yls|y1cmL]gp7aifgqYulUr}s:g sVn?ytedTFu<?k 
B	yPRh'KJ\5JH #G_5T]/8ku@*AD>klgfvfcD
C%o5"9<b-@>8BDn1~!"g5D"ryc??y\DD>""'/QUD+"rydt-@R_-@3C4 53@mo2B@ y@ NF ?e2Bd-r:f@>0t!
?XI2<2LsAgF%4~I?P?&9 
:C4~g?pi`vi @4~L4~I#i(t	S4~&^AL6~]4~m<i^N5j 
F*M U44~Id?xId?HwAa7P|
d,OP5d9J}oAff'WIRzOH~_)x sM$#oh|}QRz^5?['+?w}1JmMI _)/>rL<ND)`#rC2(o_5D!Xo
m9*xT:y4di 2ZR`H0
(Q#$UamQNUu[bS%Qe*-1
nKdUa4l*FT8N
=dUa4*F=TBQF 
=dUa4W{
^~*l&GUKT}5Kb0}Ua[RoU^	Wn_g<opA9:Mv<J+`lWsVUc+>r>{SZtD%VcxXEzK'%Xs*2JWH?nIW8uXN]O_I=?R7H8Vqr+[7:y`u*w5u=51&5Q>huDeiJ%(-?yKN^}\Z8&RjrhjdX=C`9Vhmw@_/u8u81`4bx
v~}}iHqZ~,Qw-1HDx tQm$#A%K$#/TV)b[RRtZNV+;l$H&+f7m;s{\O[3]I Dgd]p/d{y,o;zyy<An^WEn^AnBw6Gn^G@nNKd(7'N[NyUry*$?FNNQFy||||1o#RNw"'GTEN8AN"' '<@\`,?$DNxIj'4
gL2e2BB
&gZC)EZo(]ofk[(1Z<+>uuU!
{P/Y!f/7xYIJSU_nG?B;f6{7|
EqRC}G,U:l*t**BS.Fkl!k50%jW1E~c,!d3FI#8[X'" }jB}J(<:2x)7aK{*|&8c?BaDr5AHj']y^H' *5F_<Y^M7el*XgP7]jfJ|	>	;V?t0T>gr1qxPgE"<,NK;!fM5MaoFr t .EY#A
?qd8d&Yd,,,SAYYEGyEEYG! #, GyD@!,QE#AEAAGE9WA
#q7ddd	"Cd3d<H,2GC@#,\+pWd^""*"
"EY,  H@9G9_@iEf#{$,G#|#qd)*
H]p,G,  "
"/"!{$pA-d"qt!{pt!*Wd"Sdo"{*"7	""
"xd=A<G?"; {$0,,$!MA"<N?D!XA"TE2-d!{$,sdEE>#& #LE6E"*"6SSMY%(Mi}Q_^7DxW?7[N9W
%nvSiTR&W<qG?ka..wKFR^.?kDi[_$|s(7-wL[^:ovrG^Ei{3cocCG;t=W|M#t=lH	Zpj7G'=9mO+2D}AH)H}e$g#J/!I!I~8$x$sHsy$+g9$8$_)HH?Q$"#I|!G$Hd$oHH'HqHHqH;IHA5| {e3"=)#AS6+_ +X_(o->CXs=hTSsv"uvK]M5zwKK3)Cp,?sae[qhSDt'uuCiu7J6@:cYKM1}}|yt1*AcO~u?^r]:rW)sOn39g}i[!]IjyUi}*Wt7~J<\2-7fRT10~1WbHaj*+^sUl`]ceaZX63q`<]oXNG25!p)?s=TwKQGO=o7po	w59]JW\Zv`n\,#G\,%XpM`EW]RK,.}7,4Xpk`7S*S1`SK  , X `)$c0hwx&&\%+*\m:|`AM($'`Rh6`SFxxNc(k1<gXDzRD'*JD|pZ2@+*dJj#K!_vpZwLP> KJ4Rwid?o>>K7omu7xU4DI)fs{5{Z13?b]^>y{uAW%u:|:Ow`N8C"}
czcw~eeee`eFM~Oz[B{C{E{A{UB+%4jXf_dS1?@H19bTxcL&!)90$-;g1:S9-aiYw}5qX#2 ,)MoruM/}p [XIu})Vb?<EuPYyC<mQr*[UcEjYLUmvP	oN ybNAGINf\^_!	 .n+NYp6`uUq	Xp#J`K
,<j	F`	F9IKd=iLOGBi)~\T,(wB%v%<|eey]+7YeRu+*hRmVZ}b3~Uh6/i{'kBm+L|L0opUYQq2)!mN_QT')y*m
m m 0V6QYI8?`^['_]g')y2{xE-/+7WN5=t}?'Gi8D[ZL!cW_n\Az \$N`[4X?A|DitQv?"IMh_xSGk@A_S1ghjpwU;T((zw+,>c;OLO1~]kzV<\ZRX;IK'vnj}kyr?][sgM>peC_<k%N*_})Y9PryC>Von-=7?6;c3)arC|L]?CqQ~#\?K'rqr{_7e2#m&ackF&m{_wr@U*2\n1r_yWWbrCUV^*[kvQ\m rxK;vr)g|bsR|^h={wya[_4gUNfOmcs"Im%uo9x(lt-X2={~R53-CCO)oy>g\|%f9ayeWUO]1T8K4LVCg#;s^\X><|ox3cscRR</n+Sajy6Kd#g:gm'&XOt<?T.g@,7ys7\
?N\ww1E;|}6Wmp8*  4QK	,@T`,@X/ a`8~iXF- pG*[EVp2nQphY8eY&8%,Cx,y@<d@3@'dyF,>2nMuJ H{FgX@U<d@<d@<djq Kq Kwq K+Tq KB5
\s=`U0+9c\7s]au^	cu<92\s1`5A s `E
\;`3sg9s9W9saau>ss9y1:s1's/cuU\C/cuf\`ut\CR09:)s}s$a5s$au9Wosxpsc&93>61zkyP9k%!s.k%s-cu9s1:Kk9U<\psc39k%!sk%sm0JB,\Ys9R0z^ks{eB+'bn\+	s=V1
!s1
!s1!bx1p-oD$t#zYovworb[9r@% 2gXz+n<wF;lP[Nsvai+.}mG]{j0o~58LQS*8#PTP\P<"9""pHncT$dDQ`7*]<*x	v " T$H2ERVU)	NlbLt X_ZZF)*[_8dng/dq)C?]o==mq>c,Xs .Q/t'6fO7^x^>N6uSGtkTsK8sloe&];6	,M	cjDgH^f/Fz?5OqRoO]:z/w3sG'YH{)lp'dJios^}v^zwkQNsNjmu}9fccRrsd=+[1I``wGC,>r^kIc }QwS=	IX`Ozc])] *kXgQwOd_^K V|	/2Z%`F+h`^n`h/>Z%G+ i  _K ZKZXLhOoh'&`>?+u[~ ho5J-U~K?bw)<X5hnO9+r4V|_Job4V|G$`[4V|#;0F]Nayyw-]Kea%2]`eL<9.w0R2]02,.R0]Jyd>Nf6*59?!vIGe&S56T
@CO64?n<XUg*3g|W-	mNpk~t>tu+m>9Vrub{J{j@w"ds#,q| ne?;,fHc*.*NVQ\pCT8c + DFFFZfOa,R?ft(3_3eJ6:?z{$ff3PJAMRJJZI[}N07/yqZnLqBce*T"6#3KjE} 2
(%)v}ka(OXoy'@KkpP!'qP!)-_%pXAZIN"h(1$?`4wJYe2M))I%9?_;i?IM4S7M<jE.arGf_=BH!'||W=?#+, *j^	M8970Gd%)jw9;~m9lPO{/bN+son},P=xv$1QnV,$~o xa@bTO~~^"^Wso+0WnS3lvZn'7rY
$~:X8X?ep.bp\~,<w)<IyE.A"c}~wyygp+&;w}=3S2{4FzKsz=!0'?Bu_$iK$K
$wT.4(oT$.-6g?V6Ck&>'37~yE54h^xv[XrXN9Y9Y]"xO+E1CEapt|pDFtaRt<I^2,8kKU(X--/@yjay{_2tEESD^a!-DGf|u#?#P\m/d^GRG$&e *B?K*nt+.^[)$FD{Z;-*hRq3+S;Y_rQ3_g1?$wn;_PkJvxXz7x&xoo}{/\]v5]Xv13|qB%VHK1e+l14fdKiqK)#A?aA ;	3?6/-0/OiMXYj YS36coe.3n2s-?XXGra7$79gJlXiXYY.yx"U^az>1aJdkbc5gj7o4T`TC%T_^Y~XegAl6x!YlYw;G:RKL+ViR}%AT6 5s]4E!n-z2?znf>wf+!uie)LX)|bK/<)01lTBV1^C	vFH{Rb\'^MP'C]NZ1>O<
;^BTv,cEH&v1qqx&1kCL-%'H&i]{i1)rBrT&=Vslz&Bfc3{-$$}4g8aNilIH/nn/N$MyWDRkEzFU1Hcc<=&FGxL1qp(zBNw7DzO\umY,&0:6v,ZmGp0zgKGp&98Im;l}E63>Xpx @Xx $X@X `&%P,@X `>P )`VZ1`f%P 9`vD#! E`$X	,@X)j	T@X-x t@X1x Q*A,@X5$D{Y9X Pzs(vC|OB9XD9CBIDiPoD=gE%7a
J@&MlADAyE9AE9A)K7g7?PoD%=@-B ;Ob
^70zzQocPo<E;Pn\<+(Qof7_QoLPo:$	6JKJ59$4'8g<L6gRA{`@_Z^7~pVW>~[q1o\f`[[v[1<PvX{=9ia^[*[NU]{cm63wjp5N	jg|[Rnau[dR&fcZr37?u_:hntntB;_t~nX{k~%ArNK.jn;ld^i6%gqk=Zq]'yb]X%KO]zD$.2wmu9QEzA=}+u=|n=9Op;{wHn`cZZ~0Ohp[~utnn!;Mq-+[HfNXIWYb3-&f?z,-tcS-!zaU:4Y}C#]#sY&XvL>I29Y^<yK)o]wg8@886n'$isD8\7s <B@8{\yX_gnj/;y3zCYU/0*7|'I{<'x'CQEJ;X*b9qz.s(O(CUF~:;X/GV||7|9/| .M('2g3vzg@?PB2;=t(oXPC2^iA?2~e|e+eY2>2ee|e(D(Q_PC2~(2~e%O(YP/2_oA?2{=t(wQCe`-('Q2~e|3df13  ?QGQoG=2~eU=t(e=:-(WQfFoO6gAcFiA2?2>C2e|?e|eUeCC2#e3,(-fg,(Qo4_fA2%P3SnK0>:,YNRRGJK7&o?c}deK ?R _3 B.3M/?.\h1Wmqmv{zuy+wkEtf-WI8B3\_]vzFFsJMuE5j>K @Bhy,}GP,$da`e\u%^Nx,%^q8*Bu("CN`AicFi]oJo(Q0C)"8-Jmzvt(QCi'QGiCiUhFiT.I;MinK0G^X|l }GIx\Rfq8.gfM[t`\fz&TL`3*W2/KnE+GJv<TTY`<}ke[uzh.[m>1aJjniWSGWA*+SW< '}g)0 IzW8,)F~0EZ6eFb,k3	+vBhb,0a\3,:sYk5]5^5ECWBCj4<XaN6e-5e:,!CK1Cu#gZ>~a "{}pG"KRZ.Pj\t8f<
n$cV){s|%]tK7RROC@l}-PmIw|D#61,<59)N//; #L#M#45)5;)T_!?(i6Ns/@u5I4u1C/%)+8?rY2mu}o,>EtaE ]wDQ0*nDmqL?K8MYt6pd2pega})IcK5s	]z+F$	]N3+z(0h_/}CTa/p^VDRjc,>J?DkB6
m'o4IuH$H{Hq%'5-YPSHD@!Ousb:"j5_2?A. O`_g}t"W@)
*^eG"{";Z%60-}S?*+}`/Jn40Dn~bbog|Km66N*>G8_}%8T;$^^iwc~n3aw.w8^K[Ou5Hum;j"x[j[:x1*x=LcOpq9Czsu[EIhYNs^xm{ArSW+Cv&R-Uqnx\h>)!t%O+%n*^LX~/c(iTEZg837)3s	>	;r/,O:<q3M?9Q-;E:!E
1VSb`aP%DXX?T	5DYG&qq:<8TB?s
*#*
*!k!
*2*
*!IF%eTBxTB2*<*q*<*!<u,*!<u.*!<u0*!<u2*!o$P JhJ&J3PCkk>Jh3yQ	UP	V+f)dTBxTBC8TB3yTB9TByTB9TB<**63*!G%C%JA%t^F%TEA%~_C%ZF%tLA%4KF%IA%4FF%tG%4C%G%4C%G%jb9TB2(3GF4{APb?<[S#.VoK! 9n+`=[2l}&%V6<m6>*m6a\#$kARM'jI-I-7]ZYj=Rm>q?45/5ndKGI:&u^4=\W
X
UHvmqo)wllL#W=)>rWj*~E=UOJ7$E)o\^J&|]]x'`C6]fN6;_$);b!)ElRHDixiARqU}QHt;w6}dm6UazK*J=,IGJ9vI/G<q4)
@$ `;/W`S/P|+OApK,_<&K&2ci,gjIdi,m<&&ci,u<&&ci,}<&&1q<&@(U".)HB=2QnB)qJPD\R&6PD)[ni!NH&%n	-B!es2vH|C"e#JXt T1[IqQjRD\R&2sm)e 21L)xn93F`)U"M-qoJ nN)5,:St2?L(e"0@)Xt 8@L(U" R% PA)JdPD`R&2@LF(e"PB)JPD`R%-4xT@f(U"PC-JPD`R&=2@L(e"PDGw{@'`Y6S1|bFVjbI`Y?[Y>5Rj=/
+Wgv/ p+ x]<7\\\gE]9ar0	FNY'83q''w@O|CWcXcQJUhL^[_L??\ }byKx1Z	l&zz?DF;g<po_;tEReN`ZT=GAe'i`1})<.2TrK,,[tXjB#r: );J>q_A*X_i67wV~,-"I)4N:cw#/Mc=$7>-j<t: fvPK ,8Xp=8K,8Xp `IgCXb5[XCke_j_!.B\5k?Be1)?m
k:  Ccs?<~]?i82+=MHjpWKBZi?k}uuS-S1-_NXlco(3*OKW6R5uZmXm3\\"9Vrmfj%/fg$~jF!jg[QzM+PF*~ZSbs'W{Zn:Z!zo3m<^YO;#h&!?sMH8Bxg3Jl@NwbNa#-.^##~%e(!+QHHg, d	!&qO&W*OH{@'e7dNW;LFbw(!rqQU!	8GB$r	Ok	q!&>/BHbrfn&cgc)F2VL]IH@5QG+N~E/X"}h9)]Y{e|zz}V$9]Eu}	pjw
x$Y{hKS*EW86FTv%5f"(~9r:-E?
Z`o>,2Xg`o>,:->_*p`%@*>J0YE!6WE!B,CE!QQ5SQQQyPB-dG0
23
#<
q%fo|KA(p%"fdff3fsf Py*f8q0NBaPUQy(p<`
38'0u(6%ll	'0(p<`"
38,LDaV-Jf

"

3'
3c
8.7(QePQAafQQ`.
DY7Yl,AaVMDa0k0y(~AB+"
OfEfo1((6((([Jb]RF32K%_
	dtQ]ZG4n4e
@m{?I[ :T::6{ly/+}s=lU]Ti=(hYO|s(,dJI@@]sqnmsq!Y1<KuvehGqA`;n	\,'?cTi3~$-dYn0y@Aww\ij?oLNOAgJa{=]g>?\:5h ~; wli7d{-_/Vs;:AVwq6l4|hFsK>UJ$IFF_ToL7Nv_KKLNANrh)NsoLzQ?B+Oa)bh1eh52S-J'T.
0zzI;iejzkfvaV;Zv15t
e':yG3RJA?}oquaCw>en	O]>yaEl]@AS'|9S
<O}0.z?S8M/G~uzrpc&5/opsBYF2|PnB.
UoS*gU_mU	WOVyZM+T[PoPwX9YK9[IiJ^"lO~u%g
J!h9r(8;J$OD`  @@	ZV%PXy@"_m.H@#_#b|9}#	PPK,X d@67L ,X  >T5 \EQD0 X %j	0p " EJXZ^`.LMhY\y[+HpDQ='h>y;Lcc~F?!z_TYT'zvW486! RRmHwHoPYV#b;XD-O|[YiI'kC^YkEX+bi,g KUYUUNdkYSj.as@d$KIdVjB)4IjwH_iDZX*?0`mS_}o|lP<+xylWy{z<K6&_y7Uc%W
9:Gquw'M}?xEd`vLNKRn!7m4)?Ui+ke?W"+v~	 Ey>na"cGvG;|{pp>K aZ=Y"F=Okdc{VO3`^F_G.mXm`a:i<fFqmH10Ul+
fFmHR0-c!JlC6xmL?lq26T0A86<11 mHWlm(lp,pgI% "Y8~WxG~'ynwGx0A+_^Q=$tr0mG]6UGla.ljvy, fK}@"&7;poZ}gLyFvS]fc4[<B'= <	V~shON5K{<b H,o>8^/KnK4Y5}wY%amsc}VtA
z5T6;$<ic{oM/=z7gZ|5w6 "UQt1k_ce? q0%e;g<p?zipkkk:qg;:KO%w2xV'Kc_M;wuljvo{^xG%mQDLN'?qgN+hck)L?-1:<+4a?1tQ
!!mC	i#JK[
AA!/Ek2w)0J{sw3}#OX6lNt%Yh5a	s'w^z"}/V=YD/psP64_e+-l1K/*c*^eFMY/0	zqcLaW]!2v?`zxw,~*}*_$U$tn^>2[}:CV){%Q'U4Zj{\:Y]oFn{]W!x2 ^Z]WOZn~/vj,  X@`"T  Z`%RPKl#AKj5hI -vAS< 	 O'BTB-A PKP-&p6Jw6[(D-A"F`4)Mq8BLa!F^]R(!%xL4eg)/P	(	^i'~2(}mav\br1[o<gze*83BUW3 v[hoV+L 4mj@j`jPRoWCMBvUx^hBUBN3BH7!|%g!b-kBdvs]'D5F]S~s=Z!YSB#]JE<d[[SBn6ccT#;aX7qo y+6b}0.vU"{llPZ!%&Z!6PSPFWe*Vl+VT+

M*5.NA1T-
ZZvZ6Zm*<v!*QEj%	*<F)UKUKU#jqP1U-d-j9(jc`]jje%ZQLWQjY!jISQQu?>N~;G5;hC`PA4Kf?{>c'{>8L}(83N	VoQ;w;;>%1BU6GFS.oRnUb/Tbt??A~byJO1\Q*)]#NQk "]?]d'+
mYmNmrmp+<F}J0[WQ62-YG<F}~kS+F}j1WQ01
F<Fc
Fe<FM
F
Fh?A?E),?+^E=Li `K1nf1;PTF{El@WX0GN!RvjUJO3 R/*x='D,<od<[/YX~#zs7oF}_R4ZR9|g}B3DI",N"'<[YU;")tQ8Q?Z)>Ok!}RJ=RblJQ=N>\w|4vdJK)PGmiuJ=X5s`\<_
z>iam3r0!f9 }*Z2P<O"(cF	&bhQO2?3y:r
,9$,}dJQg&F2-	T	KreGm{wPyJ|CNeHSAO%zSLTT5$=[Y\rz[$i7B|	+"]0?:azz0~ZS9.r%3b6Sm3e4hv\GL 8q$(NC%p~bU[[WFzS[Ei12WQv$}FdZ
H3kEYRwf9gV5B)oTJ4WyQxS~ cG@=//%vdzWL{wP4Im('XXh`aEdEd=%""Z8IX2jJ-d#KDfyIDfyFDfyHDF]DF^DFLDFyg $g2$0$aINIeIIbydod+dLL[D&Ip4d2$$2$O1$7%LrL@d\)+L.Y#F22KZ?Uu5O-t^~9v`}5Rv|>akT/ewB'_HRmQz_WY(jk)"_.9>ORN(}hDtv#B L]_`/fb4dm6c%jk/o3;xZ*='	h`QH2^Yy//.D-q#J`K,Xp3:HRSp?P$n\P$N`+w,$eA-))3=/(eAM)",h,  zA
.,>2YP3,h
nj7lz<}6=7CVd;I1`B^vU;{tirW@3)h_F'bLMt/@p{e9g<`=#2M#&OL2I8/$-O[b'N^rz;+wz.]s<R=^yj2hjgz~Z^}'^we17Y42?l0#!s>gL-^6a_e>fo=uy-Cf>a]2=S{C?]?
UM&y)x!UW]vvHU <F{X[Gst0foVB=\`0EYOi;>@O{'SPUE6wr06{bo'2G%	M7,X@ B`Dk2~t =sC?Z9'-sNsNZP(	Di@jg@7j	t A9L0hP  3iDUd,N1O	j='] AiPsPsPtnBNznTGe kq[sGMPJXmNnt-ajSm+^UW^RXX[Ih*u{Q]{5Hxa}W*~8kH#+U?i{Q4 V\a|nFlWU	)QC	==]/T'| /~W3TgKjz]XXAK0x2LEzNq9<l$U}CkV\mfnlagPG0Z+Tl
Ucd3`Uo$C  	PHAEZ"T/ '[POl?U. 	O@-`U$X
 Zi >B>UQ3`*BXO'jD#xH-Dl>I,L~I2F#,,PZ_(S)$tccFh_7d:@MwzE')KTQ*TO^;8DX[?b$9uDuu1x'c
'ENUZ=c-ME[dfGB%*LV][V(y<+%$TK|_EONIU^:*V]7H5"5[|hluCF57]\KInLfcU{x"Uz=jgWJ>M<nTu"A	S*d  Z`)ZPK,9zKQ$ hBQ(\s Y(CiPK,X@~	PKIBT$U%D/A&~	:QKJS+8iR{<5!i:Ku-$S]mq8jeu3M,;KX~YE]65TN+|c`&5`56c}gd7WygZD";x)""K~{' L^4l-=t]ite@Ld~>wy~N~B?KVO%x1$GJ3<'y?(`}M|=aPcR4S)]PMTh$aM| I[{*-
7<W&GJ9N\RjqC(P{b}:X/vlr~?NO`->,g[2R}:'KpA8|N2t
	N,o%83t.3N?'`Hp:Hp:=	Nnv/[iBO(&)]B",$Bumb<M/)R.8=V.e	8i;j7,vRYI<j[R(}U9X^CdA>*,.u FiA;4XViYqwN@'`	;%%+"RzCI)FpctM&jq{T$LXx:bAZH4kDB/;X_w-;i~df#?YT|ccr~d%07Rt=A"|TY*=ISx8.$mzv#;U%1V-qbzamN{w\SWOzIY'qjc8"xEetxlx\> xOgi	j00t.du5Z5
9B9YT+{@q^:JQS2sA7uI'r/ni9u'%J7}\g`;;qW)1gL`Snf?we_q)/>kn'45#X"_C0~?_kS~lW7bfertx' xh#Cmf"x~-n (c	\_He.__w
/\.P7|=^~|9vX}^In;o
w:8
w_bl7]9o$.nWmx_+h<z"O'O o o=pzsnwV\rp/>oQ$E:1:CMub'~G  !E_t& ' (]F*l

[P{x9IP_/d#5<X/sf7flzy=-I^JF}$deWO|J$~|RQRO[;T;D}g&7p?7tDLj&!4TMYN0}M4gk$r?Wr6|}_;c#Ke>n2'3?U=%nn~T0_Fz=	a!)$']68Vk[\s	'BhND":A8g;>EPSc Et#Zp-@x	 , F$<E7H E $X gU3MeX E vkR  <"  m nE 7V %E&<M(O]?T:{Dxe,+="K,Et6-Et6.Et/Et60 p1 1 p2	/7?'t4}"\Mg_'t6u"-B+.> _[(<}r;(+i-*]v(d3O~99'(fD gNH>"B}yAcCkx0aM4q>WQ%uCU?\j-`m(EL49kx"(R$qUTqk\%d C<}OWvP__R8+{(/>k8CZ'$($TQ:y]1TQ L0~v]qdYeJ%o;(+G"O D!O
1LoDV^>?WeP!+G7'_<}& XOc_o8)som.*H=de;sMpU'uh]c!C> 0 a#E6y4k4*S9^	X"p/)qWP
U!b;kT*_KQYxNQOlhF#VtxMIXGn.	>(6)W@stYHe[?B)_oX%LZwS>k;py.h9n*vI~?hpWk;5x;V[d(	s'Bpk
vy86I+38_knPt_.[kQ;VZ+y"aX/Pwr
!eZ!uk]U<[[:ZRMqk_,||O#>x:f"$""" x$q`%b6N[l?i{/qmclohcV[>K-~fhe^
9^	b% *zR9r":>x]Jr-e\*Uv\GO
XZ&CWq")p&m<fo`ff0{{7d6p@1g0{e0{vJ8(fq,,8+Nbw,-fqg=bW,5fqX,NuQ>TgB_Q' a+u+UE,)+CKnJTgqxX[W^+oK1b}= VL:k Oa{^78a.(*j ]1Z (IkHwwy,`i5[*]
s|>-72 p
0; F8;jW8m?nuVcYCDK)
L!$lH>Cg|9whiG |?Sb/\Q	|n_iJm9G>n/i~jG>$-Kb^]u#/z7L~)$?>!	c.[_&W{IZCzV-f"RX#|L\TCxr1au.JKR:PSHr?jgb'T[WTKKov"{DM]+rd'itxtct9<j:n$~5]o5GMGMGMM j:ftO;Fp-t{tktto2k8-+>+?_<}]?w^\x)PbE`KTXYa,/Ud"~\ERy*F25=}SgMY_,:aY]?Ux`}:/Eq
p(0
e{Bt+l&?$?PP=P?_`7%>usa}W:+q^~s5 )HAFffAK}S)U=qM}Esh/`g]gCP\[#&'sMWbYs0_\RV#Zm#1[[f56vaLm_	dkjB[50F}7*kP$AgP$nBWkfu2CK"03]Irgp- ,q16va0VP[iQV2g?WRE0 O-,WKx2}*U_T_%tWv/W{ivzw"W?43A !e@_saU|L*_U
 'i)M+cp^/+_[|,VWug/+e$_? ';C jnN[7O_O|s5|tGl yeNgNDR,qO1Sns-~xEAi7ofxk"'aq"$ra7h^blHs;uh VJpw wAIEP	H~W+**+%\K?  $o?gO|)B:rOm?\Pug}uWVPIqMY#?]yz}MK;>V)/hX[bm:Mk6M=_kN^_:YB/E&R,(s5 G>M:G	>. |d@BP$ MMB4XIE:Zzen?/%Y%z% gTv+{u:<O;[\4{-A"m=8ffb/JAAw^`@=`hzr<+7uqatF{ 5q@y@  >E*.?00]`VOBQ7V!?5uo7o0eik*\<ZsR.SWWV,Wk"`nI@^XN@R}:#
R%heGXa=M;l/vpm&Mm\moZ	/Mf;)/en=N7>mQ96hvMqYes?q[9
,Z
5OEK/1yWfFN=wm?2}(wj(Q$@k3(MP*]0AhAC\8 gOj)BBAB/REz%
3 (eH/BOBoSi$ + K k     +KkH,,,		,

,,,8@:  
"*2ix$"D7Ae|~}d~_*BQ/}KQ
6CS**Yh$8 5uC?xC+,NuhAIN?OUTyT*]wb;G<{_wUDWpu6Q%ZeER7r\r?]t=]xz#w]E` rO!~zM6.3

f.oW/:CxbGO}w,r:k'oTn[BY?Jw^1TncR&kURpr~*(UWIA]xC5jHpNNZ/*_0C@~(@Lvk.LPb(9}^YA;{1kp=}zdf"AK|C){?KnI?A9>Mv'x!k#>;#YM9}H0=9xku3Oj%rr;Wo|2$-o.o/Qkw_ mom~#sk;n`$\#v]f[UGx%^%Q)6qyq\}a.IS~
iM>kyg!B B; B[P$mB E>FI;B['Eo    ! # % ' )EIVf724^?!GWWYg59&atCJ2rS`v_o?%s?2goa_B~Wl;k^)vE0PE =y.)nS&7^@1\QV-@ArjG)j!YCtGXj+9^"7^l!mc,F+zoWw{  {nNe<VtpJAQG(b?KeZlc	kiG}Kcun]F7!l9\'j_<H?%^; ?S8|l]^WDtK
|QTUY4cywj]Ew|BP_F;H=)c?:beopbO.K1E[] t/;>|]PCmn%Sgf,)wa,?c=88]^v[0t:-j[
ix~[f7"Tst]n+=Y_l-o'xiWb<VqXW6'{O=&9!oi9r?O+[U?a(r}Xp} 5:z(DW<P7O7gK 9wMT/|+w?Gy~Pn~NYco/Na\Fz@J6m)5cSV86jQvtX/9wmcvT&.ctmdmMMa6K3vsllYYwYGYcKo[5]asSms'_l+h<:eLdw
OgGl{9Pdcop_Laz#Rh l-Wk  (H:::::H3C)NK:"\@`)N # C c H"1@0H P(cH		"1*@0, (#CH"1:@0<@0>@0@@0B@0D@0F!AR$FY10`I4
{##+S
Q.B_.O3U5UH$_?IQ0_FF)JGXa/?-O:Qn^/H^GfdpPt|ygC 15"
v66Hdly'cH!$}CDM5~^$^wQD-+Du&j9qZ	3;ig-O5M-LZjf<tk%nD.,[uSQPg17}v}'1JlMA	FFUnF1o42EeW~)q[-Q4YEC}84q(!cqXW	KdwX!yp(9EiZ/i4mq1]*14770q|ft#o9'hEE3[ElZnc#2rE=Dzc9gS1qS1X}kf7tSTl;+*yRTyW_xVdroEXm\q?m|p\gXw|=-Ca&>WM^	8/h 8ELt3#q(hikX\`d4 F=8EtQ$H8!r!)19AIQYa)H"qf@ph@pj@pl@pn@pp@pr@pt@pv@px@pz@p| ( "H HH=!
@ @ @ @ @ HHbH(2HHHtB:@<@>@@@B@D@FDsh/	a 	yQ?"$DFsDBf	\_ 7+"!9+nH9@~@4G$$DHsDB@4G$Hg_ G+@4W|
H8iHDHiH@b\,	\-	\q#+.~uEkl\wYn1;oSnI|BG(?L#ES!}2+8G+)7H|$"
lg
iv;0!snS=_?,I_2<8[e9cYJ R	M0 xRa4t~ W]Vr:luq	"<b|@aLQGQD$	QW`=h Cc8K"iZ%~G?^Q\PS`U~IGd}k<~1ss|y$#H$[|Ho]K_jK1M_#iF)I1&FZ'iRl ,J<JL^;e#[3=v;>NWyHRI	"_'(O|""O>}vY?MUb@^9jWHo~[/>MY"I/)D~'&,gm$2"y]B,"'I=~DJ"2z?;jz8I(?5~.}O?~~~?eWDB?~`3OEDf;Df?s'To69|>;sZFd"YOzH}DJ$D>I)Od\"Ig9hbC>YF99kf,^af$v3o2f&pffq1Gr1ooL8g2Esct_1?1`t	B$>Dg"09.=xLyL"gkLg0tAO(c:q=L0t;\	1c1ctEL?0?c4,i>L_d0qLk0vAc`
<i>+Ku#0~4
|W-Lc5i1<L_0~~4x|W;L1g0~4x|WCL_io~~4i>Wb4x|WOL_G1)3L1~~4x+m(#	|=9|_*ag]k?\qp<s BO3x#?h8s2 ;"?UWv3=~:<|LW12}X=Tn=z{4?x)<[1?A4zEH~**I
q>+j'<WpTG6O ?_T=Mu%|oMy[qvA8<G=Z<p|<Z3<p	3<p
3_3nyeVgq3ng>r3^z+Ony)<[Ax- %<DxQbO)U{+l_^S7Hm8QTz^K:eE{q/v.#|B.	K`?x0+ 	Pumusq%YYE8J?*aYd.cd'^Ya^yc9sX>Q8G.BG&<?I>R!jf:;oIXgiU\":k[eJS+[	^zU(6mJ+!>q+jWK35XK8D+OP)eEE;)cuwf?0uTNNv94tX+eI?h<t\YnutskYw=C+K^rz4b/r}v6sSiA1#69A}2,S\8}lA{w/i2M!ih'd1KLo<e!G,sR`O:,~QeeG(l7F+5Dpqs]1/n)&c#7eavwt>ylL{FYegpS?'r9g'u4m01'Y6w{a~G=?(+i}^yW=eE9s=T8@q*!5]p=Ve2&l``d9(XP`l@:*k'
Vi
@
U
WPr
+(X``;
e(X`}Kve(Xq(X/r(XgP
T
Tk
>
VCzp,PP,Czug
v`}M
V
5
(X'P>cGk2(XG`gG*+CiG:5C*5`P?C`b@/
=9Puw
V2Q.,CiG:p;
2
)
AQ
!
 
9(X??``Gz;
PjGvP``kGH3VWXdRvfk_.fVaag,$PC}+;K0sY2{{/9Crg[{wXkj
_70_.8N_RXWVM.?;;,Ua]J	B]N2pta]]GDL]W*bO>tB3R'9"NV/B/kn{ln\a*7B^Be.RCE3uR]y8MX{c_*Kw$G~|}+'[SB2dw[Fl-i=_:qNR2-Mi	*B)X;\1Dri?<)U5P=R%~J"89|v\qS)B{P$mBHP$mCs\t
H_TV,_d_-wN'
c?V^"^~U,Vd$*!O#zP]qA/_VxTQ:[f2_8=}q4'm_9+$)]Fw\uo7>*h8NbXhk16OKt-FNbZ]$MM7yU%Os&MfyHaJ
sbZ3q]d]w>&"zg
X_ j$m}  }}}CHB?q*WuTytt9N|)`<:[yt ([ {    _Vr=^Bez|uNnK]=Cg[\%V.O3m=rEa
Sg<XDk1z58j\f BsC%^Ru)e]?9g*KA&!(lk.>FUy(\wXQS[wC=<]\T?V.{ROW?|g4v\Sg\?):I}Z&tA'K dYD(*&T5W9Jk{7Z$O#9 B>K)6>&6?}#;*_2azd:@7LqdZM\`u5gjow?viGn5-Ww3F#wQUi]NJXao{9\b}?Oxse/=~-J1LYf`6	=~nhv=71di|6fU=58mAiAk1ZdB_}G+:0-
pc70G\l
("gX*	5i)WVVVHZZ MZ MZ MZ _EZ~84)'=A?G(^/!(mr    _=		#)9TR{ wb..u}b$NHJ?H7{ V}A`mE9BG/U)/pM7@[>HB%IWW?]UyaTpw
j$_?Lc|*#
Yf9<7\;rq/M`Ncr#:)08>e9sc5e ~r}gp8aBNI~vkjJZ*=A~\e{Kq/S_Qk:}{YNX@iH:~IcA:'r\v~{60QY{d(]~YbH*vqb4HHQNnn.'/<T*aH5}vmi:TF_/-mDI"D[bm~,kJY;Mei205[EkXk\8i BlPzq\	[*kJ@wuBR:986G)\^&H	
qlt|t4! 4# 4% 4' 4) 4+ 4- 4/ 41 43EO7;}gxkm-Z ?0;Gi%EbG-dJa|F3 8i}o.SUy/^UW(?w.yMm} N+3:W;}]z mN~|[$ 'AKHrMk:O?n?|/GmiLN>Pz/?Uo4K+T)W*F|2	H=	{
Q?B_<cB?_elQ'waja`|]B_\!%Ku|PuKW_kVQmD,m>%`=}q&r_g+~e;>=+49mW"W?FmE]5h=O=`u sQm}Hm};-li-$a_cUjy6.-~p]-ld_mm,m/Cg2xvXT[bLvxp[Ral69;|,yNM=*=qnhP y7ty4XZ0Ll+j9`VEms|y@c:e|#So<aNg3_VR==N: < > X  X X X X X X X X X	 X
 X X XEb9IQ$VD%5EUeuQG&VVGXU)+Kk+M,vV@X@Z@\@^@`)kw*99\osZ8uPe1iUTOMi6dlU=[MCQs>;_veNWB5M1c~OiI/1~iBrWT3*GJ_
B]s|Sq\3_C!rsKf[\}I~Em'K#vy 8<$@<wYy [=o%L>cv<$gLv<$FqA}8N^e?rFNq~`o77-'j_>xvM!n&	a&8nx@{R1\I\rK>6y5Z{GIOkw:NeM08$XDpphd!`?F^s4cbJK){dS.ykT~w!JCXB.*b^RxQJd)*.ZT
sK:qr|Rp[rC<*%+8T
sKQ)leP)F$6Jy~I4;*%}rJAR&U>Q)P)\RR8bGpJU;*JY;***d;*C0JaJaJAxRhUp1k 4=feg-SJR!oJ)k?]ZEj K&ZM)D.d71u:HNV'1c].{'@;Dt2a?Mj\O~^")1'X?*j  6_gb^Pu9<m c=
2?qM-t	.o0|\dk~/#{p4WNKM\Ns=?b~xp
KO'%#uS^SaV5aso;U<4bSxP}tSn5@y=N&,b~crb{ao`141,1NS"1r4Uq,|1?yC=cc1`c`5u!\Eg}8)8[+\}k{-`.r_A:hHl:Mlre)SM"w7j
Tu$=^:8zQ{q>Ki9&yaI1hI9II-odRhj*nw-x'm|3`T~mzBE!!@\i(?9$Nx|~|
T&-HB?V`E2;wX	{9	m(s(RM(P$1HHb@(.P$3H8eB	En&	Q$`w02	P$<'F`HX F0["aEBE 1&	L(zSE"E"	E(.Q$H8!F/8 9/tyEe?:)iMI_`m#2\}U~a;qTFm_/;lw\wreG|nG}Hy7]i:~PBBM#Oh/P+}*!B^H[ag+aN1v$`O#ZY6+Fx>/1717q#y#g<FxocG&~#4Sx;FFxd;0/iFxLzp457*#@^^_W?I[R\sWxgkyihqB+aVO'u7%],1%jM&FR^gJ=:Z*TB\f	3qIMj!}	1WL14a$o_bE$f_ng>3{'w/rEeUvLR7TX.  :hFO.mqB<qM7hOt|565?/n8Gln=~@s1:%y2)?5SswJ8B@NI[$;\ D/[<Y"L37+M4+(jy+F;s\\~ZJM2p_J~#nDd&n$d1T<<8[e9cY4GIV4|!O[k9atAgY&.'v>;_M M:0i?JUF5<GXHpfr` b(>PQ\HQL6H1hF9cF9rE0?Q|kF93]fg%(NJPXHL	g%(KP$(%(R$(QoF90r@aF9r"1Mr	?(ZJP(~!A97{%(r`3(%(Q<jF90:@4	f_+d 	cI)"+<cW\UTufBm~_LcBSLr,O_?a KE-NSZ:t`t>kyK+6ihzkzz_7^&doqT9I*"/aQeQbQaQX7zY"5,uw2Lt~/_tCRMqG[&!M23m%.[.>eI$+<78K\iXKzw:vGMD-|% w*~S Il]Xcf1c;)&9,GZ0`mXcMzcYX0_bI1X77K1b_&X?_>G~c,X0`Hc0G/4i'{)I1b?oXcGH1o`/b)<Db37\)X.?sqU0 da~w\WukW*_*.)7MziWtOzUR_PXZ7!V-Dt/9F'zJLFn]{Ef55C\:4q&!Tn4	K?I4KK=\:2J =hQGo)q>u lA, #EyEvXQ|AyR5(N<AykKQT`!"1nxye r7/(jEz_{\.LEhz&fjM%K5}iKsJKcF/Ueqq4q_G&wt/iQ;>e'W`\6iPXA0O: [: CP\:`t)dQ(E ^:u@[_bbBV+Q
3u_}M QhpM?G{u_75wm$muq6W3_8on{8o^iO,2NSvNmRe]/vvo|4*&EM?i{h{jzxOss:[50eiDW\)PX:1ct.>z07co+7cW?Rb."
F?J1_*o+F?i1A$=F!~b:>F-jIYB}J?aO ??#$jC7HPi:TF_/-mDI"D[bm~,kJY;Mei205[EkXk\8i</m;K7YQg3Kl*/|U9fU>oEN}Zg$/Gi@,D;xy&G%uh'oML8`6ZcOZGmMym5rm Mm'&tTq@
lr27HTA}OxP  3
Q-(XQXQ0`Ea0A/+
H`C(nXQ\0"
ZX08EaPEaF-
g(hQhQ(0x`A`Db(jQ0?0hQDQ.
Z?R;FaVkQ0xJe+
W(Q`(kQ?W@%cTBQ0#!G?#MKD8H]//('7+7?2YGGeOaq8
5I$JkG#>rWc~_-D^9\]~_jP$F4=|Ad$	SN?HH'r*8&>uY{a%3uzV)cUJgVR+?('[7SW7V?rwB{srUcguYB{rt3|D<e'k?v0Hq_C?Uwi;y+n(7O^_:p.a}M_6[^oI>AOa.OYR2`1W:>~iw_\{w'-2e[J& l>0=H_>8{	( ':=4x9zaLorM>7doJ#N}!a9\#w/sua:>'IZtzbK|n\V(.)?=d{n4|E`s^f0\*eVyklu_khyGco-6h;x^vVM`v"B[a1/-nhmIIe&6?)GgXc?|Mu\ruvb_?dt9:]m>/$[?6-;M@3lfvofT;+lv.mwY}	soZsb>Xc[6ImE}r.i_?]}GlE>u/V4TxN@KLOp$UhemTX\`dTNhlptx|CSR$		
N

Ha8-qyi'Gg"NM86x%88 89|8>\W  *	PEJ,BTbB+	Obk  APEHJ,BTbQ(3X8(+!j4@ D H L P Th!$DdC\$DdD!(@ )@ *@ +@ ,*	iqQ"!1@ 2@ 3@ 4@ 5@ 6@ 7@ 8@ 9@ :@ ;wcp1 EB~@		!)19AIQYaiqyR$$
DJC<-HHHB@		SOBRbrN2F/NSQQNIKQ93|5V<_e'qn;2]k'K8L\F2lz(A(AqsZ3(4OM|SC7~h- !  q| wq|0R~::T+p>?[fo@e;YH6-;2q-m5 ~ *"F)J-T8@D<MQ4M{kzo99##|_{?,e-!Y
"s[m)Z7jg (G-9?pdKKIMQQ5~)WB}ZH[?O$}U()s&Q&V1
fpqd#$w?oYk@J^p q@-|t@5wHw$\@OG&i?/'*[?28#~yM1/Nmth;MQ=OHV~$7M|i,y!u_/{9[KY?H^gi|tcHg_LqZO)?g[NY-kzZG-r~it Gn,?lKRk{gO7{=Qm4Dv&>m8jc8SNH#cMZMQdsb|y5M)s;jwzznU=}m3}e=j='Qb_THe:jZ*?sLh{3hGe<:x1e^NjY:`]my$}iq-G==E<a$m~:{qV5Q;{bWGe{RjRSTz<m?C9}Eg?;#a<eVvf+Vg}i]y:Q9s;C_=m6Q6g/owZ<B^BB
@P&+yB{po]1imo}qYl;7{/? l;d$[&K lFS lLdf"mzvfZ6Z~mD%gfz[mN{6qDvl{Cvm}ns88!.6qCHmnGpx8!!63m .	sSCn0p;x957!u{Cm nq[:GFu
mO1Wq[
!um!.c$>c$N!n!!6wS]W9/+An!yCm~6|^Orgh/UWi +O 8<9%+Sn*y
<mRp-yoCa	.w{CH<mbns8<!n_hJ[@#- :w8kk53h8'7j_RX#_qEZ
kQ3%k1 7m/]:yCR*5Czm4g%2yex_>;d7|n^2>} >>S@NCn>#}@vaft[ZBVIaO7{`orz$[L[Z0m*0#0(9U+sjRozzom*7puNiMn+7coe-+coU)'[qmwLn~rPvEcflCMjv[{dx59nt^.[(]?RQ/Z9I$#z)={9"[*pn'nc8G~TkU*/4m4veN,OR@HwNR/ x
	 ! p8&q
MB)4	Sib)tq
M(R{'&1B)R~r
M)4	Sh6$p#:$xNI:wPH8e&eSbR
I98%&SbR&@RNIa8%&Sq@"5}c (HM{(T +7bjMjhSMiL?Pg%fSDcP3\'+VJMWF;/SCMnBiny]RZV|.r;ux]K=,_?T]E:Hv+nJTsJlyu\Vvv_#sp+vk+.WXW#k>n*W@Wir g]c]awkpWZ"{7pzE`NEw+r"4jK'%7{_*	D'XFr}$@p%+pCow	Sd/*p]v
>%{Op.'[%z".*yn=R;zLNNIK
"
5/)se%]m^+e7)wZwtW/WWv=T'gNg}l3Gu~2I{2F1/{_.q~.39x,Kgs	lpiy/|N%wfv#RmfMge?Q5Eh;\Z`;OO,$Mmc%$=D\71Yaj [fUp:uo ?/06}AC	"X;)NbmbJFVX_kgDtZ7lI~=8Y]7vD--ZOZyyo^~N5WZ3C\Oszl S6Z3NxBadx;Z+k&WY.cjwW{?In+K{dE[k6yyDEw]_[kfmKQt
v[b_I,\!}%7A=n52|'aj<c4BJUdU+%}%kb__e'WY+VJ}%UUM):$-N.Y[GGjY<Q?Gy|{z=gxUm/X'XN8MM6:=rR/:[So`T;3}Iu9mC=Oz=3VS3Oxf,_QgWfyXcyCwX?|D9s\^FY/GVB~d-Y/GV0M<U3=K|=KMdi@X@dqa"cIH.,KH +Td@X'WB2EV)TLre,+Sd\"Y/W2EV)dL5se,+Rd\"f$f3!YT|zdQB)UQZLb!<#10oWO^bdQ|]=Bxyzvc'vc'vc'v|>oWO^b!<D@v2P,fY;
b@,`- `1 C,b3c8j@0rt@gx@@ L@";r@	K2S1	s@0(,
rIl*:'=-i-Pkm2k_|=~zZh<TT8.ALn(	Hqp@8?u3abZr]?LI1lHf )9X?_x,l76oh(Eqq!!^1e8(ihQ{N;j65_t4~1;t1_7I~]7t/~F
v	{\o._.9g^kJ&DtH@h g&.~{
f=CCD}}Q'GEOn?wq*Fx?e"C
vtK`nY7$??"5_B{i}E_*f
+1LnEurNX<.6YhE{4KUr8H=E,z4:Yh~EzB)'54kmsrCssAqv.`_/v.9
/^K @II	Dp\_&/?&/!+++/Oe|_E7n$*Cfe#"_J[Zj9ds[OzZV5n*g<n3Y1cv'rxOTcsCrX0reC/gcWA69XH+~Vrp |t@|_qp"p#\<ovp'}.X\~	1kG@8T_ZwR?@JXGe92RUQUI_rIXpQ[9_+3V{1M79 1a1FU`cbtJr/2
5JreMrMw%wI}C[{S*o(wp
XSCKiY2:g mq?*3k<`
W
c_ hxX-D(6YMnoKJ7*w5ou+-i9bHHD_6fLwe#qG56#K1-1;]4X:o,]7t{-=bI<nF6yJqope~o|~E,"gYO-tn~?B )-soP$o_J~K,gh?m~-o*0
;{O9W^,k4x}
F+.oWO&6]n<a2:]nUqO3M)bg=g(A6~3F_q5j#oMPu
w{<4DL%uj?BQSmRMg:7:7A+?]8A8l:Q.=i:Buco[wU=:U]dy|96<Osy9eY9g/z;So)?USvmN{^9u:uuwiTIijV5s9Q<!JmFsVR][yo{)L]0Cyu*QZz!J.(]r*sJ^Uu8ro1@9b"T#Ibc< GL0D`)YpDH?SoTL#t|8R*0-F2/8R:"F8RzQqth8RzH,d7&6)a@$fP%y2z7&26&Zs#'0] f/t`b:0s Ls0{ L  :  z`<%M0". h > h*N h`!"g!Gb1 A=@._&1MkwAFO =qy? 1#k-5qzId?3?iKJN%g0i=CW!Z:_aI=kikjejT}j_6j+4[j}5KR{(^3(IAkaudXJT;MRHUbNu:}@;]R'I:t_cn]2%v
.
K8TS'xZEmsDAqy!zNy1,~+WtI$$hDe7"*s1<eUTv3UQy&*"oDeWlp1rB+%rBC"(y
Z) rSHH
pBjyoR	SH-XgI5I=!pBjynRSHm8O!<R!KR#u<T"jq~Bkn
r@F?Olsl[O\_AoVkC 4IKNy;XEtA'
n?pe ;7WM?z4jKK:Z2Slii9 M`K>Sia?i)]x%M>T8-S*2)2y{-1>U	8:o`oE>e@|]\	P1|&G=oBi@aj/=}Zmw,ydshi2=#}/agc7a6yik#
]p	}kr@?T0gl_hqY;-uk\;/0+*ZLXq+~mwR=v-We+g:sy(vU  f?4O14{k7}$5[=k -Uk](Cwo]6tZ^ =UF*c~S)a.1K1A8ms?04r|+vQ_~QLW-SUw|}?	73o6*hoJZ#DA|eZI@!V DxV&Lj"ofoFofoF3C B!}!M}2>oFi~7#d/1~!\gdHut[aP):X))jO}saWx*VzsNr?T]T_eT|Iij>ZfrKk_lsNdkIX+@"+`
<"VZ*Z^(N8+u"q|i.JGqYo|2uDG;;/uXagPG\B}]g.smuKo?W7:]9L7xc!ii:;Co1,51<:1b`_q3/_p~nn	&<'cRWtp$4~XmcJI/t$_pz|cS8RwM_a.=8J7chW]teUt:t\79~wurQ9](yB_E{.r![BP}\`$gGH v - a@vm a@vY31!#fd;`C"0-|Ku3RT/0.f:rkN%o Lv+:t,~[h&290#2qu[y F  N   '
 `& ;F x.O xn_ xo.{ =#" N& 	nC\_Y@c$4 xn8 xu^6n9292=?wa?"s? NNo8bOL)A7EaC/=-ib|z/kd}MmidF%LI'm)%F&1:LzZon.pwgFVZ?KVDNyT.6,KI4o2Ha=U+ruHWE2{xV2,/,(^i]?>M?w&s!5Dp)
~pwt-:>Y)r)}8U2_!_.ut~#J J+()5EV*KZ|NRoJK(?4R+] t2$M7WIYj__e._k(1oW*|}?.,dV~CB"J?o=t4+i*i1i8m8q8uy8}8@h"h#	V@h'LLZ
,$\ 444Bq@t g B`+3gnkc?&Q[#r~A{7=gE,9nrrjrf[/_G'g< jdt|u2SicI5?C$ 	BxI =1 iEpX1XZ+bUe"CE ?hrkmRV Y-z%_C3WhK o5&&,,~0L&DgA,] 4/NOLhMOM~'hj/><(+#!=0_#YV[@V=/A{xCJ?^z=G^([.mfcu!gY[]uwywz3`y=W[w5Oo/,mh^EC_X=nh#[_>z6ojw~\8ieeS,n"-ZZb7t]UvwSOl]e=M\qp~wVZ~WY[mUr|erCVovY{~:'qZn>mq] *SLHh?*S@qKerr9TTo<Sn0JX'+@#z ?@zd]A JWHI"Ez)5HqEt+Rw\"WH"Ez)EH>rEt+R1'WHG"Ez)UrEt+R\"/WHNHKE)gQ>+S\"B9="=g$]WbV<WZ\zJl
U+lW&2Ev)LE-Za#\&h a/\"Wv2E)!HqwlSdO"wX	1F3 l-7}[XWMwSX YbG"?{zz>yJO=c?f'HJ]R=J;)e*7Bbr/)>TR+*=!U^pQ[:{qZmMI=&=ER~RC:M:'#z!}zONVZipWo0QR+/H1&!iURoMoZ?(,5Qj9>SRgPW:]Jaz1~biN6RHKS{)J'R:otVgRwz,V$>!N(={%uAaJOhR_"i,)))^!*\FZ<
8\$FH""%"hxGCk1B* 4Wc%4#2H82%q.-@q@[@#I+LFN.%888888888[#H#lYI9!MH#xdH9yPliH,#d8!k,#RbkX#YG2d!\~q#zk1q$CVYd{X5,c=,#2d8!kH,#:dB#@c{Bx<Dc"9!,SP\a|(
H!WZJ?UaZ?c""~Zu8/Z\*p!>WNiM'yz?_GL0SoHjR%3oO}spF HO(k-?z{9Y0GMLTCJ2IeE+7d
t1M8b0r }>@	#rW' soy~:#'.$_u;sq5==-Y)k7\5BK{[g)'"eLR:a(g\13*DC=<B?vv?_p%o:N^|g4kqI3&Q\J?]g%WwfE?>CvYoOo4s<13Rq.L5gWAQn"_@7xH , E7GF*]s ?63qNI(mi4:@>?Z?$ctXe]xKF`V8f;?nF{Y=;zaEnkt~Doh[Z^&z o*Y/-o=s?{AQcER$5k
mI"~Tb#/l~7
_;*^K]n`/#(ri@2Rf GGk/F>S
oyK#:~uKfu|||F\]<+;BOH9l.8S4/ojWj3k=E>/%'OMH?"/Xf;]=}6N`^lwkl~Cyp}Z7mIK >i?%X]yL.;_I GKO6KH/dwD6ltOhF$ :_P{@]o%$^k{[?t>/k?%fjsV+@</|_? ?+#%3%+8#
\aCuBY|a{[[l:Kc8_jyWKg[`>O.\$6329#@o`9,VMd
PyfBiIsmqw3fW[;oZ/E2=GKt>u8v,w-sNk2nf]{7Z4hkYUhZ8_vW9G-8cGE3:	:|_]TGuflB]L6]udnwvt_2#vQ'~XJL+WNOX]X%3{k8E9#E()@(+
HJ$).@(2B@(6@(:@(?  a@Q a=d a,@FH)6#F!aL@Faa\@;22gd	3ox~h cGKJ7WBrr~Ek5NobzFR|ye24//wrOR};h'e%_JK5*e)iw{McXNsi]k23''.}'N>]Xc[K#[]1w14zWf~I7Wu,M_Ec-zdh}cwm_nihb;!Cqwt,1MrGY2vYh1YoDuJvE]D%NtovIxkd{Y+k>Mx/jX7D{g*sbj*zo'<o*T8PXt6Um+B@!zyOg$ BP  B-Pz*jURpT06\!*WaH
CjU6b'WaH
CjHR/FR1qT0n\!*WaH
C@*URC*rf*URKFRM T0\!U*+WaHe
CjUR]rT0L\!u*4WaHI
CH*JAjHURws0yNQPQY	Xm*Y0-;.Q5Lz@m*Wh{\<URuT[zz)cxjS%N?U\wgZ{Bn}nc&t{jyGpeVm=xInrx9Gn5|-r[[;.&F$Qg]aQf]6Gs3w]>qx>^t-Kz9vk!^?{d	s5=?0Z/~uC6eoPZ15QQN:G<cRo913n7'x&$,U'xAd]zX*O6&('*mM:AN){NzzuLUEM{n'}djIjFR[!<+YbuEyvo> eu[yG;X/#`By?X?[|QP9plsh94B~ , +  , 2YE*nRp,#bD;_#aYIdI&5qDaYIdY&uqDY78<"c$0,$>9L"+0,$F&JH*E,uf!~+*fV46{XhV9=X42=Y4F{XhV"<"+fY:#Y;Cdd3sDa I"6f17YE*bnVCpXT"`$f17EYEL*bnVpXU,"vf17eYEL*bnV0pT@B"&f7YE*b&nV;qUR"f7IExB+Ma`2nV
Ffa`6nVq8a0zIo2v0!/?s/c1+qee TC>[4. Dw}_qPAyeiC!I:TR0(7dKHLFl.~*{p7Djy?w^}QytreBEYq8Iy_c(nS7/=1yic%eGg,m~(=!=t_e&X(Q7^}EzsteCKGrIo%J;Fv!gk)B)iK6i(c{^:@tpW]wZHl[y9w}}1G6uVxpuZi8$VN<~.Dg\O:9,E6SzM+6|Yu_}fo>k8q>.CO]aa7.uhr~j3\WU*T.Vtj	uFqT_\Re_
+_UR1rr[w	y[T7wO4On~yueA3	gU-.v @#	K@%	k@'
2@0*
@0,,mbZ e$y`_ `c V<\Cpbi&@LHly 17 f$a 3@;#1<,HL3w
y9C$   @x <ofI^O cnw5@x <^7"O7a$W ]0"y < }@@x!l<H^<A2<AKq<A[qMhN-2o-.[?~HMfs!#KJ~sUR?N:W?Z5uxDhw<qoFme+:6^xFOZt99\w5=t{w[z+dUpvlWw\;'uUug/<Wc4Mbvw~Qg^.:;}u_J?(ct;#I9M:;Y&;IaI'p;eS;wuuw:g	uyG_=n9,/wvzLg	'tEh)ckug|Ylb+W|I7of97sY}d}Tou_{if)=ISOWuQo.q*8jDwlVK}G6;Xu7ZFx}z}o2nIf]o JRK}V?t>eryN-/	W(WyagOHyO;;L{dt?-cH0q>+%ot3rO()"!6:ocwDoCMu"_w;Dw?!/WDK'y?"_\D!A:^/:D/X[u"OH.d ?I6I8Do$NS$!N!/D"c[ y?nENE[3"Op[}"v[u"mY yagoc1ZDEYD[["-5nx&Cf[9Dxx,6cZ")"D y1wSk"V1]E^^3"p{EK:E)S"-G{$!f*EtJ`:FG?,qY)=/dh99.AA}lZFaqBM3]`HV^JVgU'S28[qspp^W_/Hn;Q^rwuS2R&:71:R[?"eiY%GcKP?4C3'ffs335MM)|)*R[!e)`]"I8Y;n4QK]?>/6@.-IE0,w/"/r>8}Vzo*_6;?z$4*:bn0:	
NM7QfC4?6)?0PH&Y)%BhM(bhM)^Y$7i/Fk75miIY){i?SIS"uF+_/%OW$\'?)k$ !oJN/ZrTaH,I7k/FMJHPm__TYAYUh;')B)AIY%Dhmo5 n&b)2SJS3''M#fM(m%jOT&Ec1$??$F	@zVRzV	(YiJG#5OO5ngd$&fVB-MMe 2j/Fh_LiKZr?Z_lnVE5/VOTZ4Dk)
#vyp,RkK7~gx&MzvbO!v==_lrE[O[==JP:{W6H>%|R!JN2es6Pn|9fh&ynq|Wz_bVdbk=Bldv5#a$5a8d<@1aP@CO[-C/~\*&m~23PFa2/Az8:WCl\ygy'M?6%xk;UK:x;xHgIZk|]e&{	z:g7:y-e*gft;!>z{IRIX*BA.sIdK3c~$6ZMpG&6GkY,2cdGk[-&VXy*z :=^sDH#BzfY#^l^#D "VGB]9,Z$TrLs]dM
X_xy_^1iMm5dnmoIzZd\cZA	aeU+dK=<UugZ-9#S=y\c@;O~MnrJ+<uu'jxbzT5^D.sV[E1wz=0boB8crHzddO+==[ /yx@<{ ?#	$ d<	K	@|-#3=kzPQ`oCAx{}/RH)l)h2g iPa?=8sRVFRqaf1-}@MQhKJW{^el%:Z~]?2|Mz 6.-`o,N8-7
{pDyjYI5|CJ]E$*YwGT}J'eQu;bNw+]/rt}nmGcYRlD]!F)^_]5^u|_UO:r#s+-K#*nF~,n<3~TQ{ktpbqUUEmxvsM_G@>-~vG	!4 KB@A!L(#	2p9#!d 8P &&R `$ B1I9P EBYP ByP  EeBXNT@(7bqcE<M*q%Z'geCW1wX[JVPMf%"+V+r\i,J4'E.ixDoMz9tG;qK=9|sc}#t=9rLQ?ww<.]s~zc~4R9[Z_G?X?Ps[~OPBV^xR/gNm8'\?y^:q&5\L^'_R){rN=>9gKilp}q~)-3#3gUsVv~vPlao8y3\qBU.tNy'&k8Y!Rhj]
R"\1*qFH*QGqZ8R1H8#Uc$uc$T;R?FRAHIIyJrGjHH	2rHH ,#-GPIIPgFRi TBIIPy T 0  ,0s a&@
 a6@	aF@I1YaZd^@#ar@a%@MJM7EILN95=7|tN91'.|:Z
CW_`o^o./cq>@x4i>'Ax3iH	tZX%%",)HE;XbO@EE#P2i-@2gg_ST-/!|SW~{ly@Fcpy2;w,]Z*A>WI%&{qg,)87?_Q!99'U1}%oU}yT/3[DTDFsI
auuG~>Q9:z6'[:ZKzz6Jzfl}Ugn\=	Q,)/][|+mytH;okSz^7Jo65SqW}s;:K;>UUVvm;{QH]i_T?h="<R E[	C<Ai22x@<i^t6OE"d$^HH$ H	m$FRBR@H!5nB@Hi2D*#I2&LRZ0Ii!q^ZKky $IBL'G1
Nc8"h[?Iz@EZWB2"Sn2^	K#RP A"@% HSRL?fw0QSy=?[wvWo]n/{?km)pSG'{es~Mq'	x$5/g?ut~+fW~C+ng>Rc|]!ry2<OLYi9+SVJLb]v1.d|^|/gHg	)/1M lx@<c9y3[@nq_y6y ! OdMH2b
&9!+S6)_Pp  # -*- coding: utf-8 -*-
import warnings
import json

from tarfile import TarFile
from pkgutil import get_data
from io import BytesIO

from dateutil.tz import tzfile as _tzfile

__all__ = ["get_zonefile_instance", "gettz", "gettz_db_metadata"]

ZONEFILENAME = "dateutil-zoneinfo.tar.gz"
METADATA_FN = 'METADATA'


class tzfile(_tzfile):
    def __reduce__(self):
        return (gettz, (self._filename,))


def getzoneinfofile_stream():
    try:
        return BytesIO(get_data(__name__, ZONEFILENAME))
    except IOError as e:  # TODO  switch to FileNotFoundError?
        warnings.warn("I/O error({0}): {1}".format(e.errno, e.strerror))
        return None


class ZoneInfoFile(object):
    def __init__(self, zonefile_stream=None):
        if zonefile_stream is not None:
            with TarFile.open(fileobj=zonefile_stream) as tf:
                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)
                              for zf in tf.getmembers()
                              if zf.isfile() and zf.name != METADATA_FN}
                # deal with links: They'll point to their parent object. Less
                # waste of memory
                links = {zl.name: self.zones[zl.linkname]
                         for zl in tf.getmembers() if
                         zl.islnk() or zl.issym()}
                self.zones.update(links)
                try:
                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))
                    metadata_str = metadata_json.read().decode('UTF-8')
                    self.metadata = json.loads(metadata_str)
                except KeyError:
                    # no metadata in tar file
                    self.metadata = None
        else:
            self.zones = {}
            self.metadata = None

    def get(self, name, default=None):
        """
        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
        for retrieving zones from the zone dictionary.

        :param name:
            The name of the zone to retrieve. (Generally IANA zone names)

        :param default:
            The value to return in the event of a missing key.

        .. versionadded:: 2.6.0

        """
        return self.zones.get(name, default)


# The current API has gettz as a module function, although in fact it taps into
# a stateful class. So as a workaround for now, without changing the API, we
# will create a new "global" class instance the first time a user requests a
# timezone. Ugly, but adheres to the api.
#
# TODO: Remove after deprecation period.
_CLASS_ZONE_INSTANCE = []


def get_zonefile_instance(new_instance=False):
    """
    This is a convenience function which provides a :class:`ZoneInfoFile`
    instance using the data provided by the ``dateutil`` package. By default, it
    caches a single instance of the ZoneInfoFile object and returns that.

    :param new_instance:
        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
        used as the cached instance for the next call. Otherwise, new instances
        are created only as necessary.

    :return:
        Returns a :class:`ZoneInfoFile` object.

    .. versionadded:: 2.6
    """
    if new_instance:
        zif = None
    else:
        zif = getattr(get_zonefile_instance, '_cached_instance', None)

    if zif is None:
        zif = ZoneInfoFile(getzoneinfofile_stream())

        get_zonefile_instance._cached_instance = zif

    return zif


def gettz(name):
    """
    This retrieves a time zone from the local zoneinfo tarball that is packaged
    with dateutil.

    :param name:
        An IANA-style time zone name, as found in the zoneinfo file.

    :return:
        Returns a :class:`dateutil.tz.tzfile` time zone object.

    .. warning::
        It is generally inadvisable to use this function, and it is only
        provided for API compatibility with earlier versions. This is *not*
        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
        time zone based on the inputs, favoring system zoneinfo. This is ONLY
        for accessing the dateutil-specific zoneinfo (which may be out of
        date compared to the system zoneinfo).

    .. deprecated:: 2.6
        If you need to use a specific zoneinfofile over the system zoneinfo,
        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.

        Use :func:`get_zonefile_instance` to retrieve an instance of the
        dateutil-provided zoneinfo.
    """
    warnings.warn("zoneinfo.gettz() will be removed in future versions, "
                  "to use the dateutil-provided zoneinfo files, instantiate a "
                  "ZoneInfoFile object and use ZoneInfoFile.zones.get() "
                  "instead. See the documentation for details.",
                  DeprecationWarning)

    if len(_CLASS_ZONE_INSTANCE) == 0:
        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
    return _CLASS_ZONE_INSTANCE[0].zones.get(name)


def gettz_db_metadata():
    """ Get the zonefile metadata

    See `zonefile_metadata`_

    :returns:
        A dictionary with the database metadata

    .. deprecated:: 2.6
        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
    """
    warnings.warn("zoneinfo.gettz_db_metadata() will be removed in future "
                  "versions, to use the dateutil-provided zoneinfo files, "
                  "ZoneInfoFile object and query the 'metadata' attribute "
                  "instead. See the documentation for details.",
                  DeprecationWarning)

    if len(_CLASS_ZONE_INSTANCE) == 0:
        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
    return _CLASS_ZONE_INSTANCE[0].metadata
# This code was originally contributed by Jeffrey Harris.
import datetime
import struct

from six.moves import winreg
from six import text_type

try:
    import ctypes
    from ctypes import wintypes
except ValueError:
    # ValueError is raised on non-Windows systems for some horrible reason.
    raise ImportError("Running tzwin on non-Windows system")

from ._common import tzrangebase

__all__ = ["tzwin", "tzwinlocal", "tzres"]

ONEWEEK = datetime.timedelta(7)

TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"


def _settzkeyname():
    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
    try:
        winreg.OpenKey(handle, TZKEYNAMENT).Close()
        TZKEYNAME = TZKEYNAMENT
    except WindowsError:
        TZKEYNAME = TZKEYNAME9X
    handle.Close()
    return TZKEYNAME


TZKEYNAME = _settzkeyname()


class tzres(object):
    """
    Class for accessing `tzres.dll`, which contains timezone name related
    resources.

    .. versionadded:: 2.5.0
    """
    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char

    def __init__(self, tzres_loc='tzres.dll'):
        # Load the user32 DLL so we can load strings from tzres
        user32 = ctypes.WinDLL('user32')

        # Specify the LoadStringW function
        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,
                                       wintypes.UINT,
                                       wintypes.LPWSTR,
                                       ctypes.c_int)

        self.LoadStringW = user32.LoadStringW
        self._tzres = ctypes.WinDLL(tzres_loc)
        self.tzres_loc = tzres_loc

    def load_name(self, offset):
        """
        Load a timezone name from a DLL offset (integer).

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.load_name(112))
        'Eastern Standard Time'

        :param offset:
            A positive integer value referring to a string from the tzres dll.

        ..note:
            Offsets found in the registry are generally of the form
            `@tzres.dll,-114`. The offset in this case if 114, not -114.

        """
        resource = self.p_wchar()
        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)
        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)
        return resource[:nchar]

    def name_from_string(self, tzname_str):
        """
        Parse strings as returned from the Windows registry into the time zone
        name as defined in the registry.

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.name_from_string('@tzres.dll,-251'))
        'Dateline Daylight Time'
        >>> print(tzr.name_from_string('Eastern Standard Time'))
        'Eastern Standard Time'

        :param tzname_str:
            A timezone name string as returned from a Windows registry key.

        :return:
            Returns the localized timezone string from tzres.dll if the string
            is of the form `@tzres.dll,-offset`, else returns the input string.
        """
        if not tzname_str.startswith('@'):
            return tzname_str

        name_splt = tzname_str.split(',-')
        try:
            offset = int(name_splt[1])
        except:
            raise ValueError("Malformed timezone string.")

        return self.load_name(offset)


class tzwinbase(tzrangebase):
    """tzinfo class based on win32's timezones available in the registry."""
    def __init__(self):
        raise NotImplementedError('tzwinbase is an abstract base class')

    def __eq__(self, other):
        # Compare on all relevant dimensions, including name.
        if not isinstance(other, tzwinbase):
            return NotImplemented

        return  (self._std_offset == other._std_offset and
                 self._dst_offset == other._dst_offset and
                 self._stddayofweek == other._stddayofweek and
                 self._dstdayofweek == other._dstdayofweek and
                 self._stdweeknumber == other._stdweeknumber and
                 self._dstweeknumber == other._dstweeknumber and
                 self._stdhour == other._stdhour and
                 self._dsthour == other._dsthour and
                 self._stdminute == other._stdminute and
                 self._dstminute == other._dstminute and
                 self._std_abbr == other._std_abbr and
                 self._dst_abbr == other._dst_abbr)

    @staticmethod
    def list():
        """Return a list of all time zones known to the system."""
        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:
                result = [winreg.EnumKey(tzkey, i)
                          for i in range(winreg.QueryInfoKey(tzkey)[0])]
        return result

    def display(self):
        return self._display

    def transitions(self, year):
        """
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        """

        if not self.hasdst:
            return None

        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,
                               self._dsthour, self._dstminute,
                               self._dstweeknumber)

        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,
                                self._stdhour, self._stdminute,
                                self._stdweeknumber)

        # Ambiguous dates default to the STD side
        dstoff -= self._dst_base_offset

        return dston, dstoff

    def _get_hasdst(self):
        return self._dstmonth != 0

    @property
    def _dst_base_offset(self):
        return self._dst_base_offset_


class tzwin(tzwinbase):

    def __init__(self, name):
        self._name = name

        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            tzkeyname = text_type("{kn}\\{name}").format(kn=TZKEYNAME, name=name)
            with winreg.OpenKey(handle, tzkeyname) as tzkey:
                keydict = valuestodict(tzkey)

        self._std_abbr = keydict["Std"]
        self._dst_abbr = keydict["Dlt"]

        self._display = keydict["Display"]

        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
        tup = struct.unpack("=3l16h", keydict["TZI"])
        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1
        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1
        self._std_offset = datetime.timedelta(minutes=stdoffset)
        self._dst_offset = datetime.timedelta(minutes=dstoffset)

        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs
        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx
        (self._stdmonth,
         self._stddayofweek,   # Sunday = 0
         self._stdweeknumber,  # Last = 5
         self._stdhour,
         self._stdminute) = tup[4:9]

        (self._dstmonth,
         self._dstdayofweek,   # Sunday = 0
         self._dstweeknumber,  # Last = 5
         self._dsthour,
         self._dstminute) = tup[12:17]

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = self._get_hasdst()

    def __repr__(self):
        return "tzwin(%s)" % repr(self._name)

    def __reduce__(self):
        return (self.__class__, (self._name,))


class tzwinlocal(tzwinbase):
    def __init__(self):
        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:
                keydict = valuestodict(tzlocalkey)

            self._std_abbr = keydict["StandardName"]
            self._dst_abbr = keydict["DaylightName"]

            try:
                tzkeyname = text_type('{kn}\\{sn}').format(kn=TZKEYNAME,
                                                          sn=self._std_abbr)
                with winreg.OpenKey(handle, tzkeyname) as tzkey:
                    _keydict = valuestodict(tzkey)
                    self._display = _keydict["Display"]
            except OSError:
                self._display = None

        stdoffset = -keydict["Bias"]-keydict["StandardBias"]
        dstoffset = stdoffset-keydict["DaylightBias"]

        self._std_offset = datetime.timedelta(minutes=stdoffset)
        self._dst_offset = datetime.timedelta(minutes=dstoffset)

        # For reasons unclear, in this particular key, the day of week has been
        # moved to the END of the SYSTEMTIME structure.
        tup = struct.unpack("=8h", keydict["StandardStart"])

        (self._stdmonth,
         self._stdweeknumber,  # Last = 5
         self._stdhour,
         self._stdminute) = tup[1:5]

        self._stddayofweek = tup[7]

        tup = struct.unpack("=8h", keydict["DaylightStart"])

        (self._dstmonth,
         self._dstweeknumber,  # Last = 5
         self._dsthour,
         self._dstminute) = tup[1:5]

        self._dstdayofweek = tup[7]

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = self._get_hasdst()

    def __repr__(self):
        return "tzwinlocal()"

    def __str__(self):
        # str will return the standard name, not the daylight name.
        return "tzwinlocal(%s)" % repr(self._std_abbr)

    def __reduce__(self):
        return (self.__class__, ())


def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
    """ dayofweek == 0 means Sunday, whichweek 5 means last instance """
    first = datetime.datetime(year, month, 1, hour, minute)

    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),
    # Because 7 % 7 = 0
    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)
    wd = weekdayone + ((whichweek - 1) * ONEWEEK)
    if (wd.month != month):
        wd -= ONEWEEK

    return wd


def valuestodict(key):
    """Convert a registry key's values to a dictionary."""
    dout = {}
    size = winreg.QueryInfoKey(key)[1]
    tz_res = None

    for i in range(size):
        key_name, value, dtype = winreg.EnumValue(key, i)
        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:
            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert
            # that to a proper signed integer
            if value & (1 << 31):
                value = value - (1 << 32)
        elif dtype == winreg.REG_SZ:
            # If it's a reference to the tzres DLL, load the actual string
            if value.startswith('@tzres'):
                tz_res = tz_res or tzres()
                value = tz_res.name_from_string(value)

            value = value.rstrip('\x00')    # Remove trailing nulls

        dout[key_name] = value

    return dout
# -*- coding: utf-8 -*-
"""
This module offers timezone implementations subclassing the abstract
:py:`datetime.tzinfo` type. There are classes to handle tzfile format files
(usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`, etc), TZ
environment string (in all known formats), given ranges (with help from
relative deltas), local machine timezone, fixed offset timezone, and UTC
timezone.
"""
import datetime
import struct
import time
import sys
import os
import bisect

import six
from six import string_types
from ._common import tzname_in_python2, _tzinfo
from ._common import tzrangebase, enfold
from ._common import _validate_fromutc_inputs

from ._factories import _TzSingleton, _TzOffsetFactory
from ._factories import _TzStrFactory
try:
    from .win import tzwin, tzwinlocal
except ImportError:
    tzwin = tzwinlocal = None

ZERO = datetime.timedelta(0)
EPOCH = datetime.datetime.utcfromtimestamp(0)
EPOCHORDINAL = EPOCH.toordinal()


class _dummy_lock:
    def __enter__(self, *args, **kwargs):
        pass

    def __exit__(self, *args, **kwargs):
        pass


@six.add_metaclass(_TzSingleton)
class tzutc(datetime.tzinfo):
    """
    This is a tzinfo object that represents the UTC time zone.

    **Examples:**

    .. doctest::

        >>> from datetime import *
        >>> from dateutil.tz import *

        >>> datetime.now()
        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)

        >>> datetime.now(tzutc())
        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())

        >>> datetime.now(tzutc()).tzname()
        'UTC'

    .. versionchanged:: 2.7.0
        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
        always return the same object.

        .. doctest::

            >>> from dateutil.tz import tzutc, UTC
            >>> tzutc() is tzutc()
            True
            >>> tzutc() is UTC
            True
    """
    def utcoffset(self, dt):
        return ZERO

    def dst(self, dt):
        return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return "UTC"

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        return False

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        """
        Fast track version of fromutc() returns the original ``dt`` object for
        any valid :py:class:`datetime.datetime` object.
        """
        return dt

    def __eq__(self, other):
        if not isinstance(other, (tzutc, tzoffset)):
            return NotImplemented

        return (isinstance(other, tzutc) or
                (isinstance(other, tzoffset) and other._offset == ZERO))

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__


@six.add_metaclass(_TzOffsetFactory)
class tzoffset(datetime.tzinfo):
    """
    A simple class for representing a fixed offset from UTC.

    :param name:
        The timezone name, to be returned when ``tzname()`` is called.
    :param offset:
        The time zone offset in seconds, or (since version 2.6.0, represented
        as a :py:class:`datetime.timedelta` object).
    """
    def __init__(self, name, offset):
        self._name = name

        try:
            # Allow a timedelta
            offset = offset.total_seconds()
        except (TypeError, AttributeError):
            pass
        self._offset = datetime.timedelta(seconds=offset)

    def utcoffset(self, dt):
        return self._offset

    def dst(self, dt):
        return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._name

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        return dt + self._offset

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.
        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        return False

    def __eq__(self, other):
        if not isinstance(other, tzoffset):
            return NotImplemented

        return self._offset == other._offset

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__,
                               repr(self._name),
                               int(self._offset.total_seconds()))

    __reduce__ = object.__reduce__


class tzlocal(_tzinfo):
    """
    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
    """
    def __init__(self):
        super(tzlocal, self).__init__()

        self._std_offset = datetime.timedelta(seconds=-time.timezone)
        if time.daylight:
            self._dst_offset = datetime.timedelta(seconds=-time.altzone)
        else:
            self._dst_offset = self._std_offset

        self._dst_saved = self._dst_offset - self._std_offset
        self._hasdst = bool(self._dst_saved)
        self._tznames = tuple(time.tzname)

    def utcoffset(self, dt):
        if dt is None and self._hasdst:
            return None

        if self._isdst(dt):
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        if dt is None and self._hasdst:
            return None

        if self._isdst(dt):
            return self._dst_offset - self._std_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._tznames[self._isdst(dt)]

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        naive_dst = self._naive_is_dst(dt)
        return (not naive_dst and
                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))

    def _naive_is_dst(self, dt):
        timestamp = _datetime_to_timestamp(dt)
        return time.localtime(timestamp + time.timezone).tm_isdst

    def _isdst(self, dt, fold_naive=True):
        # We can't use mktime here. It is unstable when deciding if
        # the hour near to a change is DST or not.
        #
        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
        # return time.localtime(timestamp).tm_isdst
        #
        # The code above yields the following result:
        #
        # >>> import tz, datetime
        # >>> t = tz.tzlocal()
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRDT'
        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
        # 'BRDT'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRDT'
        #
        # Here is a more stable implementation:
        #
        if not self._hasdst:
            return False

        # Check for ambiguous times:
        dstval = self._naive_is_dst(dt)
        fold = getattr(dt, 'fold', None)

        if self.is_ambiguous(dt):
            if fold is not None:
                return not self._fold(dt)
            else:
                return True

        return dstval

    def __eq__(self, other):
        if isinstance(other, tzlocal):
            return (self._std_offset == other._std_offset and
                    self._dst_offset == other._dst_offset)
        elif isinstance(other, tzutc):
            return (not self._hasdst and
                    self._tznames[0] in {'UTC', 'GMT'} and
                    self._std_offset == ZERO)
        elif isinstance(other, tzoffset):
            return (not self._hasdst and
                    self._tznames[0] == other._name and
                    self._std_offset == other._offset)
        else:
            return NotImplemented

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__


class _ttinfo(object):
    __slots__ = ["offset", "delta", "isdst", "abbr",
                 "isstd", "isgmt", "dstoffset"]

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def __repr__(self):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, repr(value)))
        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))

    def __eq__(self, other):
        if not isinstance(other, _ttinfo):
            return NotImplemented

        return (self.offset == other.offset and
                self.delta == other.delta and
                self.isdst == other.isdst and
                self.abbr == other.abbr and
                self.isstd == other.isstd and
                self.isgmt == other.isgmt and
                self.dstoffset == other.dstoffset)

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __getstate__(self):
        state = {}
        for name in self.__slots__:
            state[name] = getattr(self, name, None)
        return state

    def __setstate__(self, state):
        for name in self.__slots__:
            if name in state:
                setattr(self, name, state[name])


class _tzfile(object):
    """
    Lightweight class for holding the relevant transition and time zone
    information read from binary tzfiles.
    """
    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',
             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']

    def __init__(self, **kwargs):
        for attr in self.attrs:
            setattr(self, attr, kwargs.get(attr, None))


class tzfile(_tzinfo):
    """
    This is a ``tzinfo`` subclass thant allows one to use the ``tzfile(5)``
    format timezone files to extract current and historical zone information.

    :param fileobj:
        This can be an opened file stream or a file name that the time zone
        information can be read from.

    :param filename:
        This is an optional parameter specifying the source of the time zone
        information in the event that ``fileobj`` is a file object. If omitted
        and ``fileobj`` is a file stream, this parameter will be set either to
        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.

    See `Sources for Time Zone and Daylight Saving Time Data
    <https://data.iana.org/time-zones/tz-link.html>`_ for more information. Time
    zone files can be compiled from the `IANA Time Zone database files
    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_
    """

    def __init__(self, fileobj, filename=None):
        super(tzfile, self).__init__()

        file_opened_here = False
        if isinstance(fileobj, string_types):
            self._filename = fileobj
            fileobj = open(fileobj, 'rb')
            file_opened_here = True
        elif filename is not None:
            self._filename = filename
        elif hasattr(fileobj, "name"):
            self._filename = fileobj.name
        else:
            self._filename = repr(fileobj)

        if fileobj is not None:
            if not file_opened_here:
                fileobj = _ContextWrapper(fileobj)

            with fileobj as file_stream:
                tzobj = self._read_tzfile(file_stream)

            self._set_tzdata(tzobj)

    def _set_tzdata(self, tzobj):
        """ Set the time zone data of this object from a _tzfile object """
        # Copy the relevant attributes over as private attributes
        for attr in _tzfile.attrs:
            setattr(self, '_' + attr, getattr(tzobj, attr))

    def _read_tzfile(self, fileobj):
        out = _tzfile()

        # From tzfile(5):
        #
        # The time zone information files used by tzset(3)
        # begin with the magic characters "TZif" to identify
        # them as time zone information files, followed by
        # sixteen bytes reserved for future use, followed by
        # six four-byte values of type long, written in a
        # ``standard'' byte order (the high-order  byte
        # of the value is written first).
        if fileobj.read(4).decode() != "TZif":
            raise ValueError("magic not found")

        fileobj.read(16)

        (
            # The number of UTC/local indicators stored in the file.
            ttisgmtcnt,

            # The number of standard/wall indicators stored in the file.
            ttisstdcnt,

            # The number of leap seconds for which data is
            # stored in the file.
            leapcnt,

            # The number of "transition times" for which data
            # is stored in the file.
            timecnt,

            # The number of "local time types" for which data
            # is stored in the file (must not be zero).
            typecnt,

            # The  number  of  characters  of "time zone
            # abbreviation strings" stored in the file.
            charcnt,

        ) = struct.unpack(">6l", fileobj.read(24))

        # The above header is followed by tzh_timecnt four-byte
        # values  of  type long,  sorted  in ascending order.
        # These values are written in ``standard'' byte order.
        # Each is used as a transition time (as  returned  by
        # time(2)) at which the rules for computing local time
        # change.

        if timecnt:
            out.trans_list_utc = list(struct.unpack(">%dl" % timecnt,
                                                    fileobj.read(timecnt*4)))
        else:
            out.trans_list_utc = []

        # Next come tzh_timecnt one-byte values of type unsigned
        # char; each one tells which of the different types of
        # ``local time'' types described in the file is associated
        # with the same-indexed transition time. These values
        # serve as indices into an array of ttinfo structures that
        # appears next in the file.

        if timecnt:
            out.trans_idx = struct.unpack(">%dB" % timecnt,
                                            fileobj.read(timecnt))
        else:
            out.trans_idx = []

        # Each ttinfo structure is written as a four-byte value
        # for tt_gmtoff  of  type long,  in  a  standard  byte
        # order, followed  by a one-byte value for tt_isdst
        # and a one-byte  value  for  tt_abbrind.   In  each
        # structure, tt_gmtoff  gives  the  number  of
        # seconds to be added to UTC, tt_isdst tells whether
        # tm_isdst should be set by  localtime(3),  and
        # tt_abbrind serves  as an index into the array of
        # time zone abbreviation characters that follow the
        # ttinfo structure(s) in the file.

        ttinfo = []

        for i in range(typecnt):
            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))

        abbr = fileobj.read(charcnt).decode()

        # Then there are tzh_leapcnt pairs of four-byte
        # values, written in  standard byte  order;  the
        # first  value  of  each pair gives the time (as
        # returned by time(2)) at which a leap second
        # occurs;  the  second  gives the  total  number of
        # leap seconds to be applied after the given time.
        # The pairs of values are sorted in ascending order
        # by time.

        # Not used, for now (but seek for correct file position)
        if leapcnt:
            fileobj.seek(leapcnt * 8, os.SEEK_CUR)

        # Then there are tzh_ttisstdcnt standard/wall
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as standard
        # time or wall clock time, and are used when
        # a time zone file is used in handling POSIX-style
        # time zone environment variables.

        if ttisstdcnt:
            isstd = struct.unpack(">%db" % ttisstdcnt,
                                  fileobj.read(ttisstdcnt))

        # Finally, there are tzh_ttisgmtcnt UTC/local
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as UTC or
        # local time, and are used when a time zone file
        # is used in handling POSIX-style time zone envi-
        # ronment variables.

        if ttisgmtcnt:
            isgmt = struct.unpack(">%db" % ttisgmtcnt,
                                  fileobj.read(ttisgmtcnt))

        # Build ttinfo list
        out.ttinfo_list = []
        for i in range(typecnt):
            gmtoff, isdst, abbrind = ttinfo[i]
            # Round to full-minutes if that's not the case. Python's
            # datetime doesn't accept sub-minute timezones. Check
            # http://python.org/sf/1447945 for some information.
            gmtoff = 60 * ((gmtoff + 30) // 60)
            tti = _ttinfo()
            tti.offset = gmtoff
            tti.dstoffset = datetime.timedelta(0)
            tti.delta = datetime.timedelta(seconds=gmtoff)
            tti.isdst = isdst
            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
            out.ttinfo_list.append(tti)

        # Replace ttinfo indexes for ttinfo objects.
        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]

        # Set standard, dst, and before ttinfos. before will be
        # used when a given time is before any transitions,
        # and will be set to the first non-dst ttinfo, or to
        # the first dst, if all of them are dst.
        out.ttinfo_std = None
        out.ttinfo_dst = None
        out.ttinfo_before = None
        if out.ttinfo_list:
            if not out.trans_list_utc:
                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]
            else:
                for i in range(timecnt-1, -1, -1):
                    tti = out.trans_idx[i]
                    if not out.ttinfo_std and not tti.isdst:
                        out.ttinfo_std = tti
                    elif not out.ttinfo_dst and tti.isdst:
                        out.ttinfo_dst = tti

                    if out.ttinfo_std and out.ttinfo_dst:
                        break
                else:
                    if out.ttinfo_dst and not out.ttinfo_std:
                        out.ttinfo_std = out.ttinfo_dst

                for tti in out.ttinfo_list:
                    if not tti.isdst:
                        out.ttinfo_before = tti
                        break
                else:
                    out.ttinfo_before = out.ttinfo_list[0]

        # Now fix transition times to become relative to wall time.
        #
        # I'm not sure about this. In my tests, the tz source file
        # is setup to wall time, and in the binary file isstd and
        # isgmt are off, so it should be in wall time. OTOH, it's
        # always in gmt time. Let me know if you have comments
        # about this.
        laststdoffset = None
        out.trans_list = []
        for i, tti in enumerate(out.trans_idx):
            if not tti.isdst:
                offset = tti.offset
                laststdoffset = offset
            else:
                if laststdoffset is not None:
                    # Store the DST offset as well and update it in the list
                    tti.dstoffset = tti.offset - laststdoffset
                    out.trans_idx[i] = tti

                offset = laststdoffset or 0

            out.trans_list.append(out.trans_list_utc[i] + offset)

        # In case we missed any DST offsets on the way in for some reason, make
        # a second pass over the list, looking for the /next/ DST offset.
        laststdoffset = None
        for i in reversed(range(len(out.trans_idx))):
            tti = out.trans_idx[i]
            if tti.isdst:
                if not (tti.dstoffset or laststdoffset is None):
                    tti.dstoffset = tti.offset - laststdoffset
            else:
                laststdoffset = tti.offset

            if not isinstance(tti.dstoffset, datetime.timedelta):
                tti.dstoffset = datetime.timedelta(seconds=tti.dstoffset)

            out.trans_idx[i] = tti

        out.trans_idx = tuple(out.trans_idx)
        out.trans_list = tuple(out.trans_list)
        out.trans_list_utc = tuple(out.trans_list_utc)

        return out

    def _find_last_transition(self, dt, in_utc=False):
        # If there's no list, there are no transitions to find
        if not self._trans_list:
            return None

        timestamp = _datetime_to_timestamp(dt)

        # Find where the timestamp fits in the transition list - if the
        # timestamp is a transition time, it's part of the "after" period.
        trans_list = self._trans_list_utc if in_utc else self._trans_list
        idx = bisect.bisect_right(trans_list, timestamp)

        # We want to know when the previous transition was, so subtract off 1
        return idx - 1

    def _get_ttinfo(self, idx):
        # For no list or after the last transition, default to _ttinfo_std
        if idx is None or (idx + 1) >= len(self._trans_list):
            return self._ttinfo_std

        # If there is a list and the time is before it, return _ttinfo_before
        if idx < 0:
            return self._ttinfo_before

        return self._trans_idx[idx]

    def _find_ttinfo(self, dt):
        idx = self._resolve_ambiguous_time(dt)

        return self._get_ttinfo(idx)

    def fromutc(self, dt):
        """
        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.

        :param dt:
            A :py:class:`datetime.datetime` object.

        :raises TypeError:
            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.

        :raises ValueError:
            Raised if this is called with a ``dt`` which does not have this
            ``tzinfo`` attached.

        :return:
            Returns a :py:class:`datetime.datetime` object representing the
            wall time in ``self``'s time zone.
        """
        # These isinstance checks are in datetime.tzinfo, so we'll preserve
        # them, even if we don't care about duck typing.
        if not isinstance(dt, datetime.datetime):
            raise TypeError("fromutc() requires a datetime argument")

        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        # First treat UTC as wall time and get the transition we're in.
        idx = self._find_last_transition(dt, in_utc=True)
        tti = self._get_ttinfo(idx)

        dt_out = dt + datetime.timedelta(seconds=tti.offset)

        fold = self.is_ambiguous(dt_out, idx=idx)

        return enfold(dt_out, fold=int(fold))

    def is_ambiguous(self, dt, idx=None):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        if idx is None:
            idx = self._find_last_transition(dt)

        # Calculate the difference in offsets from current to previous
        timestamp = _datetime_to_timestamp(dt)
        tti = self._get_ttinfo(idx)

        if idx is None or idx <= 0:
            return False

        od = self._get_ttinfo(idx - 1).offset - tti.offset
        tt = self._trans_list[idx]          # Transition time

        return timestamp < tt + od

    def _resolve_ambiguous_time(self, dt):
        idx = self._find_last_transition(dt)

        # If we have no transitions, return the index
        _fold = self._fold(dt)
        if idx is None or idx == 0:
            return idx

        # If it's ambiguous and we're in a fold, shift to a different index.
        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))

        return idx - idx_offset

    def utcoffset(self, dt):
        if dt is None:
            return None

        if not self._ttinfo_std:
            return ZERO

        return self._find_ttinfo(dt).delta

    def dst(self, dt):
        if dt is None:
            return None

        if not self._ttinfo_dst:
            return ZERO

        tti = self._find_ttinfo(dt)

        if not tti.isdst:
            return ZERO

        # The documentation says that utcoffset()-dst() must
        # be constant for every dt.
        return tti.dstoffset

    @tzname_in_python2
    def tzname(self, dt):
        if not self._ttinfo_std or dt is None:
            return None
        return self._find_ttinfo(dt).abbr

    def __eq__(self, other):
        if not isinstance(other, tzfile):
            return NotImplemented
        return (self._trans_list == other._trans_list and
                self._trans_idx == other._trans_idx and
                self._ttinfo_list == other._ttinfo_list)

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))

    def __reduce__(self):
        return self.__reduce_ex__(None)

    def __reduce_ex__(self, protocol):
        return (self.__class__, (None, self._filename), self.__dict__)


class tzrange(tzrangebase):
    """
    The ``tzrange`` object is a time zone specified by a set of offsets and
    abbreviations, equivalent to the way the ``TZ`` variable can be specified
    in POSIX-like systems, but using Python delta objects to specify DST
    start, end and offsets.

    :param stdabbr:
        The abbreviation for standard time (e.g. ``'EST'``).

    :param stdoffset:
        An integer or :class:`datetime.timedelta` object or equivalent
        specifying the base offset from UTC.

        If unspecified, +00:00 is used.

    :param dstabbr:
        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).

        If specified, with no other DST information, DST is assumed to occur
        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
        used. If unspecified and no other DST information is specified, it
        is assumed that this zone has no DST.

        If this is unspecified and other DST information is *is* specified,
        DST occurs in the zone but the time zone abbreviation is left
        unchanged.

    :param dstoffset:
        A an integer or :class:`datetime.timedelta` object or equivalent
        specifying the UTC offset during DST. If unspecified and any other DST
        information is specified, it is assumed to be the STD offset +1 hour.

    :param start:
        A :class:`relativedelta.relativedelta` object or equivalent specifying
        the time and time of year that daylight savings time starts. To specify,
        for example, that DST starts at 2AM on the 2nd Sunday in March, pass:

            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``

        If unspecified and any other DST information is specified, the default
        value is 2 AM on the first Sunday in April.

    :param end:
        A :class:`relativedelta.relativedelta` object or equivalent representing
        the time and time of year that daylight savings time ends, with the
        same specification method as in ``start``. One note is that this should
        point to the first time in the *standard* zone, so if a transition
        occurs at 2AM in the DST zone and the clocks are set back 1 hour to 1AM,
        set the `hours` parameter to +1.


    **Examples:**

    .. testsetup:: tzrange

        from dateutil.tz import tzrange, tzstr

    .. doctest:: tzrange

        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
        True

        >>> from dateutil.relativedelta import *
        >>> range1 = tzrange("EST", -18000, "EDT")
        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
        ...                  relativedelta(hours=+2, month=4, day=1,
        ...                                weekday=SU(+1)),
        ...                  relativedelta(hours=+1, month=10, day=31,
        ...                                weekday=SU(-1)))
        >>> tzstr('EST5EDT') == range1 == range2
        True

    """
    def __init__(self, stdabbr, stdoffset=None,
                 dstabbr=None, dstoffset=None,
                 start=None, end=None):

        global relativedelta
        from dateutil import relativedelta

        self._std_abbr = stdabbr
        self._dst_abbr = dstabbr

        try:
            stdoffset = stdoffset.total_seconds()
        except (TypeError, AttributeError):
            pass

        try:
            dstoffset = dstoffset.total_seconds()
        except (TypeError, AttributeError):
            pass

        if stdoffset is not None:
            self._std_offset = datetime.timedelta(seconds=stdoffset)
        else:
            self._std_offset = ZERO

        if dstoffset is not None:
            self._dst_offset = datetime.timedelta(seconds=dstoffset)
        elif dstabbr and stdoffset is not None:
            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)
        else:
            self._dst_offset = ZERO

        if dstabbr and start is None:
            self._start_delta = relativedelta.relativedelta(
                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
        else:
            self._start_delta = start

        if dstabbr and end is None:
            self._end_delta = relativedelta.relativedelta(
                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
        else:
            self._end_delta = end

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = bool(self._start_delta)

    def transitions(self, year):
        """
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        """
        if not self.hasdst:
            return None

        base_year = datetime.datetime(year, 1, 1)

        start = base_year + self._start_delta
        end = base_year + self._end_delta

        return (start, end)

    def __eq__(self, other):
        if not isinstance(other, tzrange):
            return NotImplemented

        return (self._std_abbr == other._std_abbr and
                self._dst_abbr == other._dst_abbr and
                self._std_offset == other._std_offset and
                self._dst_offset == other._dst_offset and
                self._start_delta == other._start_delta and
                self._end_delta == other._end_delta)

    @property
    def _dst_base_offset(self):
        return self._dst_base_offset_


@six.add_metaclass(_TzStrFactory)
class tzstr(tzrange):
    """
    ``tzstr`` objects are time zone objects specified by a time-zone string as
    it would be passed to a ``TZ`` variable on POSIX-style systems (see
    the `GNU C Library: TZ Variable`_ for more details).

    There is one notable exception, which is that POSIX-style time zones use an
    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
    behavior, pass a ``True`` value to ``posix_offset``.

    The :class:`tzrange` object provides the same functionality, but is
    specified using :class:`relativedelta.relativedelta` objects. rather than
    strings.

    :param s:
        A time zone string in ``TZ`` variable format. This can be a
        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x: :class:`unicode`)
        or a stream emitting unicode characters (e.g. :class:`StringIO`).

    :param posix_offset:
        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
        POSIX standard.

    .. caution::

        Prior to version 2.7.0, this function also supported time zones
        in the format:

            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``

        This format is non-standard and has been deprecated; this function
        will raise a :class:`DeprecatedTZFormatWarning` until
        support is removed in a future version.

    .. _`GNU C Library: TZ Variable`:
        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
    """
    def __init__(self, s, posix_offset=False):
        global parser
        from dateutil.parser import _parser as parser

        self._s = s

        res = parser._parsetz(s)
        if res is None or res.any_unused_tokens:
            raise ValueError("unknown string format")

        # Here we break the compatibility with the TZ variable handling.
        # GMT-3 actually *means* the timezone -3.
        if res.stdabbr in ("GMT", "UTC") and not posix_offset:
            res.stdoffset *= -1

        # We must initialize it first, since _delta() needs
        # _std_offset and _dst_offset set. Use False in start/end
        # to avoid building it two times.
        tzrange.__init__(self, res.stdabbr, res.stdoffset,
                         res.dstabbr, res.dstoffset,
                         start=False, end=False)

        if not res.dstabbr:
            self._start_delta = None
            self._end_delta = None
        else:
            self._start_delta = self._delta(res.start)
            if self._start_delta:
                self._end_delta = self._delta(res.end, isend=1)

        self.hasdst = bool(self._start_delta)

    def _delta(self, x, isend=0):
        from dateutil import relativedelta
        kwargs = {}
        if x.month is not None:
            kwargs["month"] = x.month
            if x.weekday is not None:
                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
                if x.week > 0:
                    kwargs["day"] = 1
                else:
                    kwargs["day"] = 31
            elif x.day:
                kwargs["day"] = x.day
        elif x.yday is not None:
            kwargs["yearday"] = x.yday
        elif x.jyday is not None:
            kwargs["nlyearday"] = x.jyday
        if not kwargs:
            # Default is to start on first sunday of april, and end
            # on last sunday of october.
            if not isend:
                kwargs["month"] = 4
                kwargs["day"] = 1
                kwargs["weekday"] = relativedelta.SU(+1)
            else:
                kwargs["month"] = 10
                kwargs["day"] = 31
                kwargs["weekday"] = relativedelta.SU(-1)
        if x.time is not None:
            kwargs["seconds"] = x.time
        else:
            # Default is 2AM.
            kwargs["seconds"] = 7200
        if isend:
            # Convert to standard time, to follow the documented way
            # of working with the extra hour. See the documentation
            # of the tzinfo class.
            delta = self._dst_offset - self._std_offset
            kwargs["seconds"] -= delta.seconds + delta.days * 86400
        return relativedelta.relativedelta(**kwargs)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._s))


class _tzicalvtzcomp(object):
    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
                 tzname=None, rrule=None):
        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom
        self.isdst = isdst
        self.tzname = tzname
        self.rrule = rrule


class _tzicalvtz(_tzinfo):
    def __init__(self, tzid, comps=[]):
        super(_tzicalvtz, self).__init__()

        self._tzid = tzid
        self._comps = comps
        self._cachedate = []
        self._cachecomp = []
        self._cache_lock = _dummy_lock()

    def _find_comp(self, dt):
        if len(self._comps) == 1:
            return self._comps[0]

        dt = dt.replace(tzinfo=None)

        try:
            with self._cache_lock:
                return self._cachecomp[self._cachedate.index(
                    (dt, self._fold(dt)))]
        except ValueError:
            pass

        lastcompdt = None
        lastcomp = None

        for comp in self._comps:
            compdt = self._find_compdt(comp, dt)

            if compdt and (not lastcompdt or lastcompdt < compdt):
                lastcompdt = compdt
                lastcomp = comp

        if not lastcomp:
            # RFC says nothing about what to do when a given
            # time is before the first onset date. We'll look for the
            # first standard component, or the first component, if
            # none is found.
            for comp in self._comps:
                if not comp.isdst:
                    lastcomp = comp
                    break
            else:
                lastcomp = comp[0]

        with self._cache_lock:
            self._cachedate.insert(0, (dt, self._fold(dt)))
            self._cachecomp.insert(0, lastcomp)

            if len(self._cachedate) > 10:
                self._cachedate.pop()
                self._cachecomp.pop()

        return lastcomp

    def _find_compdt(self, comp, dt):
        if comp.tzoffsetdiff < ZERO and self._fold(dt):
            dt -= comp.tzoffsetdiff

        compdt = comp.rrule.before(dt, inc=True)

        return compdt

    def utcoffset(self, dt):
        if dt is None:
            return None

        return self._find_comp(dt).tzoffsetto

    def dst(self, dt):
        comp = self._find_comp(dt)
        if comp.isdst:
            return comp.tzoffsetdiff
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._find_comp(dt).tzname

    def __repr__(self):
        return "<tzicalvtz %s>" % repr(self._tzid)

    __reduce__ = object.__reduce__


class tzical(object):
    """
    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.

    :param `fileobj`:
        A file or stream in iCalendar format, which should be UTF-8 encoded
        with CRLF endings.

    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
    """
    def __init__(self, fileobj):
        global rrule
        from dateutil import rrule

        if isinstance(fileobj, string_types):
            self._s = fileobj
            # ical should be encoded in UTF-8 with CRLF
            fileobj = open(fileobj, 'r')
        else:
            self._s = getattr(fileobj, 'name', repr(fileobj))
            fileobj = _ContextWrapper(fileobj)

        self._vtz = {}

        with fileobj as fobj:
            self._parse_rfc(fobj.read())

    def keys(self):
        """
        Retrieves the available time zones as a list.
        """
        return list(self._vtz.keys())

    def get(self, tzid=None):
        """
        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.

        :param tzid:
            If there is exactly one time zone available, omitting ``tzid``
            or passing :py:const:`None` value returns it. Otherwise a valid
            key (which can be retrieved from :func:`keys`) is required.

        :raises ValueError:
            Raised if ``tzid`` is not specified but there are either more
            or fewer than 1 zone defined.

        :returns:
            Returns either a :py:class:`datetime.tzinfo` object representing
            the relevant time zone or :py:const:`None` if the ``tzid`` was
            not found.
        """
        if tzid is None:
            if len(self._vtz) == 0:
                raise ValueError("no timezones defined")
            elif len(self._vtz) > 1:
                raise ValueError("more than one timezone available")
            tzid = next(iter(self._vtz))

        return self._vtz.get(tzid)

    def _parse_offset(self, s):
        s = s.strip()
        if not s:
            raise ValueError("empty offset")
        if s[0] in ('+', '-'):
            signal = (-1, +1)[s[0] == '+']
            s = s[1:]
        else:
            signal = +1
        if len(s) == 4:
            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal
        elif len(s) == 6:
            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal
        else:
            raise ValueError("invalid offset: " + s)

    def _parse_rfc(self, s):
        lines = s.splitlines()
        if not lines:
            raise ValueError("empty string")

        # Unfold
        i = 0
        while i < len(lines):
            line = lines[i].rstrip()
            if not line:
                del lines[i]
            elif i > 0 and line[0] == " ":
                lines[i-1] += line[1:]
                del lines[i]
            else:
                i += 1

        tzid = None
        comps = []
        invtz = False
        comptype = None
        for line in lines:
            if not line:
                continue
            name, value = line.split(':', 1)
            parms = name.split(';')
            if not parms:
                raise ValueError("empty property name")
            name = parms[0].upper()
            parms = parms[1:]
            if invtz:
                if name == "BEGIN":
                    if value in ("STANDARD", "DAYLIGHT"):
                        # Process component
                        pass
                    else:
                        raise ValueError("unknown component: "+value)
                    comptype = value
                    founddtstart = False
                    tzoffsetfrom = None
                    tzoffsetto = None
                    rrulelines = []
                    tzname = None
                elif name == "END":
                    if value == "VTIMEZONE":
                        if comptype:
                            raise ValueError("component not closed: "+comptype)
                        if not tzid:
                            raise ValueError("mandatory TZID not found")
                        if not comps:
                            raise ValueError(
                                "at least one component is needed")
                        # Process vtimezone
                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
                        invtz = False
                    elif value == comptype:
                        if not founddtstart:
                            raise ValueError("mandatory DTSTART not found")
                        if tzoffsetfrom is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found")
                        if tzoffsetto is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found")
                        # Process component
                        rr = None
                        if rrulelines:
                            rr = rrule.rrulestr("\n".join(rrulelines),
                                                compatible=True,
                                                ignoretz=True,
                                                cache=True)
                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
                                              (comptype == "DAYLIGHT"),
                                              tzname, rr)
                        comps.append(comp)
                        comptype = None
                    else:
                        raise ValueError("invalid component end: "+value)
                elif comptype:
                    if name == "DTSTART":
                        # DTSTART in VTIMEZONE takes a subset of valid RRULE
                        # values under RFC 5545.
                        for parm in parms:
                            if parm != 'VALUE=DATE-TIME':
                                msg = ('Unsupported DTSTART param in ' +
                                       'VTIMEZONE: ' + parm)
                                raise ValueError(msg)
                        rrulelines.append(line)
                        founddtstart = True
                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
                        rrulelines.append(line)
                    elif name == "TZOFFSETFROM":
                        if parms:
                            raise ValueError(
                                "unsupported %s parm: %s " % (name, parms[0]))
                        tzoffsetfrom = self._parse_offset(value)
                    elif name == "TZOFFSETTO":
                        if parms:
                            raise ValueError(
                                "unsupported TZOFFSETTO parm: "+parms[0])
                        tzoffsetto = self._parse_offset(value)
                    elif name == "TZNAME":
                        if parms:
                            raise ValueError(
                                "unsupported TZNAME parm: "+parms[0])
                        tzname = value
                    elif name == "COMMENT":
                        pass
                    else:
                        raise ValueError("unsupported property: "+name)
                else:
                    if name == "TZID":
                        if parms:
                            raise ValueError(
                                "unsupported TZID parm: "+parms[0])
                        tzid = value
                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
                        pass
                    else:
                        raise ValueError("unsupported property: "+name)
            elif name == "BEGIN" and value == "VTIMEZONE":
                tzid = None
                comps = []
                invtz = True

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._s))


if sys.platform != "win32":
    TZFILES = ["/etc/localtime", "localtime"]
    TZPATHS = ["/usr/share/zoneinfo",
               "/usr/lib/zoneinfo",
               "/usr/share/lib/zoneinfo",
               "/etc/zoneinfo"]
else:
    TZFILES = []
    TZPATHS = []

def __get_gettz():
    tzlocal_classes = (tzlocal,)
    if tzwinlocal is not None:
        tzlocal_classes += (tzwinlocal,)

    class GettzFunc(object):
        def __init__(self):

            self.__instances = {}
            self._cache_lock = _dummy_lock()

        def __call__(self, name=None):
            with self._cache_lock:
                rv = self.__instances.get(name, None)

                if rv is None:
                    rv = self.nocache(name=name)
                    if not (name is None or isinstance(rv, tzlocal_classes)):
                        # tzlocal is slightly more complicated than the other
                        # time zone providers because it depends on environment
                        # at construction time, so don't cache that.
                        self.__instances[name] = rv

            return rv

        def cache_clear(self):
            with self._cache_lock:
                self.__instances = {}

        @staticmethod
        def nocache(name=None):
            """A non-cached version of gettz"""
            tz = None
            if not name:
                try:
                    name = os.environ["TZ"]
                except KeyError:
                    pass
            if name is None or name == ":":
                for filepath in TZFILES:
                    if not os.path.isabs(filepath):
                        filename = filepath
                        for path in TZPATHS:
                            filepath = os.path.join(path, filename)
                            if os.path.isfile(filepath):
                                break
                        else:
                            continue
                    if os.path.isfile(filepath):
                        try:
                            tz = tzfile(filepath)
                            break
                        except (IOError, OSError, ValueError):
                            pass
                else:
                    tz = tzlocal()
            else:
                if name.startswith(":"):
                    name = name[1:]
                if os.path.isabs(name):
                    if os.path.isfile(name):
                        tz = tzfile(name)
                    else:
                        tz = None
                else:
                    for path in TZPATHS:
                        filepath = os.path.join(path, name)
                        if not os.path.isfile(filepath):
                            filepath = filepath.replace(' ', '_')
                            if not os.path.isfile(filepath):
                                continue
                        try:
                            tz = tzfile(filepath)
                            break
                        except (IOError, OSError, ValueError):
                            pass
                    else:
                        tz = None
                        if tzwin is not None:
                            try:
                                tz = tzwin(name)
                            except WindowsError:
                                tz = None

                        if not tz:
                            from dateutil.zoneinfo import get_zonefile_instance
                            tz = get_zonefile_instance().get(name)

                        if not tz:
                            for c in name:
                                # name must have at least one offset to be a tzstr
                                if c in "0123456789":
                                    try:
                                        tz = tzstr(name)
                                    except ValueError:
                                        pass
                                    break
                            else:
                                if name in ("GMT", "UTC"):
                                    tz = tzutc()
                                elif name in time.tzname:
                                    tz = tzlocal()
            return tz

    return GettzFunc()

gettz = __get_gettz()
del __get_gettz

def datetime_exists(dt, tz=None):
    """
    Given a datetime and a time zone, determine whether or not a given datetime
    would fall in a gap.

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" exists in ``tz``.

    ..versionadded:: 2.7.0
    """
    if tz is None:
        if dt.tzinfo is None:
            raise ValueError('Datetime is naive and no time zone provided.')
        tz = dt.tzinfo

    dt = dt.replace(tzinfo=None)

    # This is essentially a test of whether or not the datetime can survive
    # a round trip to UTC.
    dt_rt = dt.replace(tzinfo=tz).astimezone(tzutc()).astimezone(tz)
    dt_rt = dt_rt.replace(tzinfo=None)

    return dt == dt_rt


def datetime_ambiguous(dt, tz=None):
    """
    Given a datetime and a time zone, determine whether or not a given datetime
    is ambiguous (i.e if there are two times differentiated only by their DST
    status).

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" is ambiguous in
        ``tz``.

    .. versionadded:: 2.6.0
    """
    if tz is None:
        if dt.tzinfo is None:
            raise ValueError('Datetime is naive and no time zone provided.')

        tz = dt.tzinfo

    # If a time zone defines its own "is_ambiguous" function, we'll use that.
    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)
    if is_ambiguous_fn is not None:
        try:
            return tz.is_ambiguous(dt)
        except:
            pass

    # If it doesn't come out and tell us it's ambiguous, we'll just check if
    # the fold attribute has any effect on this particular date and time.
    dt = dt.replace(tzinfo=tz)
    wall_0 = enfold(dt, fold=0)
    wall_1 = enfold(dt, fold=1)

    same_offset = wall_0.utcoffset() == wall_1.utcoffset()
    same_dst = wall_0.dst() == wall_1.dst()

    return not (same_offset and same_dst)


def resolve_imaginary(dt):
    """
    Given a datetime that may be imaginary, return an existing datetime.

    This function assumes that an imaginary datetime represents what the
    wall time would be in a zone had the offset transition not occurred, so
    it will always fall forward by the transition's change in offset.

    ..doctest::
        >>> from dateutil import tz
        >>> from datetime import datetime
        >>> NYC = tz.gettz('America/New_York')
        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
        2017-03-12 03:30:00-04:00

        >>> KIR = tz.gettz('Pacific/Kiritimati')
        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
        1995-01-02 12:30:00+14:00

    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
    existing datetime, so a round-trip to and from UTC is sufficient to get
    an extant datetime, however, this generally "falls back" to an earlier time
    rather than falling forward to the STD side (though no guarantees are made
    about this behavior).

    :param dt:
        A :class:`datetime.datetime` which may or may not exist.

    :return:
        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
        imaginary, the datetime returned is guaranteed to be the same object
        passed to the function.

    ..versionadded:: 2.7.0
    """
    if dt.tzinfo is not None and not datetime_exists(dt):

        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()
        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()

        dt += curr_offset - old_offset

    return dt


def _datetime_to_timestamp(dt):
    """
    Convert a :class:`datetime.datetime` object to an epoch timestamp in seconds
    since January 1, 1970, ignoring the time zone.
    """
    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()


class _ContextWrapper(object):
    """
    Class for wrapping contexts so that they are passed through in a
    with statement.
    """
    def __init__(self, context):
        self.context = context

    def __enter__(self):
        return self.context

    def __exit__(*args, **kwargs):
        pass

# vim:ts=4:sw=4:et
from datetime import timedelta


class _TzSingleton(type):
    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        super(_TzSingleton, cls).__init__(*args, **kwargs)

    def __call__(cls):
        if cls.__instance is None:
            cls.__instance = super(_TzSingleton, cls).__call__()
        return cls.__instance

class _TzFactory(type):
    def instance(cls, *args, **kwargs):
        """Alternate constructor that returns a fresh instance"""
        return type.__call__(cls, *args, **kwargs)


class _TzOffsetFactory(_TzFactory):
    def __init__(cls, *args, **kwargs):
        cls.__instances = {}

    def __call__(cls, name, offset):
        if isinstance(offset, timedelta):
            key = (name, offset.total_seconds())
        else:
            key = (name, offset)

        instance = cls.__instances.get(key, None)
        if instance is None:
            instance = cls.__instances.setdefault(key,
                                                  cls.instance(name, offset))
        return instance


class _TzStrFactory(_TzFactory):
    def __init__(cls, *args, **kwargs):
        cls.__instances = {}

    def __call__(cls, s, posix_offset=False):
        key = (s, posix_offset)
        instance = cls.__instances.get(key, None)

        if instance is None:
            instance = cls.__instances.setdefault(key,
                cls.instance(s, posix_offset))
        return instance

from six import PY3

from functools import wraps

from datetime import datetime, timedelta, tzinfo


ZERO = timedelta(0)

__all__ = ['tzname_in_python2', 'enfold']


def tzname_in_python2(namefunc):
    """Change unicode output into bytestrings in Python 2

    tzname() API changed in Python 3. It used to return bytes, but was changed
    to unicode strings
    """
    def adjust_encoding(*args, **kwargs):
        name = namefunc(*args, **kwargs)
        if name is not None and not PY3:
            name = name.encode()

        return name

    return adjust_encoding


# The following is adapted from Alexander Belopolsky's tz library
# https://github.com/abalkin/tz
if hasattr(datetime, 'fold'):
    # This is the pre-python 3.6 fold situation
    def enfold(dt, fold=1):
        """
        Provides a unified interface for assigning the ``fold`` attribute to
        datetimes both before and after the implementation of PEP-495.

        :param fold:
            The value for the ``fold`` attribute in the returned datetime. This
            should be either 0 or 1.

        :return:
            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
            ``fold`` for all versions of Python. In versions prior to
            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
            subclass of :py:class:`datetime.datetime` with the ``fold``
            attribute added, if ``fold`` is 1.

        .. versionadded:: 2.6.0
        """
        return dt.replace(fold=fold)

else:
    class _DatetimeWithFold(datetime):
        """
        This is a class designed to provide a PEP 495-compliant interface for
        Python versions before 3.6. It is used only for dates in a fold, so
        the ``fold`` attribute is fixed at ``1``.

        .. versionadded:: 2.6.0
        """
        __slots__ = ()

        def replace(self, *args, **kwargs):
            """
            Return a datetime with the same attributes, except for those
            attributes given new values by whichever keyword arguments are
            specified. Note that tzinfo=None can be specified to create a naive
            datetime from an aware datetime with no conversion of date and time
            data.

            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
            return a ``datetime.datetime`` even if ``fold`` is unchanged.
            """
            argnames = (
                'year', 'month', 'day', 'hour', 'minute', 'second',
                'microsecond', 'tzinfo'
            )

            for arg, argname in zip(args, argnames):
                if argname in kwargs:
                    raise TypeError('Duplicate argument: {}'.format(argname))

                kwargs[argname] = arg

            for argname in argnames:
                if argname not in kwargs:
                    kwargs[argname] = getattr(self, argname)

            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime

            return dt_class(**kwargs)

        @property
        def fold(self):
            return 1

    def enfold(dt, fold=1):
        """
        Provides a unified interface for assigning the ``fold`` attribute to
        datetimes both before and after the implementation of PEP-495.

        :param fold:
            The value for the ``fold`` attribute in the returned datetime. This
            should be either 0 or 1.

        :return:
            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
            ``fold`` for all versions of Python. In versions prior to
            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
            subclass of :py:class:`datetime.datetime` with the ``fold``
            attribute added, if ``fold`` is 1.

        .. versionadded:: 2.6.0
        """
        if getattr(dt, 'fold', 0) == fold:
            return dt

        args = dt.timetuple()[:6]
        args += (dt.microsecond, dt.tzinfo)

        if fold:
            return _DatetimeWithFold(*args)
        else:
            return datetime(*args)


def _validate_fromutc_inputs(f):
    """
    The CPython version of ``fromutc`` checks that the input is a ``datetime``
    object and that ``self`` is attached as its ``tzinfo``.
    """
    @wraps(f)
    def fromutc(self, dt):
        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")
        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        return f(self, dt)

    return fromutc


class _tzinfo(tzinfo):
    """
    Base class for all ``dateutil`` ``tzinfo`` objects.
    """

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """

        dt = dt.replace(tzinfo=self)

        wall_0 = enfold(dt, fold=0)
        wall_1 = enfold(dt, fold=1)

        same_offset = wall_0.utcoffset() == wall_1.utcoffset()
        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)

        return same_dt and not same_offset

    def _fold_status(self, dt_utc, dt_wall):
        """
        Determine the fold status of a "wall" datetime, given a representation
        of the same datetime as a (naive) UTC datetime. This is calculated based
        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
        datetimes, and that this offset is the actual number of hours separating
        ``dt_utc`` and ``dt_wall``.

        :param dt_utc:
            Representation of the datetime as UTC

        :param dt_wall:
            Representation of the datetime as "wall time". This parameter must
            either have a `fold` attribute or have a fold-naive
            :class:`datetime.tzinfo` attached, otherwise the calculation may
            fail.
        """
        if self.is_ambiguous(dt_wall):
            delta_wall = dt_wall - dt_utc
            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))
        else:
            _fold = 0

        return _fold

    def _fold(self, dt):
        return getattr(dt, 'fold', 0)

    def _fromutc(self, dt):
        """
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurence, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        """

        # Re-implement the algorithm from Python's datetime.py
        dtoff = dt.utcoffset()
        if dtoff is None:
            raise ValueError("fromutc() requires a non-None utcoffset() "
                             "result")

        # The original datetime.py code assumes that `dst()` defaults to
        # zero during ambiguous times. PEP 495 inverts this presumption, so
        # for pre-PEP 495 versions of python, we need to tweak the algorithm.
        dtdst = dt.dst()
        if dtdst is None:
            raise ValueError("fromutc() requires a non-None dst() result")
        delta = dtoff - dtdst

        dt += delta
        # Set fold=1 so we can default to being in the fold for
        # ambiguous dates.
        dtdst = enfold(dt, fold=1).dst()
        if dtdst is None:
            raise ValueError("fromutc(): dt.dst gave inconsistent "
                             "results; cannot convert")
        return dt + dtdst

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        """
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurance, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        """
        dt_wall = self._fromutc(dt)

        # Calculate the fold status given the two datetimes.
        _fold = self._fold_status(dt, dt_wall)

        # Set the default fold value for ambiguous dates
        return enfold(dt_wall, fold=_fold)


class tzrangebase(_tzinfo):
    """
    This is an abstract base class for time zones represented by an annual
    transition into and out of DST. Child classes should implement the following
    methods:

        * ``__init__(self, *args, **kwargs)``
        * ``transitions(self, year)`` - this is expected to return a tuple of
          datetimes representing the DST on and off transitions in standard
          time.

    A fully initialized ``tzrangebase`` subclass should also provide the
    following attributes:
        * ``hasdst``: Boolean whether or not the zone uses DST.
        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
          representing the respective UTC offsets.
        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
          abbreviations in DST and STD, respectively.
        * ``_hasdst``: Whether or not the zone has DST.

    .. versionadded:: 2.6.0
    """
    def __init__(self):
        raise NotImplementedError('tzrangebase is an abstract base class')

    def utcoffset(self, dt):
        isdst = self._isdst(dt)

        if isdst is None:
            return None
        elif isdst:
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        isdst = self._isdst(dt)

        if isdst is None:
            return None
        elif isdst:
            return self._dst_base_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        if self._isdst(dt):
            return self._dst_abbr
        else:
            return self._std_abbr

    def fromutc(self, dt):
        """ Given a datetime in UTC, return local time """
        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")

        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        # Get transitions - if there are none, fixed offset
        transitions = self.transitions(dt.year)
        if transitions is None:
            return dt + self.utcoffset(dt)

        # Get the transition times in UTC
        dston, dstoff = transitions

        dston -= self._std_offset
        dstoff -= self._std_offset

        utc_transitions = (dston, dstoff)
        dt_utc = dt.replace(tzinfo=None)

        isdst = self._naive_isdst(dt_utc, utc_transitions)

        if isdst:
            dt_wall = dt + self._dst_offset
        else:
            dt_wall = dt + self._std_offset

        _fold = int(not isdst and self.is_ambiguous(dt_wall))

        return enfold(dt_wall, fold=_fold)

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        if not self.hasdst:
            return False

        start, end = self.transitions(dt.year)

        dt = dt.replace(tzinfo=None)
        return (end <= dt < end + self._dst_base_offset)

    def _isdst(self, dt):
        if not self.hasdst:
            return False
        elif dt is None:
            return None

        transitions = self.transitions(dt.year)

        if transitions is None:
            return False

        dt = dt.replace(tzinfo=None)

        isdst = self._naive_isdst(dt, transitions)

        # Handle ambiguous dates
        if not isdst and self.is_ambiguous(dt):
            return not self._fold(dt)
        else:
            return isdst

    def _naive_isdst(self, dt, transitions):
        dston, dstoff = transitions

        dt = dt.replace(tzinfo=None)

        if dston < dstoff:
            isdst = dston <= dt < dstoff
        else:
            isdst = not dstoff <= dt < dston

        return isdst

    @property
    def _dst_base_offset(self):
        return self._dst_offset - self._std_offset

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(...)" % self.__class__.__name__

    __reduce__ = object.__reduce__
from .tz import *

#: Convenience constant providing a :class:`tzutc()` instance
#:
#: .. versionadded:: 2.7.0
UTC = tzutc()

__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz",
           "enfold", "datetime_ambiguous", "datetime_exists",
           "resolve_imaginary", "UTC", "DeprecatedTzFormatWarning"]


class DeprecatedTzFormatWarning(Warning):
    """Warning raised when time zones are parsed from deprecated formats."""
# -*- coding: utf-8 -*-
"""
This module offers a generic date/time string parser which is able to parse
most known formats to represent a date and/or time.

This module attempts to be forgiving with regards to unlikely input formats,
returning a datetime object even for dates which are ambiguous. If an element
of a date/time stamp is omitted, the following rules are applied:

- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
  specified.
- If a time zone is omitted, a timezone-naive datetime is returned.

If any other elements are missing, they are taken from the
:class:`datetime.datetime` object passed to the parameter ``default``. If this
results in a day number exceeding the valid number of days per month, the
value falls back to the end of the month.

Additional resources about date/time string formats can be found below:

- `A summary of the international standard date and time notation
  <http://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
- `W3C Date and Time Formats <http://www.w3.org/TR/NOTE-datetime>`_
- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
- `CPAN ParseDate module
  <http://search.cpan.org/~muir/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
- `Java SimpleDateFormat Class
  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
"""
from __future__ import unicode_literals

import datetime
import re
import string
import time
import warnings

from calendar import monthrange
from io import StringIO

import six
from six import binary_type, integer_types, text_type

from decimal import Decimal

from warnings import warn

from .. import relativedelta
from .. import tz

__all__ = ["parse", "parserinfo"]


# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth
# making public and/or figuring out if there is something we can
# take off their plate.
class _timelex(object):
    # Fractional seconds are sometimes split by a comma
    _split_decimal = re.compile("([.,])")

    def __init__(self, instream):
        if six.PY2:
            # In Python 2, we can't duck type properly because unicode has
            # a 'decode' function, and we'd be double-decoding
            if isinstance(instream, (binary_type, bytearray)):
                instream = instream.decode()
        else:
            if getattr(instream, 'decode', None) is not None:
                instream = instream.decode()

        if isinstance(instream, text_type):
            instream = StringIO(instream)
        elif getattr(instream, 'read', None) is None:
            raise TypeError('Parser must be a string or character stream, not '
                            '{itype}'.format(itype=instream.__class__.__name__))

        self.instream = instream
        self.charstack = []
        self.tokenstack = []
        self.eof = False

    def get_token(self):
        """
        This function breaks the time string into lexical units (tokens), which
        can be parsed by the parser. Lexical units are demarcated by changes in
        the character set, so any continuous string of letters is considered
        one unit, any continuous string of numbers is considered one unit.

        The main complication arises from the fact that dots ('.') can be used
        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
        "4:30:21.447"). As such, it is necessary to read the full context of
        any dot-separated strings before breaking it into tokens; as such, this
        function maintains a "token stack", for when the ambiguous context
        demands that multiple tokens be parsed at once.
        """
        if self.tokenstack:
            return self.tokenstack.pop(0)

        seenletters = False
        token = None
        state = None

        while not self.eof:
            # We only realize that we've reached the end of a token when we
            # find a character that's not part of the current token - since
            # that character may be part of the next token, it's stored in the
            # charstack.
            if self.charstack:
                nextchar = self.charstack.pop(0)
            else:
                nextchar = self.instream.read(1)
                while nextchar == '\x00':
                    nextchar = self.instream.read(1)

            if not nextchar:
                self.eof = True
                break
            elif not state:
                # First character of the token - determines if we're starting
                # to parse a word, a number or something else.
                token = nextchar
                if self.isword(nextchar):
                    state = 'a'
                elif self.isnum(nextchar):
                    state = '0'
                elif self.isspace(nextchar):
                    token = ' '
                    break  # emit token
                else:
                    break  # emit token
            elif state == 'a':
                # If we've already started reading a word, we keep reading
                # letters until we find something that's not part of a word.
                seenletters = True
                if self.isword(nextchar):
                    token += nextchar
                elif nextchar == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == '0':
                # If we've already started reading a number, we keep reading
                # numbers until we find something that doesn't fit.
                if self.isnum(nextchar):
                    token += nextchar
                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == 'a.':
                # If we've seen some letters and a dot separator, continue
                # parsing, and the tokens will be broken up later.
                seenletters = True
                if nextchar == '.' or self.isword(nextchar):
                    token += nextchar
                elif self.isnum(nextchar) and token[-1] == '.':
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == '0.':
                # If we've seen at least one dot separator, keep going, we'll
                # break up the tokens later.
                if nextchar == '.' or self.isnum(nextchar):
                    token += nextchar
                elif self.isword(nextchar) and token[-1] == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token

        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
                                       token[-1] in '.,')):
            l = self._split_decimal.split(token)
            token = l[0]
            for tok in l[1:]:
                if tok:
                    self.tokenstack.append(tok)

        if state == '0.' and token.count('.') == 0:
            token = token.replace(',', '.')

        return token

    def __iter__(self):
        return self

    def __next__(self):
        token = self.get_token()
        if token is None:
            raise StopIteration

        return token

    def next(self):
        return self.__next__()  # Python 2.x support

    @classmethod
    def split(cls, s):
        return list(cls(s))

    @classmethod
    def isword(cls, nextchar):
        """ Whether or not the next character is part of a word """
        return nextchar.isalpha()

    @classmethod
    def isnum(cls, nextchar):
        """ Whether the next character is part of a number """
        return nextchar.isdigit()

    @classmethod
    def isspace(cls, nextchar):
        """ Whether the next character is whitespace """
        return nextchar.isspace()


class _resultbase(object):

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def _repr(self, classname):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, repr(value)))
        return "%s(%s)" % (classname, ", ".join(l))

    def __len__(self):
        return (sum(getattr(self, attr) is not None
                    for attr in self.__slots__))

    def __repr__(self):
        return self._repr(self.__class__.__name__)


class parserinfo(object):
    """
    Class which handles what inputs are accepted. Subclass this to customize
    the language and acceptable values for each parameter.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM
        and YMD. Default is ``False``.

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
        to be the year, otherwise the last number is taken to be the year.
        Default is ``False``.
    """

    # m from a.m/p.m, t from ISO T separator
    JUMP = [" ", ".", ",", ";", "-", "/", "'",
            "at", "on", "and", "ad", "m", "t", "of",
            "st", "nd", "rd", "th"]

    WEEKDAYS = [("Mon", "Monday"),
                ("Tue", "Tuesday"),     # TODO: "Tues"
                ("Wed", "Wednesday"),
                ("Thu", "Thursday"),    # TODO: "Thurs"
                ("Fri", "Friday"),
                ("Sat", "Saturday"),
                ("Sun", "Sunday")]
    MONTHS = [("Jan", "January"),
              ("Feb", "February"),      # TODO: "Febr"
              ("Mar", "March"),
              ("Apr", "April"),
              ("May", "May"),
              ("Jun", "June"),
              ("Jul", "July"),
              ("Aug", "August"),
              ("Sep", "Sept", "September"),
              ("Oct", "October"),
              ("Nov", "November"),
              ("Dec", "December")]
    HMS = [("h", "hour", "hours"),
           ("m", "minute", "minutes"),
           ("s", "second", "seconds")]
    AMPM = [("am", "a"),
            ("pm", "p")]
    UTCZONE = ["UTC", "GMT", "Z"]
    PERTAIN = ["of"]
    TZOFFSET = {}
    # TODO: ERA = ["AD", "BC", "CE", "BCE", "Stardate",
    #              "Anno Domini", "Year of Our Lord"]

    def __init__(self, dayfirst=False, yearfirst=False):
        self._jump = self._convert(self.JUMP)
        self._weekdays = self._convert(self.WEEKDAYS)
        self._months = self._convert(self.MONTHS)
        self._hms = self._convert(self.HMS)
        self._ampm = self._convert(self.AMPM)
        self._utczone = self._convert(self.UTCZONE)
        self._pertain = self._convert(self.PERTAIN)

        self.dayfirst = dayfirst
        self.yearfirst = yearfirst

        self._year = time.localtime().tm_year
        self._century = self._year // 100 * 100

    def _convert(self, lst):
        dct = {}
        for i, v in enumerate(lst):
            if isinstance(v, tuple):
                for v in v:
                    dct[v.lower()] = i
            else:
                dct[v.lower()] = i
        return dct

    def jump(self, name):
        return name.lower() in self._jump

    def weekday(self, name):
        try:
            return self._weekdays[name.lower()]
        except KeyError:
            pass
        return None

    def month(self, name):
        try:
            return self._months[name.lower()] + 1
        except KeyError:
            pass
        return None

    def hms(self, name):
        try:
            return self._hms[name.lower()]
        except KeyError:
            return None

    def ampm(self, name):
        try:
            return self._ampm[name.lower()]
        except KeyError:
            return None

    def pertain(self, name):
        return name.lower() in self._pertain

    def utczone(self, name):
        return name.lower() in self._utczone

    def tzoffset(self, name):
        if name in self._utczone:
            return 0

        return self.TZOFFSET.get(name)

    def convertyear(self, year, century_specified=False):
        if year < 100 and not century_specified:
            year += self._century
            if abs(year - self._year) >= 50:
                if year < self._year:
                    year += 100
                else:
                    year -= 100
        return year

    def validate(self, res):
        # move to info
        if res.year is not None:
            res.year = self.convertyear(res.year, res.century_specified)

        if res.tzoffset == 0 and not res.tzname or res.tzname == 'Z':
            res.tzname = "UTC"
            res.tzoffset = 0
        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
            res.tzoffset = 0
        return True


class _ymd(list):
    def __init__(self, *args, **kwargs):
        super(self.__class__, self).__init__(*args, **kwargs)
        self.century_specified = False
        self.dstridx = None
        self.mstridx = None
        self.ystridx = None

    @property
    def has_year(self):
        return self.ystridx is not None

    @property
    def has_month(self):
        return self.mstridx is not None

    @property
    def has_day(self):
        return self.dstridx is not None

    def could_be_day(self, value):
        if self.has_day:
            return False
        elif not self.has_month:
            return 1 <= value <= 31
        elif not self.has_year:
            # Be permissive, assume leapyear
            month = self[self.mstridx]
            return 1 <= value <= monthrange(2000, month)[1]
        else:
            month = self[self.mstridx]
            year = self[self.ystridx]
            return 1 <= value <= monthrange(year, month)[1]

    def append(self, val, label=None):
        if hasattr(val, '__len__'):
            if val.isdigit() and len(val) > 2:
                self.century_specified = True
                if label not in [None, 'Y']:  # pragma: no cover
                    raise ValueError(label)
                label = 'Y'
        elif val > 100:
            self.century_specified = True
            if label not in [None, 'Y']:  # pragma: no cover
                raise ValueError(label)
            label = 'Y'

        super(self.__class__, self).append(int(val))

        if label == 'M':
            if self.has_month:
                raise ValueError('Month is already set')
            self.mstridx = len(self) - 1
        elif label == 'D':
            if self.has_day:
                raise ValueError('Day is already set')
            self.dstridx = len(self) - 1
        elif label == 'Y':
            if self.has_year:
                raise ValueError('Year is already set')
            self.ystridx = len(self) - 1

    def resolve_ymd(self, yearfirst, dayfirst):
        len_ymd = len(self)
        year, month, day = (None, None, None)

        mstridx = self.mstridx

        if len_ymd > 3:
            raise ValueError("More than three YMD values")
        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):
            # One member, or two members with a month string
            if mstridx is not None:
                month = self[mstridx]
                del self[mstridx]

            if len_ymd > 1 or mstridx is None:
                if self[0] > 31:
                    year = self[0]
                else:
                    day = self[0]

        elif len_ymd == 2:
            # Two members with numbers
            if self[0] > 31:
                # 99-01
                year, month = self
            elif self[1] > 31:
                # 01-99
                month, year = self
            elif dayfirst and self[1] <= 12:
                # 13-01
                day, month = self
            else:
                # 01-13
                month, day = self

        elif len_ymd == 3:
            # Three members
            if mstridx == 0:
                if self[1] > 31:
                    # Apr-2003-25
                    month, year, day = self
                else:
                    month, day, year = self
            elif mstridx == 1:
                if self[0] > 31 or (yearfirst and self[2] <= 31):
                    # 99-Jan-01
                    year, month, day = self
                else:
                    # 01-Jan-01
                    # Give precendence to day-first, since
                    # two-digit years is usually hand-written.
                    day, month, year = self

            elif mstridx == 2:
                # WTF!?
                if self[1] > 31:
                    # 01-99-Jan
                    day, year, month = self
                else:
                    # 99-01-Jan
                    year, day, month = self

            else:
                if (self[0] > 31 or
                    self.ystridx == 0 or
                        (yearfirst and self[1] <= 12 and self[2] <= 31)):
                    # 99-01-01
                    if dayfirst and self[2] <= 12:
                        year, day, month = self
                    else:
                        year, month, day = self
                elif self[0] > 12 or (dayfirst and self[1] <= 12):
                    # 13-01-01
                    day, month, year = self
                else:
                    # 01-13-01
                    month, day, year = self

        return year, month, day


class parser(object):
    def __init__(self, info=None):
        self.info = info or parserinfo()

    def parse(self, timestr, default=None,
              ignoretz=False, tzinfos=None, **kwargs):
        """
        Parse the date/time string into a :class:`datetime.datetime` object.

        :param timestr:
            Any date/time string using the supported formats.

        :param default:
            The default datetime object, if this is a datetime object and not
            ``None``, elements specified in ``timestr`` replace elements in the
            default object.

        :param ignoretz:
            If set ``True``, time zones in parsed strings are ignored and a
            naive :class:`datetime.datetime` object is returned.

        :param tzinfos:
            Additional time zone names / aliases which may be present in the
            string. This argument maps time zone names (and optionally offsets
            from those time zones) to time zones. This parameter can be a
            dictionary with timezone aliases mapping time zone names to time
            zones or a function taking two parameters (``tzname`` and
            ``tzoffset``) and returning a time zone.

            The timezones to which the names are mapped can be an integer
            offset from UTC in seconds or a :class:`tzinfo` object.

            .. doctest::
               :options: +NORMALIZE_WHITESPACE

                >>> from dateutil.parser import parse
                >>> from dateutil.tz import gettz
                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21,
                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

            This parameter is ignored if ``ignoretz`` is set.

        :param \\*\\*kwargs:
            Keyword arguments as passed to ``_parse()``.

        :return:
            Returns a :class:`datetime.datetime` object or, if the
            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
            first element being a :class:`datetime.datetime` object, the second
            a tuple containing the fuzzy tokens.

        :raises ValueError:
            Raised for invalid or unknown string format, if the provided
            :class:`tzinfo` is not in a valid format, or if an invalid date
            would be created.

        :raises TypeError:
            Raised for non-string or character stream input.

        :raises OverflowError:
            Raised if the parsed date exceeds the largest valid C integer on
            your system.
        """

        if default is None:
            default = datetime.datetime.now().replace(hour=0, minute=0,
                                                      second=0, microsecond=0)

        res, skipped_tokens = self._parse(timestr, **kwargs)

        if res is None:
            raise ValueError("Unknown string format:", timestr)

        if len(res) == 0:
            raise ValueError("String does not contain a date:", timestr)

        ret = self._build_naive(res, default)

        if not ignoretz:
            ret = self._build_tzaware(ret, res, tzinfos)

        if kwargs.get('fuzzy_with_tokens', False):
            return ret, skipped_tokens
        else:
            return ret

    class _result(_resultbase):
        __slots__ = ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond",
                     "tzname", "tzoffset", "ampm","any_unused_tokens"]

    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
               fuzzy_with_tokens=False):
        """
        Private method which performs the heavy lifting of parsing, called from
        ``parse()``, which passes on its ``kwargs`` to this function.

        :param timestr:
            The string to parse.

        :param dayfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
            ``yearfirst`` is set to ``True``, this distinguishes between YDM
            and YMD. If set to ``None``, this value is retrieved from the
            current :class:`parserinfo` object (which itself defaults to
            ``False``).

        :param yearfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
            to be the year, otherwise the last number is taken to be the year.
            If this is set to ``None``, the value is retrieved from the current
            :class:`parserinfo` object (which itself defaults to ``False``).

        :param fuzzy:
            Whether to allow fuzzy parsing, allowing for string like "Today is
            January 1, 2047 at 8:21:00AM".

        :param fuzzy_with_tokens:
            If ``True``, ``fuzzy`` is automatically set to True, and the parser
            will return a tuple where the first element is the parsed
            :class:`datetime.datetime` datetimestamp and the second element is
            a tuple containing the portions of the string which were ignored:

            .. doctest::

                >>> from dateutil.parser import parse
                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

        """
        if fuzzy_with_tokens:
            fuzzy = True

        info = self.info

        if dayfirst is None:
            dayfirst = info.dayfirst

        if yearfirst is None:
            yearfirst = info.yearfirst

        res = self._result()
        l = _timelex.split(timestr)         # Splits the timestr into tokens

        skipped_idxs = []

        # year/month/day list
        ymd = _ymd()

        len_l = len(l)
        i = 0
        try:
            while i < len_l:

                # Check if it's a number
                value_repr = l[i]
                try:
                    value = float(value_repr)
                except ValueError:
                    value = None

                if value is not None:
                    # Numeric token
                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)

                # Check weekday
                elif info.weekday(l[i]) is not None:
                    value = info.weekday(l[i])
                    res.weekday = value

                # Check month name
                elif info.month(l[i]) is not None:
                    value = info.month(l[i])
                    ymd.append(value, 'M')

                    if i + 1 < len_l:
                        if l[i + 1] in ('-', '/'):
                            # Jan-01[-99]
                            sep = l[i + 1]
                            ymd.append(l[i + 2])

                            if i + 3 < len_l and l[i + 3] == sep:
                                # Jan-01-99
                                ymd.append(l[i + 4])
                                i += 2

                            i += 2

                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and
                              info.pertain(l[i + 2])):
                            # Jan of 01
                            # In this case, 01 is clearly year
                            if l[i + 4].isdigit():
                                # Convert it here to become unambiguous
                                value = int(l[i + 4])
                                year = str(info.convertyear(value))
                                ymd.append(year, 'Y')
                            else:
                                # Wrong guess
                                pass
                                # TODO: not hit in tests
                            i += 4

                # Check am/pm
                elif info.ampm(l[i]) is not None:
                    value = info.ampm(l[i])
                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)

                    if val_is_ampm:
                        res.hour = self._adjust_ampm(res.hour, value)
                        res.ampm = value

                    elif fuzzy:
                        skipped_idxs.append(i)

                # Check for a timezone name
                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
                    res.tzname = l[i]
                    res.tzoffset = info.tzoffset(res.tzname)

                    # Check for something like GMT+3, or BRST+3. Notice
                    # that it doesn't mean "I am 3 hours after GMT", but
                    # "my time +3 is GMT". If found, we reverse the
                    # logic so that timezone parsing code will get it
                    # right.
                    if i + 1 < len_l and l[i + 1] in ('+', '-'):
                        l[i + 1] = ('+', '-')[l[i + 1] == '+']
                        res.tzoffset = None
                        if info.utczone(res.tzname):
                            # With something like GMT+3, the timezone
                            # is *not* GMT.
                            res.tzname = None

                # Check for a numbered timezone
                elif res.hour is not None and l[i] in ('+', '-'):
                    signal = (-1, 1)[l[i] == '+']
                    len_li = len(l[i + 1])

                    # TODO: check that l[i + 1] is integer?
                    if len_li == 4:
                        # -0300
                        hour_offset = int(l[i + 1][:2])
                        min_offset = int(l[i + 1][2:])
                    elif i + 2 < len_l and l[i + 2] == ':':
                        # -03:00
                        hour_offset = int(l[i + 1])
                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?
                        i += 2
                    elif len_li <= 2:
                        # -[0]3
                        hour_offset = int(l[i + 1][:2])
                        min_offset = 0
                    else:
                        raise ValueError(timestr)

                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)

                    # Look for a timezone name between parenthesis
                    if (i + 5 < len_l and
                            info.jump(l[i + 2]) and l[i + 3] == '(' and
                            l[i + 5] == ')' and
                            3 <= len(l[i + 4]) and
                            self._could_be_tzname(res.hour, res.tzname,
                                                  None, l[i + 4])):
                        # -0300 (BRST)
                        res.tzname = l[i + 4]
                        i += 4

                    i += 1

                # Check jumps
                elif not (info.jump(l[i]) or fuzzy):
                    raise ValueError(timestr)

                else:
                    skipped_idxs.append(i)
                i += 1

            # Process year/month/day
            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)

            res.century_specified = ymd.century_specified
            res.year = year
            res.month = month
            res.day = day

        except (IndexError, ValueError):
            return None, None

        if not info.validate(res):
            return None, None

        if fuzzy_with_tokens:
            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
            return res, tuple(skipped_tokens)
        else:
            return res, None

    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
        # Token is a number
        value_repr = tokens[idx]
        try:
            value = self._to_decimal(value_repr)
        except Exception as e:
            six.raise_from(ValueError('Unknown numeric token'), e)

        len_li = len(value_repr)

        len_l = len(tokens)

        if (len(ymd) == 3 and len_li in (2, 4) and
            res.hour is None and
            (idx + 1 >= len_l or
             (tokens[idx + 1] != ':' and
              info.hms(tokens[idx + 1]) is None))):
            # 19990101T23[59]
            s = tokens[idx]
            res.hour = int(s[:2])

            if len_li == 4:
                res.minute = int(s[2:])

        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
            # YYMMDD or HHMMSS[.ss]
            s = tokens[idx]

            if not ymd and '.' not in tokens[idx]:
                ymd.append(s[:2])
                ymd.append(s[2:4])
                ymd.append(s[4:])
            else:
                # 19990101T235959[.59]

                # TODO: Check if res attributes already set.
                res.hour = int(s[:2])
                res.minute = int(s[2:4])
                res.second, res.microsecond = self._parsems(s[4:])

        elif len_li in (8, 12, 14):
            # YYYYMMDD
            s = tokens[idx]
            ymd.append(s[:4], 'Y')
            ymd.append(s[4:6])
            ymd.append(s[6:8])

            if len_li > 8:
                res.hour = int(s[8:10])
                res.minute = int(s[10:12])

                if len_li > 12:
                    res.second = int(s[12:])

        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
            # HH[ ]h or MM[ ]m or SS[.ss][ ]s
            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
            if hms is not None:
                # TODO: checking that hour/minute/second are not
                # already set?
                self._assign_hms(res, value_repr, hms)

        elif idx + 2 < len_l and tokens[idx + 1] == ':':
            # HH:MM[:SS[.ss]]
            res.hour = int(value)
            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
            (res.minute, res.second) = self._parse_min_sec(value)

            if idx + 4 < len_l and tokens[idx + 3] == ':':
                res.second, res.microsecond = self._parsems(tokens[idx + 4])

                idx += 2

            idx += 2

        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
            sep = tokens[idx + 1]
            ymd.append(value_repr)

            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
                if tokens[idx + 2].isdigit():
                    # 01-01[-01]
                    ymd.append(tokens[idx + 2])
                else:
                    # 01-Jan[-01]
                    value = info.month(tokens[idx + 2])

                    if value is not None:
                        ymd.append(value, 'M')
                    else:
                        raise ValueError()

                if idx + 3 < len_l and tokens[idx + 3] == sep:
                    # We have three members
                    value = info.month(tokens[idx + 4])

                    if value is not None:
                        ymd.append(value, 'M')
                    else:
                        ymd.append(tokens[idx + 4])
                    idx += 2

                idx += 1
            idx += 1

        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
                # 12 am
                hour = int(value)
                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
                idx += 1
            else:
                # Year, month or day
                ymd.append(value)
            idx += 1

        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
            # 12am
            hour = int(value)
            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
            idx += 1

        elif ymd.could_be_day(value):
            ymd.append(value)

        elif not fuzzy:
            raise ValueError()

        return idx

    def _find_hms_idx(self, idx, tokens, info, allow_jump):
        len_l = len(tokens)

        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
            # There is an "h", "m", or "s" label following this token.  We take
            # assign the upcoming label to the current token.
            # e.g. the "12" in 12h"
            hms_idx = idx + 1

        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
              info.hms(tokens[idx+2]) is not None):
            # There is a space and then an "h", "m", or "s" label.
            # e.g. the "12" in "12 h"
            hms_idx = idx + 2

        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
            # There is a "h", "m", or "s" preceeding this token.  Since neither
            # of the previous cases was hit, there is no label following this
            # token, so we use the previous label.
            # e.g. the "04" in "12h04"
            hms_idx = idx-1

        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
              info.hms(tokens[idx-2]) is not None):
            # If we are looking at the final token, we allow for a
            # backward-looking check to skip over a space.
            # TODO: Are we sure this is the right condition here?
            hms_idx = idx - 2

        else:
            hms_idx = None

        return hms_idx

    def _assign_hms(self, res, value_repr, hms):
        # See GH issue #427, fixing float rounding
        value = self._to_decimal(value_repr)

        if hms == 0:
            # Hour
            res.hour = int(value)
            if value % 1:
                res.minute = int(60*(value % 1))

        elif hms == 1:
            (res.minute, res.second) = self._parse_min_sec(value)

        elif hms == 2:
            (res.second, res.microsecond) = self._parsems(value_repr)

    def _could_be_tzname(self, hour, tzname, tzoffset, token):
        return (hour is not None and
                tzname is None and
                tzoffset is None and
                len(token) <= 5 and
                all(x in string.ascii_uppercase for x in token))

    def _ampm_valid(self, hour, ampm, fuzzy):
        """
        For fuzzy parsing, 'a' or 'am' (both valid English words)
        may erroneously trigger the AM/PM flag. Deal with that
        here.
        """
        val_is_ampm = True

        # If there's already an AM/PM flag, this one isn't one.
        if fuzzy and ampm is not None:
            val_is_ampm = False

        # If AM/PM is found and hour is not, raise a ValueError
        if hour is None:
            if fuzzy:
                val_is_ampm = False
            else:
                raise ValueError('No hour specified with AM or PM flag.')
        elif not 0 <= hour <= 12:
            # If AM/PM is found, it's a 12 hour clock, so raise
            # an error for invalid range
            if fuzzy:
                val_is_ampm = False
            else:
                raise ValueError('Invalid hour specified for 12-hour clock.')

        return val_is_ampm

    def _adjust_ampm(self, hour, ampm):
        if hour < 12 and ampm == 1:
            hour += 12
        elif hour == 12 and ampm == 0:
            hour = 0
        return hour

    def _parse_min_sec(self, value):
        # TODO: Every usage of this function sets res.second to the return
        # value. Are there any cases where second will be returned as None and
        # we *dont* want to set res.second = None?
        minute = int(value)
        second = None

        sec_remainder = value % 1
        if sec_remainder:
            second = int(60 * sec_remainder)
        return (minute, second)

    def _parsems(self, value):
        """Parse a I[.F] seconds value into (seconds, microseconds)."""
        if "." not in value:
            return int(value), 0
        else:
            i, f = value.split(".")
            return int(i), int(f.ljust(6, "0")[:6])

    def _parse_hms(self, idx, tokens, info, hms_idx):
        # TODO: Is this going to admit a lot of false-positives for when we
        # just happen to have digits and "h", "m" or "s" characters in non-date
        # text?  I guess hex hashes won't have that problem, but there's plenty
        # of random junk out there.
        if hms_idx is None:
            hms = None
            new_idx = idx
        elif hms_idx > idx:
            hms = info.hms(tokens[hms_idx])
            new_idx = hms_idx
        else:
            # Looking backwards, increment one.
            hms = info.hms(tokens[hms_idx]) + 1
            new_idx = idx

        return (new_idx, hms)

    def _recombine_skipped(self, tokens, skipped_idxs):
        """
        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
        >>> skipped_idxs = [0, 1, 2, 5]
        >>> _recombine_skipped(tokens, skipped_idxs)
        ["foo bar", "baz"]
        """
        skipped_tokens = []
        for i, idx in enumerate(sorted(skipped_idxs)):
            if i > 0 and idx - 1 == skipped_idxs[i - 1]:
                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
            else:
                skipped_tokens.append(tokens[idx])

        return skipped_tokens

    def _build_tzinfo(self, tzinfos, tzname, tzoffset):
        if callable(tzinfos):
            tzdata = tzinfos(tzname, tzoffset)
        else:
            tzdata = tzinfos.get(tzname)

        if isinstance(tzdata, datetime.tzinfo):
            tzinfo = tzdata
        elif isinstance(tzdata, text_type):
            tzinfo = tz.tzstr(tzdata)
        elif isinstance(tzdata, integer_types):
            tzinfo = tz.tzoffset(tzname, tzdata)
        else:
            raise ValueError("Offset must be tzinfo subclass, "
                             "tz string, or int offset.")
        return tzinfo

    def _build_tzaware(self, naive, res, tzinfos):
        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
            aware = naive.replace(tzinfo=tzinfo)
            aware = self._assign_tzname(aware, res.tzname)

        elif res.tzname and res.tzname in time.tzname:
            aware = naive.replace(tzinfo=tz.tzlocal())

            # Handle ambiguous local datetime
            aware = self._assign_tzname(aware, res.tzname)

            # This is mostly relevant for winter GMT zones parsed in the UK
            if (aware.tzname() != res.tzname and
                    res.tzname in self.info.UTCZONE):
                aware = aware.replace(tzinfo=tz.tzutc())

        elif res.tzoffset == 0:
            aware = naive.replace(tzinfo=tz.tzutc())

        elif res.tzoffset:
            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))

        elif not res.tzname and not res.tzoffset:
            # i.e. no timezone information was found.
            aware = naive

        elif res.tzname:
            # tz-like string was parsed but we don't know what to do
            # with it
            warnings.warn("tzname {tzname} identified but not understood.  "
                          "Pass `tzinfos` argument in order to correctly "
                          "return a timezone-aware datetime.  In a future "
                          "version, this raise an "
                          "exception.".format(tzname=res.tzname),
                          category=UnknownTimezoneWarning)
            aware = naive

        return aware

    def _build_naive(self, res, default):
        repl = {}
        for attr in ("year", "month", "day", "hour",
                     "minute", "second", "microsecond"):
            value = getattr(res, attr)
            if value is not None:
                repl[attr] = value

        if 'day' not in repl:
            # If the default day exceeds the last day of the month, fall back
            # to the end of the month.
            cyear = default.year if res.year is None else res.year
            cmonth = default.month if res.month is None else res.month
            cday = default.day if res.day is None else res.day

            if cday > monthrange(cyear, cmonth)[1]:
                repl['day'] = monthrange(cyear, cmonth)[1]

        naive = default.replace(**repl)

        if res.weekday is not None and not res.day:
            naive = naive + relativedelta.relativedelta(weekday=res.weekday)

        return naive

    def _assign_tzname(self, dt, tzname):
        if dt.tzname() != tzname:
            new_dt = tz.enfold(dt, fold=1)
            if new_dt.tzname() == tzname:
                return new_dt

        return dt

    def _to_decimal(self, val):
        try:
            return Decimal(val)
        except Exception as e:
            msg = "Could not convert %s to decimal" % val
            six.raise_from(ValueError(msg), e)


DEFAULTPARSER = parser()


def parse(timestr, parserinfo=None, **kwargs):
    """

    Parse a string in one of the supported formats, using the
    ``parserinfo`` parameters.

    :param timestr:
        A string containing a date/time stamp.

    :param parserinfo:
        A :class:`parserinfo` object containing parameters for the parser.
        If ``None``, the default arguments to the :class:`parserinfo`
        constructor are used.

    The ``**kwargs`` parameter takes the following keyword arguments:

    :param default:
        The default datetime object, if this is a datetime object and not
        ``None``, elements specified in ``timestr`` replace elements in the
        default object.

    :param ignoretz:
        If set ``True``, time zones in parsed strings are ignored and a naive
        :class:`datetime` object is returned.

    :param tzinfos:
        Additional time zone names / aliases which may be present in the
        string. This argument maps time zone names (and optionally offsets
        from those time zones) to time zones. This parameter can be a
        dictionary with timezone aliases mapping time zone names to time
        zones or a function taking two parameters (``tzname`` and
        ``tzoffset``) and returning a time zone.

        The timezones to which the names are mapped can be an integer
        offset from UTC in seconds or a :class:`tzinfo` object.

        .. doctest::
           :options: +NORMALIZE_WHITESPACE

            >>> from dateutil.parser import parse
            >>> from dateutil.tz import gettz
            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21,
                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

        This parameter is ignored if ``ignoretz`` is set.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
        YMD. If set to ``None``, this value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
        be the year, otherwise the last number is taken to be the year. If
        this is set to ``None``, the value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param fuzzy:
        Whether to allow fuzzy parsing, allowing for string like "Today is
        January 1, 2047 at 8:21:00AM".

    :param fuzzy_with_tokens:
        If ``True``, ``fuzzy`` is automatically set to True, and the parser
        will return a tuple where the first element is the parsed
        :class:`datetime.datetime` datetimestamp and the second element is
        a tuple containing the portions of the string which were ignored:

        .. doctest::

            >>> from dateutil.parser import parse
            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

    :return:
        Returns a :class:`datetime.datetime` object or, if the
        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
        first element being a :class:`datetime.datetime` object, the second
        a tuple containing the fuzzy tokens.

    :raises ValueError:
        Raised for invalid or unknown string format, if the provided
        :class:`tzinfo` is not in a valid format, or if an invalid date
        would be created.

    :raises OverflowError:
        Raised if the parsed date exceeds the largest valid C integer on
        your system.
    """
    if parserinfo:
        return parser(parserinfo).parse(timestr, **kwargs)
    else:
        return DEFAULTPARSER.parse(timestr, **kwargs)


class _tzparser(object):

    class _result(_resultbase):

        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
                     "start", "end"]

        class _attr(_resultbase):
            __slots__ = ["month", "week", "weekday",
                         "yday", "jyday", "day", "time"]

        def __repr__(self):
            return self._repr("")

        def __init__(self):
            _resultbase.__init__(self)
            self.start = self._attr()
            self.end = self._attr()

    def parse(self, tzstr):
        res = self._result()
        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
        used_idxs = list()
        try:

            len_l = len(l)

            i = 0
            while i < len_l:
                # BRST+3[BRDT[+2]]
                j = i
                while j < len_l and not [x for x in l[j]
                                         if x in "0123456789:,-+"]:
                    j += 1
                if j != i:
                    if not res.stdabbr:
                        offattr = "stdoffset"
                        res.stdabbr = "".join(l[i:j])
                    else:
                        offattr = "dstoffset"
                        res.dstabbr = "".join(l[i:j])

                    for ii in range(j):
                        used_idxs.append(ii)
                    i = j
                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in
                                       "0123456789")):
                        if l[i] in ('+', '-'):
                            # Yes, that's right.  See the TZ variable
                            # documentation.
                            signal = (1, -1)[l[i] == '+']
                            used_idxs.append(i)
                            i += 1
                        else:
                            signal = -1
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            setattr(res, offattr, (int(l[i][:2]) * 3600 +
                                                   int(l[i][2:]) * 60) * signal)
                        elif i + 1 < len_l and l[i + 1] == ':':
                            # -03:00
                            setattr(res, offattr,
                                    (int(l[i]) * 3600 +
                                     int(l[i + 2]) * 60) * signal)
                            used_idxs.append(i)
                            i += 2
                        elif len_li <= 2:
                            # -[0]3
                            setattr(res, offattr,
                                    int(l[i][:2]) * 3600 * signal)
                        else:
                            return None
                        used_idxs.append(i)
                        i += 1
                    if res.dstabbr:
                        break
                else:
                    break


            if i < len_l:
                for j in range(i, len_l):
                    if l[j] == ';':
                        l[j] = ','

                assert l[i] == ','

                i += 1

            if i >= len_l:
                pass
            elif (8 <= l.count(',') <= 9 and
                  not [y for x in l[i:] if x != ','
                       for y in x if y not in "0123456789+-"]):
                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
                for x in (res.start, res.end):
                    x.month = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    if l[i] == '-':
                        value = int(l[i + 1]) * -1
                        used_idxs.append(i)
                        i += 1
                    else:
                        value = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    if value:
                        x.week = value
                        x.weekday = (int(l[i]) - 1) % 7
                    else:
                        x.day = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    x.time = int(l[i])
                    used_idxs.append(i)
                    i += 2
                if i < len_l:
                    if l[i] in ('-', '+'):
                        signal = (-1, 1)[l[i] == "+"]
                        used_idxs.append(i)
                        i += 1
                    else:
                        signal = 1
                    used_idxs.append(i)
                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)

                # This was a made-up format that is not in normal use
                warn(('Parsed time zone "%s"' % tzstr) +
                     'is in a non-standard dateutil-specific format, which ' +
                     'is now deprecated; support for parsing this format ' +
                     'will be removed in future versions. It is recommended ' +
                     'that you switch to a standard format like the GNU ' +
                     'TZ variable format.', tz.DeprecatedTzFormatWarning)
            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',
                                                     '.', '-', ':')
                       for y in x if y not in "0123456789"]):
                for x in (res.start, res.end):
                    if l[i] == 'J':
                        # non-leap year day (1 based)
                        used_idxs.append(i)
                        i += 1
                        x.jyday = int(l[i])
                    elif l[i] == 'M':
                        # month[-.]week[-.]weekday
                        used_idxs.append(i)
                        i += 1
                        x.month = int(l[i])
                        used_idxs.append(i)
                        i += 1
                        assert l[i] in ('-', '.')
                        used_idxs.append(i)
                        i += 1
                        x.week = int(l[i])
                        if x.week == 5:
                            x.week = -1
                        used_idxs.append(i)
                        i += 1
                        assert l[i] in ('-', '.')
                        used_idxs.append(i)
                        i += 1
                        x.weekday = (int(l[i]) - 1) % 7
                    else:
                        # year day (zero based)
                        x.yday = int(l[i]) + 1

                    used_idxs.append(i)
                    i += 1

                    if i < len_l and l[i] == '/':
                        used_idxs.append(i)
                        i += 1
                        # start time
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            x.time = (int(l[i][:2]) * 3600 +
                                      int(l[i][2:]) * 60)
                        elif i + 1 < len_l and l[i + 1] == ':':
                            # -03:00
                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60
                            used_idxs.append(i)
                            i += 2
                            if i + 1 < len_l and l[i + 1] == ':':
                                used_idxs.append(i)
                                i += 2
                                x.time += int(l[i])
                        elif len_li <= 2:
                            # -[0]3
                            x.time = (int(l[i][:2]) * 3600)
                        else:
                            return None
                        used_idxs.append(i)
                        i += 1

                    assert i == len_l or l[i] == ','

                    i += 1

                assert i >= len_l

        except (IndexError, ValueError, AssertionError):
            return None

        unused_idxs = set(range(len_l)).difference(used_idxs)
        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
        return res


DEFAULTTZPARSER = _tzparser()


def _parsetz(tzstr):
    return DEFAULTTZPARSER.parse(tzstr)

class UnknownTimezoneWarning(RuntimeWarning):
    """Raised when the parser finds a timezone it cannot parse into a tzinfo"""
# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
"""
This module offers a parser for ISO-8601 strings

It is intended to support all valid date, time and datetime formats per the
ISO-8601 specification.
"""
from datetime import datetime, timedelta, time, date
import calendar
from dateutil import tz

from functools import wraps

import re
import six

__all__ = ["isoparse", "isoparser"]


def _takes_ascii(f):
    @wraps(f)
    def func(self, str_in, *args, **kwargs):
        # If it's a stream, read the whole thing
        str_in = getattr(str_in, 'read', lambda: str_in)()

        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII
        if isinstance(str_in, six.text_type):
            # ASCII is the same in UTF-8
            try:
                str_in = str_in.encode('ascii')
            except UnicodeEncodeError as e:
                msg = 'ISO-8601 strings should contain only ASCII characters'
                six.raise_from(ValueError(msg), e)

        return f(self, str_in, *args, **kwargs)

    return func


class isoparser(object):
    def __init__(self, sep=None):
        """
        :param sep:
            A single character that separates date and time portions. If
            ``None``, the parser will accept any single character.
            For strict ISO-8601 adherence, pass ``'T'``.
        """
        if sep is not None:
            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):
                raise ValueError('Separator must be a single, non-numeric ' +
                                 'ASCII character')

            sep = sep.encode('ascii')

        self._sep = sep

    @_takes_ascii
    def isoparse(self, dt_str):
        """
        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.

        An ISO-8601 datetime string consists of a date portion, followed
        optionally by a time portion - the date and time portions are separated
        by a single character separator, which is ``T`` in the official
        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
        combined with a time portion.

        Supported date formats are:

        Common:

        - ``YYYY``
        - ``YYYY-MM`` or ``YYYYMM``
        - ``YYYY-MM-DD`` or ``YYYYMMDD``

        Uncommon:

        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day

        The ISO week and day numbering follows the same logic as
        :func:`datetime.date.isocalendar`.

        Supported time formats are:

        - ``hh``
        - ``hh:mm`` or ``hhmm``
        - ``hh:mm:ss`` or ``hhmmss``
        - ``hh:mm:ss.sss`` or ``hh:mm:ss.ssssss`` (3-6 sub-second digits)

        Midnight is a special case for `hh`, as the standard supports both
        00:00 and 24:00 as a representation.

        .. caution::

            Support for fractional components other than seconds is part of the
            ISO-8601 standard, but is not currently implemented in this parser.

        Supported time zone offset formats are:

        - `Z` (UTC)
        - `HH:MM`
        - `HHMM`
        - `HH`

        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
        with the exception of UTC, which will be represented as
        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.

        :param dt_str:
            A string or stream containing only an ISO-8601 datetime string

        :return:
            Returns a :class:`datetime.datetime` representing the string.
            Unspecified components default to their lowest value.

        .. warning::

            As of version 2.7.0, the strictness of the parser should not be
            considered a stable part of the contract. Any valid ISO-8601 string
            that parses correctly with the default settings will continue to
            parse correctly in future versions, but invalid strings that
            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
            guaranteed to continue failing in future versions if they encode
            a valid date.
        """
        components, pos = self._parse_isodate(dt_str)

        if len(dt_str) > pos:
            if self._sep is None or dt_str[pos:pos + 1] == self._sep:
                components += self._parse_isotime(dt_str[pos + 1:])
            else:
                raise ValueError('String contains unknown ISO components')

        return datetime(*components)

    @_takes_ascii
    def parse_isodate(self, datestr):
        """
        Parse the date portion of an ISO string.

        :param datestr:
            The string portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.date` object
        """
        components, pos = self._parse_isodate(datestr)
        if pos < len(datestr):
            raise ValueError('String contains unknown ISO ' +
                             'components: {}'.format(datestr))
        return date(*components)

    @_takes_ascii
    def parse_isotime(self, timestr):
        """
        Parse the time portion of an ISO string.

        :param timestr:
            The time portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.time` object
        """
        return time(*self._parse_isotime(timestr))

    @_takes_ascii
    def parse_tzstr(self, tzstr, zero_as_utc=True):
        """
        Parse a valid ISO time zone string.

        See :func:`isoparser.isoparse` for details on supported formats.

        :param tzstr:
            A string representing an ISO time zone offset

        :param zero_as_utc:
            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones

        :return:
            Returns :class:`dateutil.tz.tzoffset` for offsets and
            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
            specified) offsets equivalent to UTC.
        """
        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)

    # Constants
    _MICROSECOND_END_REGEX = re.compile(b'[-+Z]+')
    _DATE_SEP = b'-'
    _TIME_SEP = b':'
    _MICRO_SEP = b'.'

    def _parse_isodate(self, dt_str):
        try:
            return self._parse_isodate_common(dt_str)
        except ValueError:
            return self._parse_isodate_uncommon(dt_str)

    def _parse_isodate_common(self, dt_str):
        len_str = len(dt_str)
        components = [1, 1, 1]

        if len_str < 4:
            raise ValueError('ISO string too short')

        # Year
        components[0] = int(dt_str[0:4])
        pos = 4
        if pos >= len_str:
            return components, pos

        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP
        if has_sep:
            pos += 1

        # Month
        if len_str - pos < 2:
            raise ValueError('Invalid common month')

        components[1] = int(dt_str[pos:pos + 2])
        pos += 2

        if pos >= len_str:
            if has_sep:
                return components, pos
            else:
                raise ValueError('Invalid ISO format')

        if has_sep:
            if dt_str[pos:pos + 1] != self._DATE_SEP:
                raise ValueError('Invalid separator in ISO string')
            pos += 1

        # Day
        if len_str - pos < 2:
            raise ValueError('Invalid common day')
        components[2] = int(dt_str[pos:pos + 2])
        return components, pos + 2

    def _parse_isodate_uncommon(self, dt_str):
        if len(dt_str) < 4:
            raise ValueError('ISO string too short')

        # All ISO formats start with the year
        year = int(dt_str[0:4])

        has_sep = dt_str[4:5] == self._DATE_SEP

        pos = 4 + has_sep       # Skip '-' if it's there
        if dt_str[pos:pos + 1] == b'W':
            # YYYY-?Www-?D?
            pos += 1
            weekno = int(dt_str[pos:pos + 2])
            pos += 2

            dayno = 1
            if len(dt_str) > pos:
                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:
                    raise ValueError('Inconsistent use of dash separator')

                pos += has_sep

                dayno = int(dt_str[pos:pos + 1])
                pos += 1

            base_date = self._calculate_weekdate(year, weekno, dayno)
        else:
            # YYYYDDD or YYYY-DDD
            if len(dt_str) - pos < 3:
                raise ValueError('Invalid ordinal day')

            ordinal_day = int(dt_str[pos:pos + 3])
            pos += 3

            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):
                raise ValueError('Invalid ordinal day' +
                                 ' {} for year {}'.format(ordinal_day, year))

            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)

        components = [base_date.year, base_date.month, base_date.day]
        return components, pos

    def _calculate_weekdate(self, year, week, day):
        """
        Calculate the day of corresponding to the ISO year-week-day calendar.

        This function is effectively the inverse of
        :func:`datetime.date.isocalendar`.

        :param year:
            The year in the ISO calendar

        :param week:
            The week in the ISO calendar - range is [1, 53]

        :param day:
            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]

        :return:
            Returns a :class:`datetime.date`
        """
        if not 0 < week < 54:
            raise ValueError('Invalid week: {}'.format(week))

        if not 0 < day < 8:     # Range is 1-7
            raise ValueError('Invalid weekday: {}'.format(day))

        # Get week 1 for the specific year:
        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it
        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)

        # Now add the specific number of weeks and days to get what we want
        week_offset = (week - 1) * 7 + (day - 1)
        return week_1 + timedelta(days=week_offset)

    def _parse_isotime(self, timestr):
        len_str = len(timestr)
        components = [0, 0, 0, 0, None]
        pos = 0
        comp = -1

        if len(timestr) < 2:
            raise ValueError('ISO time too short')

        has_sep = len_str >= 3 and timestr[2:3] == self._TIME_SEP

        while pos < len_str and comp < 5:
            comp += 1

            if timestr[pos:pos + 1] in b'-+Z':
                # Detect time zone boundary
                components[-1] = self._parse_tzstr(timestr[pos:])
                pos = len_str
                break

            if comp < 3:
                # Hour, minute, second
                components[comp] = int(timestr[pos:pos + 2])
                pos += 2
                if (has_sep and pos < len_str and
                        timestr[pos:pos + 1] == self._TIME_SEP):
                    pos += 1

            if comp == 3:
                # Microsecond
                if timestr[pos:pos + 1] != self._MICRO_SEP:
                    continue

                pos += 1
                us_str = self._MICROSECOND_END_REGEX.split(timestr[pos:pos + 6],
                                                           1)[0]

                components[comp] = int(us_str) * 10**(6 - len(us_str))
                pos += len(us_str)

        if pos < len_str:
            raise ValueError('Unused components in ISO string')

        if components[0] == 24:
            # Standard supports 00:00 and 24:00 as representations of midnight
            if any(component != 0 for component in components[1:4]):
                raise ValueError('Hour may only be 24 at 24:00:00.000')
            components[0] = 0

        return components

    def _parse_tzstr(self, tzstr, zero_as_utc=True):
        if tzstr == b'Z':
            return tz.tzutc()

        if len(tzstr) not in {3, 5, 6}:
            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')

        if tzstr[0:1] == b'-':
            mult = -1
        elif tzstr[0:1] == b'+':
            mult = 1
        else:
            raise ValueError('Time zone offset requires sign')

        hours = int(tzstr[1:3])
        if len(tzstr) == 3:
            minutes = 0
        else:
            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])

        if zero_as_utc and hours == 0 and minutes == 0:
            return tz.tzutc()
        else:
            if minutes > 59:
                raise ValueError('Invalid minutes in time zone offset')

            if hours > 23:
                raise ValueError('Invalid hours in time zone offset')

            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)


DEFAULT_ISOPARSER = isoparser()
isoparse = DEFAULT_ISOPARSER.isoparse
# -*- coding: utf-8 -*-
from ._parser import parse, parser, parserinfo
from ._parser import DEFAULTPARSER, DEFAULTTZPARSER
from ._parser import UnknownTimezoneWarning

from ._parser import __doc__

from .isoparser import isoparser, isoparse

__all__ = ['parse', 'parser', 'parserinfo',
           'isoparse', 'isoparser',
           'UnknownTimezoneWarning']


###
# Deprecate portions of the private interface so that downstream code that
# is improperly relying on it is given *some* notice.


def __deprecated_private_func(f):
    from functools import wraps
    import warnings

    msg = ('{name} is a private function and may break without warning, '
           'it will be moved and or renamed in future versions.')
    msg = msg.format(name=f.__name__)

    @wraps(f)
    def deprecated_func(*args, **kwargs):
        warnings.warn(msg, DeprecationWarning)
        return f(*args, **kwargs)

    return deprecated_func

def __deprecate_private_class(c):
    import warnings

    msg = ('{name} is a private class and may break without warning, '
           'it will be moved and or renamed in future versions.')
    msg = msg.format(name=c.__name__)

    class private_class(c):
        __doc__ = c.__doc__

        def __init__(self, *args, **kwargs):
            warnings.warn(msg, DeprecationWarning)
            super(private_class, self).__init__(*args, **kwargs)

    private_class.__name__ = c.__name__

    return private_class


from ._parser import _timelex, _resultbase
from ._parser import _tzparser, _parsetz

_timelex = __deprecate_private_class(_timelex)
_tzparser = __deprecate_private_class(_tzparser)
_resultbase = __deprecate_private_class(_resultbase)
_parsetz = __deprecated_private_func(_parsetz)
