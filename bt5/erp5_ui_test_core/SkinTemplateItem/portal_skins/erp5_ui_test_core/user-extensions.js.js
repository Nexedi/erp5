/**
 * Selenium extensions for the ERP5 project
 */


/**
 * Checks the element referenced by `locator` is a float equals to `text`.
 * Values are converted to float, to be format-independant (ie. 1 000 = 1000.0)
 */
Selenium.prototype.assertFloat = function(locator, text) {
    var actualValueText = getText(this.page().findElement(locator));
    var actualValue = parseFloat(actualValueText.replace(/ /g, "").replace(/&nbsp;/g, ""));
    var expectedValue = parseFloat(text.replace(/ /g, "").replace(/&nbsp;/g, ""));

    if (isNaN(actualValue)) {
        Assert.fail("Actual value "+ actualValueText +
                        " cannot be parsed as float");
    }
    Assert.matches(expectedValue.toString(), actualValue.toString());
};


/**
 * like assertFloat, but for the value of <input elements.
 */
Selenium.prototype.assertFloatValue = function(locator, text) {
    var actualValueText = getInputValue(this.page().findElement(locator));
    var actualValue = parseFloat(actualValueText.replace(/ /g, "").replace(/&nbsp;/g, ""));
    var expectedValue = parseFloat(text.replace(/ /g, "").replace(/&nbsp;/g, ""));

    if (isNaN(actualValue)) {
        Assert.fail("Actual value "+ actualValueText +
                        " cannot be parsed as float");
    }
    Assert.matches(expectedValue.toString(), actualValue.toString());
};


/**
 * Checks the portal status message.
 */
Selenium.prototype.assertPortalStatusMessage = function(text) {
    var psm_locator = "//div[@id='transition_message']";
    var actualValue = getText(this.page().findElement(psm_locator));
    Assert.matches(text, actualValue);
};

Selenium.prototype.doType = function(locator, newText) {
    if (typeof(netscape) != "undefined" && typeof(netscape.security.PrivilegeManager) != "undefined" ) {
      // On old firefox versions, we enable privilege to upload file in javascript.
      // The user needs to have signed.applets.codebase_principal_support set to true in about:config
      // This is done in prefs.js generated by product/ERP5Type/tests/runFunctionalTest.py
      // This approach no longer work in newer firefox versions https://developer.mozilla.org/en-US/docs/Bypassing_Security_Restrictions_and_Signing_Code
      // Without this, tests dealing with file upload will fail
      netscape.security.PrivilegeManager.enablePrivilege("UniversalFileRead");
    }
    var element = this.page().findElement(locator);
    this.page().replaceText(element, newText);
};

/*
 * Get the location of the current page. This function is missing in
 * Selenium 0.8 or later.
 */
Selenium.prototype.getAbsoluteLocation = function() {
    return this.page().location || this.browserbot.getCurrentWindow().location;
};

Selenium.prototype.doPhantomRender = function(filename) {
    if (window.page && window.page.render) {
        page.render(filename);
    }
};

Selenium.prototype.assertElementPositionRangeTop = function(locator, range){
    var positionTop = parseFloat(this.getElementPositionTop(locator));
    /* example of range 450..455 */
    var rangeList = range.split("..");
    var minimumPositionTop = parseFloat(rangeList[0]);
    var maximumPositionTop = parseFloat(rangeList[1]);
    if (positionTop < minimumPositionTop || positionTop > maximumPositionTop ){
      Assert.fail(positionTop + " is not between " + minimumPositionTop + " and " + maximumPositionTop);
    }
};

// a memo test pathname => image counter
imageMatchReference = new Map();

function getReferenceImageCounter(testPathName) {
  var counter = imageMatchReference.get(testPathName);
  if (counter !== undefined) {
    return counter;
  }
  counter = imageMatchReference.size + 1;
  imageMatchReference.set(testPathName, counter);
  return counter;
}

function getReferenceImageURL(testPathName) {
  var imageCounter = getReferenceImageCounter(testPathName);
  return testPathName + '-reference-snapshot-' + imageCounter + '.png';
}

/**
 * assert that the rendering of the element `locator` matches the previously saved reference.
 *
 * Arguments:
 *   locator - an element locator
 *   misMatchTolerance - the percentage of mismatch allowed. If this is 0, the
 *      images must be exactly same. If more than 0, image will also be resized.
 */
Selenium.prototype.doAssertImageMatchSnapshot = (
  locator,
  misMatchTolerance
) => {
  // XXX this is a do* method and not a assert* method because only do* methods are
  // asynchronous.
  // The asynchronicity of do* method is as follow Selenium.prototype.doXXX
  // returns a function and this function will be called again and again until:
  //   * function returns true, which means step is successfull
  //   * function returns false, which means step is not finished
  //   * an execption is raised, in that case the step is failed
  //   * global timeout is reached.
  // we implement the state management with similar approach as what's discussed
  // https://stackoverflow.com/questions/30564053/how-can-i-synchronously-determine-a-javascript-promises-state
  var promiseState, rejectionValue, canvasPromise;
  return function assertCanvasImage() {
    if (promiseState === 'pending') {
      return false;
    }
    if (promiseState === 'resolved') {
      return true;
    }
    if (promiseState === 'rejected') {
      Assert.fail(rejectionValue);
    }

    if (misMatchTolerance === undefined) {
      misMatchTolerance = 0;
    }

    promiseState = 'pending';
    element = selenium.browserbot.findElement(locator);
    if (element.nodeName == 'CANVAS' /* instanceof HTMLCanvasElement XXX ? */) {
      canvasPromise = Promise.resolve(element);
    } else {
      canvasPromise = html2canvas(element);
    }

    canvasPromise
      .then(canvas => {
        return canvas.toDataURL();
      })
      .then(actual => {
        var referenceImageURL = getReferenceImageURL(
          testFrame.getCurrentTestCase().pathname
        );
        return fetch(referenceImageURL)
          .then(response => {
            if (response.status === 200) {
              return response.blob();
            }
            throw new Error('Feching reference failed ' + response.statusText);
          })
          .then(
            blob => {
              return new Promise((resolve, reject) => {
                var fr = new FileReader();
                fr.onload = d => resolve(fr.result);
                fr.onerror = reject;
                fr.readAsDataURL(blob);
              });
            },
            e => {
              // fetching reference was not found, return empty image instead, it will be different
              return document.createElement('canvas').toDataURL();
            }
          )
          .then(expected => {
            var diff = resemble(actual)
              .outputSettings({ useCrossOrigin: false })
              .compareTo(expected);
            return new Promise(resolve => diff.onComplete(resolve));
          })
          .then(diff => {
            var updateLink = new URL(
              'Zuite_viewUpdateReferenceImageDialog',
              document.baseURI
            );
            updateLink.searchParams.set('image_data', actual);
            // XXX this cause Request-URI Too Long
            // make a data-url: html form ?
            //updateLink.searchParams.set('image_path', referenceImageURL);
            updateLink.searchParams.set('image_path', 'XXX too big');

            if (parseFloat(diff.misMatchPercentage) <=  misMatchTolerance) {
              promiseState = 'resolved';
            } else {
              promiseState = 'rejected';
              rejectionValue = [
                '## Images are ' + diff.misMatchPercentage + '% different ',
                '',
                'Difference: ![image difference](' +
                  diff.getImageDataUrl() +
                  ')',
                '',
                'Expected image: ![expected](' + referenceImageURL + ')',
                '',
                'Actual image: ![actual](' + actual + ')',
                '',
                'Click [here](' +
                  updateLink.toString() +
                  ') to update reference with actual.'
              ].join('\n');
            }
          });
      })
      .catch(error => {
        console.error(error);
        promiseState = 'rejected';
        rejectionValue = 'Error computing image differences ' + error;
      });
  };
};
