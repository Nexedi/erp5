/**
 * Selenium extensions for the ERP5 project
 */


/**
 * Checks the element referenced by `locator` is a float equals to `text`.
 * Values are converted to float, to be format-independant (ie. 1 000 = 1000.0)
 */
Selenium.prototype.assertFloat = function(locator, text) {
    var actualValueText = getText(this.page().findElement(locator));
    var actualValue = parseFloat(actualValueText.replace(/ /g, "").replace(/&nbsp;/g, ""));
    var expectedValue = parseFloat(text.replace(/ /g, "").replace(/&nbsp;/g, ""));

    if (isNaN(actualValue)) {
        Assert.fail("Actual value "+ actualValueText +
                        " cannot be parsed as float");
    }
    Assert.matches(expectedValue.toString(), actualValue.toString());
};


/**
 * like assertFloat, but for the value of <input elements.
 */
Selenium.prototype.assertFloatValue = function(locator, text) {
    var actualValueText = getInputValue(this.page().findElement(locator));
    var actualValue = parseFloat(actualValueText.replace(/ /g, "").replace(/&nbsp;/g, ""));
    var expectedValue = parseFloat(text.replace(/ /g, "").replace(/&nbsp;/g, ""));

    if (isNaN(actualValue)) {
        Assert.fail("Actual value "+ actualValueText +
                        " cannot be parsed as float");
    }
    Assert.matches(expectedValue.toString(), actualValue.toString());
};


/**
 * Checks the portal status message.
 */
Selenium.prototype.assertPortalStatusMessage = function(text) {
    var psm_locator = "//div[@id='transition_message']";
    var actualValue = getText(this.page().findElement(psm_locator));
    Assert.matches(text, actualValue);
};

Selenium.prototype.doType = function(locator, newText) {
    if (typeof(netscape) != "undefined" && typeof(netscape.security.PrivilegeManager) != "undefined" ) {
      // On old firefox versions, we enable privilege to upload file in javascript.
      // The user needs to have signed.applets.codebase_principal_support set to true in about:config
      // This is done in prefs.js generated by product/ERP5Type/tests/runFunctionalTest.py
      // This approach no longer work in newer firefox versions https://developer.mozilla.org/en-US/docs/Bypassing_Security_Restrictions_and_Signing_Code
      // Without this, tests dealing with file upload will fail
      netscape.security.PrivilegeManager.enablePrivilege("UniversalFileRead");
    }
    var element = this.page().findElement(locator);
    this.page().replaceText(element, newText);
};

/*
 * Get the location of the current page. This function is missing in
 * Selenium 0.8 or later.
 */
Selenium.prototype.getAbsoluteLocation = function() {
    return this.page().location || this.browserbot.getCurrentWindow().location;
};

Selenium.prototype.doPhantomRender = function(filename) {
    if (window.page && window.page.render) {
        page.render(filename);
    }
};

Selenium.prototype.assertElementPositionRangeTop = function(locator, range){
    var positionTop = parseFloat(this.getElementPositionTop(locator));
    /* example of range 450..455 */
    var rangeList = range.split("..");
    var minimumPositionTop = parseFloat(rangeList[0]);
    var maximumPositionTop = parseFloat(rangeList[1]);
    if (positionTop < minimumPositionTop || positionTop > maximumPositionTop ){
      Assert.fail(positionTop + " is not between " + minimumPositionTop + " and " + maximumPositionTop);
    }
};


/**
 * assert that canvas located at `locator` matches the `referenceImageURL`
 *
 * Images are compared pixel by pixel and if they differed, this step
 * is considered failed.
 *
 * Arguments:
 *   locator - an element locator
 *   referenceImageURL - URL of the reference image, can be relative.
 */
Selenium.prototype.doAssertCanvasImage = function(locator, referenceImageURL) {
  // XXX this is a do* method and not a assert* method because only do* methods are
  // asynchronous.
  // The asynchronicity of do* method is as follow Selenium.prototype.doXXX
  // returns a function and this function will be called again and again until:
  //   * function returns true, which means step is successfull
  //   * function returns false, which means step is not finished
  //   * an execption is raised, in that case the step is failed
  //   * global timeout is reached.
  // we implement the state management with similar approach as what's discussed
  // https://stackoverflow.com/questions/30564053/how-can-i-synchronously-determine-a-javascript-promises-state
  var promiseState, rejectionValue;
  return function assertCanvasImage() {
    if (promiseState === "pending") {
      return false;
    }
    if (promiseState === "resolved") {
      return true;
    }
    if (promiseState === "rejected") {
        Assert.fail(rejectionValue);
    }

    promiseState = "pending";
    var actual = selenium.browserbot.findElement(locator).toDataURL();
    fetch(referenceImageURL)
      .then(r => r.blob())
      .then(blob => {
        return new Promise((resolve, reject) => {
          var fr = new FileReader();
          fr.onload = d => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsDataURL(blob);
        });
      })
      .then(expected => {
        var diff = resemble(actual)
          .outputSettings({ useCrossOrigin: false })
          .compareTo(expected);
        return new Promise(resolve => diff.onComplete(resolve));
      })
      .then(diff => {
        var img;
        if (diff.misMatchPercentage == 0) {
          promiseState = "resolved";
        } else {
          promiseState = "rejected";
          rejectionValue =
            "Images are different ![image difference](" +
            diff.getImageDataUrl() +
            ")";
        }
      })
      .catch(error => {
        console.error(error);
        promiseState = "rejected";
        rejectionValue = "Error computing image differences " + error;
      });
  };
};
