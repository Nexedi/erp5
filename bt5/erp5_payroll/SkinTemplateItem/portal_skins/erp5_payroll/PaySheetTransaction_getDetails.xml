<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <tuple>
        <tuple>
          <string>Products.PythonScripts.PythonScript</string>
          <string>PythonScript</string>
        </tuple>
        <none/>
      </tuple>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>Python_magic</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>Script_magic</string> </key>
            <value> <int>3</int> </value>
        </item>
        <item>
            <key> <string>__ac_local_roles__</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>_bind_names</string> </key>
            <value>
              <object>
                <klass>
                  <global name="NameAssignments" module="Shared.DC.Scripts.Bindings"/>
                </klass>
                <tuple/>
                <state>
                  <dictionary>
                    <item>
                        <key> <string>_asgns</string> </key>
                        <value>
                          <dictionary>
                            <item>
                                <key> <string>name_container</string> </key>
                                <value> <string>container</string> </value>
                            </item>
                            <item>
                                <key> <string>name_context</string> </key>
                                <value> <string>context</string> </value>
                            </item>
                            <item>
                                <key> <string>name_m_self</string> </key>
                                <value> <string>script</string> </value>
                            </item>
                            <item>
                                <key> <string>name_subpath</string> </key>
                                <value> <string>traverse_subpath</string> </value>
                            </item>
                          </dictionary>
                        </value>
                    </item>
                  </dictionary>
                </state>
              </object>
            </value>
        </item>
        <item>
            <key> <string>_body</string> </key>
            <value> <string encoding="cdata"><![CDATA[

"""\n
  This script get current Pay Sheet Lines and reorganize them for PDF print.\n
  TODO: What is missing in this script is the support of line ordering. The data structure (= the \'details\' dict) was design to support such a feature (thanks to a combination of dicts and lists), so normally little code is needed to make this feature working.\n
"""\n
\n
# Some globals\n
portal = context.getPortalObject()\n
\n
\n
# Initialize total share\n
gross_salary         = 0.0\n
net_salary           = 0.0\n
taxable_net_salary   = 0.0\n
total_employer_share = 0.0\n
total_employee_share = 0.0   # Alternative: total_employee_share = r_(gross_salary - net_salary)\n
total_addendum       = 0.0\n
\n
\n
##############################################################################\n
# General purpose method to manipulate the \'details\' data structure.\n
##############################################################################\n
\n
# This dict contain all paysheet details for printing\n
details = { \'groups\': []  # Current month pay sheet line details\n
          , \'totals\': {}  # Current month and yearly totals\n
          }\n
\n
\n
def getPSLGroupIdList():\n
  """\n
    This method get the list of group IDs registered in the details dict.\n
  """\n
  id_list = []\n
  for group in details[\'groups\']:\n
    gid = group[\'id\']\n
    if gid != None:\n
      id_list.append(gid)\n
  return id_list\n
\n
\n
def groupExist(group_id):\n
  return (group_id not in [\'\', None] and group_id in getPSLGroupIdList()) and True or False\n
\n
\n
def getGroup(group_id):\n
  for group in details[\'groups\']:\n
    if group[\'id\'] == group_id:\n
      return group\n
  return None\n
\n
\n
def getGroupSublineIdList(group_id=None):\n
  """\n
    This method get the list of subline IDs for a given group.\n
  """\n
  id_list = []\n
  group = getGroup(group_id)\n
  if group != None:\n
    sublines = group[\'sublines\']\n
    if sublines != None and len(sublines) > 0:\n
      for subline in sublines:\n
        id_list.append(subline[\'id\'])\n
  return id_list\n
\n
\n
def sublineExist(group_id, subline_id):\n
  return (groupExist(group_id) and subline_id not in [\'\', None] and subline_id in getGroupSublineIdList(group_id)) and True or False\n
\n
\n
def getSubline(group_id, subline_id):\n
  """\n
    This method get subline content based on its ID\n
  """\n
  group = getGroup(group_id)\n
  if group != None:\n
    for subline in group[\'sublines\']:\n
      if subline[\'id\'] == subline_id:\n
        return subline\n
  return None\n
\n
\n
def updateSubLine(group_id, subline_id, property, value):\n
  """\n
    This method update a subline property.\n
  """\n
  subline = getSubline(group_id, subline_id)\n
  if subline != None:\n
    subline[property] = value\n
    return\n
  context.log("PaySheetTransaction_getDetails() error: ", "Can\'t update subline %s from %s group with %s=%s" % (subline_id, group_id, property, value))\n
\n
\n
\n
##############################################################################\n
# Build an empty \'details\' dict.\n
##############################################################################\n
\n
# Scan each pay sheet line\n
for psl in context.objectValues(portal_type=\'Pay Sheet Line\'):\n
\n
  service           = context.restrictedTraverse(psl.getResource())\n
  salary_range_list = psl.getSalaryRangeList()\n
  tax_category_list = psl.getTaxCategoryList()\n
\n
\n
  # Create a new pay sheet line group for each new tax_category\n
  for tax_category in tax_category_list:\n
    group_id = tax_category.split(\'/\')[0]\n
    if not groupExist(group_id):\n
      group = portal.portal_categories.resolveCategory(\'tax_category/%s\' % group_id)\n
      # New pay sheet line group data structure\n
      new_group = { \'title\'   : group.getTitle()\n
                  , \'id\'      : group_id\n
                  , \'sublines\': []\n
                  }\n
      details[\'groups\'] = details[\'groups\'] + [new_group]\n
\n
\n
    # Create a new line for each salary range to contain cells\n
    for salary_range_path in salary_range_list:\n
      salary_range = portal.portal_categories.resolveCategory(\'salary_range/%s\' % salary_range_path)\n
      # Compose a unique ID for the combination of service and salary_range\n
      subline_id = "%s/%s" % (service.getId(), salary_range.getId())\n
\n
      # Here we decide if a Pay Sheet Line is taxable or not, according its payroll service\n
      # TODO: This is a hack, because the code below contain hard-coded IDs. To make this a\n
      #       little bit more generic, an idea could be to use a \'taxable\' category to test\n
      #       this in a more generic way.\n
      service_id = service.getId()\n
      taxable = False\n
      if service_id.endswith(\'non_deductible\') or \\\n
         service_id.endswith(\'crds\')           or \\\n
         service_id.endswith(\'taxable\'):\n
        taxable = True\n
      elif service_id.endswith(\'deductible\'):\n
        taxable = False\n
\n
      # Check that the subline doesn\'t exist in this group\n
      if not sublineExist(group_id, subline_id):\n
        new_subline = { \'id\'                : subline_id\n
                      , \'service_title\'     : service.getTitle()\n
                      , \'salary_range_title\': salary_range.getTitle()\n
                      , \'base\'              : None # Base Value                  (Assiette)\n
                      , \'employer_rate\'     : None # Employer Share Rate, if any (Taux part patronale)\n
                      , \'employer_share\'    : None # Employer Share              (Part patronale)\n
                      , \'employee_rate\'     : None # Employee Share Rate, if any (Taux part salariale)\n
                      , \'employee_share\'    : None # Employee Share              (Part salariale)\n
                      , \'taxable\'           : taxable\n
                      , \'description\'       : None\n
                      }\n
        # Update group\'s sublines\n
        groups = details[\'groups\']\n
        old_group = groups.pop(groups.index(getGroup(group_id)))\n
        old_group[\'sublines\'] = old_group[\'sublines\'] + [new_subline]\n
        details[\'groups\'] = groups + [old_group]\n
\n
\n
\n
##############################################################################\n
# Fill the \'details\' dict with cells and calculated datas.\n
# There is some specific code here that must be transformed to generic one.\n
##############################################################################\n
\n
# Get Precision and precise rounding methods\n
currency_precision = context.getResourceValue().getQuantityPrecision()\n
r_ = lambda x: context.Base_getRoundValue(x, currency_precision)\n
\n
# Scan each pay sheet line and save it in the right place in the data structure\n
for psl in context.objectValues(portal_type=\'Pay Sheet Line\'):\n
  line_description = psl.getDescription()\n
  line_title       = psl.getTitle()\n
  # Add each cell to the data structure\n
  for cell in psl.objectValues(portal_type=\'Pay Sheet Cell\'):\n
    # There is no getSalaryRangeList() accessor on cells, so sort categories manually\n
    salary_range_path = None\n
    tax_category_path = None\n
    for c in cell.getCategoryList():\n
      if c.startswith(\'tax_category\'): tax_category_path = c\n
      if c.startswith(\'salary_range\'): salary_range_path = c\n
\n
    # Get the cell tax category as group\n
    cell_group_id = tax_category_path.split(\'/\')[1]\n
\n
    # Get the cell subline_id\n
    service         = context.restrictedTraverse(psl.getResource())\n
    salary_range    = portal.portal_categories.resolveCategory(salary_range_path)\n
    cell_subline_id = "%s/%s" % (service.getId(), salary_range.getId())\n
\n
    # Get money-related datas\n
    # The code below is broken if category naming conventions are not respected\n
    range_type = \'/\'.join(salary_range_path.split(\'/\')[2:])   # \'fixed\', \'fixed/gross\', \'variable\'...\n
    share_type = tax_category_path.split(\'/\')[-1]             # \'employee_share\' or \'employer_share\'\n
    share_type = share_type.split(\'_\')[0]                     # \'employee\' or \'employer\'\n
\n
    # Update title\n
    if line_title not in [\'\', None]:\n
      updateSubLine( group_id   = cell_group_id\n
                   , subline_id = cell_subline_id\n
                   , property   = \'service_title\'\n
                   , value      = line_title\n
                   )\n
\n
    # Update description\n
    if line_description != None:\n
      # Transform description as one line string\n
      line_description = line_description.replace(\'\\n\', \' \').strip().capitalize()\n
      if len(line_description) > 0:\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'description\'\n
                     , value      = \'(%s)\' % line_description\n
                     )\n
\n
    ### Gross salary group handling\n
    if range_type.startswith("fixed/gross"):\n
      # Ignore the base and rates, ignore employee share, move employer share to employee share\n
      cell_value = r_(cell.getPrice())\n
      if share_type == \'employer\':\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'employee_share\'\n
                     , value      = cell_value\n
                     )\n
        gross_salary = r_(gross_salary + cell_value)\n
        # Do not display base type for non-base salary\n
        if not range_type.startswith("fixed/gross/base"):\n
          updateSubLine( group_id   = cell_group_id\n
                       , subline_id = cell_subline_id\n
                       , property   = \'salary_range_title\'\n
                       , value      = None\n
                       )\n
\n
      ### Net Salary handling\n
      elif share_type == \'employee\':\n
        net_salary = cell_value\n
\n
    ### Addendum group handling\n
    elif range_type.startswith("fixed/addendum"):\n
      # Ignore the base, rates and employer share\n
      cell_value = r_(cell.getPrice())\n
      if share_type == \'employee\':\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'employee_share\'\n
                     , value      = cell_value\n
                     )\n
        # Update total addendum\n
        total_addendum = r_(total_addendum + cell_value)\n
\n
    ### Default/Standard line group handling\n
    else:\n
      cell_rate = cell.getPrice()\n
      cell_base = - cell.getQuantity() # Change sign for beauty\n
      # BUG: why cell.getTotalPrice() use the method from Amount instead of the one defined in Movement class ?\n
      cell_share = r_(cell_base * cell_rate)\n
\n
      ### Fixed Pay Sheet Lines (= \'forfait\')\n
      if range_type.startswith("fixed"):\n
        # Ignore the base and rates\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'%s_share\' % share_type\n
                     , value      = cell_share\n
                     )\n
\n
      ### Other Pay Sheet Lines (= variable)\n
      else:\n
        # Get the rate and the base, calculate the share\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'%s_rate\' % share_type\n
                     , value      = r_(cell_rate * 100.0)\n
                     )\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'base\'\n
                     , value      = r_(cell_base)\n
                     )\n
        updateSubLine( group_id   = cell_group_id\n
                     , subline_id = cell_subline_id\n
                     , property   = \'%s_share\' % share_type\n
                     , value      = cell_share\n
                     )\n
      # Sum up employee and employer share grand total\n
      if share_type == \'employee\':\n
        total_employee_share = r_(total_employee_share + cell_share)\n
      elif share_type == \'employer\':\n
        total_employer_share = r_(total_employer_share + cell_share)\n
\n
      # Create taxable salary\n
      subline = getSubline(group_id=cell_group_id, subline_id=cell_subline_id)\n
      if subline != None and subline.has_key(\'taxable\') and subline[\'taxable\'] == True and subline[\'employee_share\'] != None:\n
        taxable_net_salary = r_(taxable_net_salary + subline[\'employee_share\'])\n
\n
\n
\n
##########################################\n
# Calculate current paysheet grand totals\n
##########################################\n
\n
details[\'totals\'][\'gross_salary\']           = gross_salary\n
details[\'totals\'][\'net_salary\']             = net_salary\n
details[\'totals\'][\'taxable_net_salary\']     = r_(net_salary + taxable_net_salary)\n
details[\'totals\'][\'total_employer_share\']   = total_employer_share\n
details[\'totals\'][\'total_employee_share\']   = total_employee_share\n
details[\'totals\'][\'total_addendum\']         = total_addendum\n
details[\'totals\'][\'total_employee_payment\'] = r_(net_salary + total_addendum)\n
\n
\n
\n
##########################################\n
# Calculate yearly sums if needed\n
##########################################\n
\n
if not ignore_yearly_sums:\n
\n
  # Calculate the year period\n
  from DateTime import DateTime\n
  start_year = context.getStartDate().year()\n
  year_start_date = DateTime(start_year, 1, 1)\n
  year_stop_date  = context.getStopDate()\n
\n
\n
  # Initialize the yearly sums data structure with current paysheet totals\n
  yearly_sums = { \'start_date\': year_start_date\n
                , \'stop_date\' : context.getStopDate()\n
                }\n
  yearly_sums_base_id = details[\'totals\'].keys()\n
  for base_id in yearly_sums_base_id:\n
    yearly_sums[base_id] = details[\'totals\'][base_id]\n
\n
\n
  # Get all paysheet transaction to calculate the sum of different value in a year\n
  search_params = \\\n
    { \'portal_type\'            : \'Pay Sheet Transaction\'\n
    , \'simulation_state\'       : [\'planned\', \'confirmed\', \'stopped\', \'delivered\']\n
    , \'delivery.start_date\'    : {\'range\': "minngt", \'query\': (year_start_date, year_stop_date)}\n
    , \'destination_section_uid\': context.getDestinationSectionUid()  # Employee\'s UID\n
    }\n
  accounting_folder = context.getParentValue()\n
  paysheet_transactions = accounting_folder.searchFolder(**search_params)\n
\n
\n
  # Browse through paysheet transaction\n
  current_paysheet_uid = context.getUid()\n
  for paysheet in paysheet_transactions:\n
    # Ignore the current paysheet to avoid infinite loop\n
    if paysheet.getUid() != current_paysheet_uid:\n
      # Get all detailed values of the paysheet\n
      paysheet_details = paysheet.PaySheetTransaction_getDetails(ignore_yearly_sums = True)\n
      for base_id in yearly_sums_base_id:\n
        if paysheet_details[\'totals\'].has_key(base_id):\n
          yearly_sums[base_id] = r_(yearly_sums[base_id] + r_(float(paysheet_details[\'totals\'][base_id])))\n
\n
\n
  # Save the yearly sums in the current details dict\n
  details[\'totals\'][\'yearly\'] = yearly_sums\n
\n
\n
\n
##############################################################################\n
# Transform every float value to a string representation according the currency.\n
##############################################################################\n
\n
# The "three decimals" format is arbitrary. "3" was choose because there is no rate with\n
# currency_precision above 3. Feel free to update dynamiccaly this format if required.\n
RATE_PRECISION = 3\n
\n
# There is 2 kind of numbers to format: rates and amounts.\n
money_format = {\'precision\': currency_precision}  #IDEA: put currency symbol as suffix ?\n
rate_format  = {\'precision\': RATE_PRECISION, \'suffix\': "%"}\n
property_format_dict = { \'base\'          : money_format\n
                       , \'employer_rate\' : rate_format\n
                       , \'employer_share\': money_format\n
                       , \'employee_rate\' : rate_format\n
                       , \'employee_share\': money_format\n
                       }\n
\n
# Format each "normal" lines\n
for group_id in getPSLGroupIdList():\n
  for subline_id in getGroupSublineIdList(group_id=group_id):\n
    subline = getSubline(group_id=group_id, subline_id=subline_id)\n
    for (property, value) in subline.items():\n
      if property_format_dict.has_key(property) and same_type(value, 1.0) or same_type(value, 1):\n
        format = property_format_dict[property]\n
        precision = format[\'precision\']\n
        new_value = (\'%.\' + str(precision) + \'f\') % value\n
        if format.has_key(\'prefix\'): new_value = \'%s %s\' % (format[\'prefix\'], new_value)\n
        if format.has_key(\'suffix\'): new_value = \'%s %s\' % (new_value, format[\'suffix\'])\n
        updateSubLine( group_id   = group_id\n
                     , subline_id = subline_id\n
                     , property   = property\n
                     , value      = new_value\n
                     )\n
\n
# Format totals and yearly sums\n
for (key, value) in details[\'totals\'].items():\n
  if same_type(value, 1.0) or same_type(value, 1):\n
    details[\'totals\'][key] = (\'%.\' + str(currency_precision) + \'f\') % value\n
  elif key == \'yearly\':\n
    for (key, value) in details[\'totals\'][\'yearly\'].items():\n
      if same_type(value, 1.0) or same_type(value, 1):\n
        details[\'totals\'][\'yearly\'][key] = (\'%.\' + str(currency_precision) + \'f\') % value\n
\n
\n
return details\n


]]></string> </value>
        </item>
        <item>
            <key> <string>_code</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>_filepath</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>_params</string> </key>
            <value> <string>ignore_yearly_sums=False</string> </value>
        </item>
        <item>
            <key> <string>errors</string> </key>
            <value>
              <tuple/>
            </value>
        </item>
        <item>
            <key> <string>func_code</string> </key>
            <value>
              <object>
                <klass>
                  <global name="FuncCode" module="Shared.DC.Scripts.Signature"/>
                </klass>
                <tuple/>
                <state>
                  <dictionary>
                    <item>
                        <key> <string>co_argcount</string> </key>
                        <value> <int>1</int> </value>
                    </item>
                    <item>
                        <key> <string>co_varnames</string> </key>
                        <value>
                          <tuple>
                            <string>ignore_yearly_sums</string>
                            <string>_getattr_</string>
                            <string>context</string>
                            <string>portal</string>
                            <string>gross_salary</string>
                            <string>net_salary</string>
                            <string>taxable_net_salary</string>
                            <string>total_employer_share</string>
                            <string>total_employee_share</string>
                            <string>total_addendum</string>
                            <string>details</string>
                            <string>getPSLGroupIdList</string>
                            <string>groupExist</string>
                            <string>getGroup</string>
                            <string>None</string>
                            <string>getGroupSublineIdList</string>
                            <string>sublineExist</string>
                            <string>getSubline</string>
                            <string>updateSubLine</string>
                            <string>_getiter_</string>
                            <string>psl</string>
                            <string>service</string>
                            <string>salary_range_list</string>
                            <string>tax_category_list</string>
                            <string>tax_category</string>
                            <string>_getitem_</string>
                            <string>group_id</string>
                            <string>group</string>
                            <string>new_group</string>
                            <string>_write_</string>
                            <string>salary_range_path</string>
                            <string>salary_range</string>
                            <string>subline_id</string>
                            <string>service_id</string>
                            <string>False</string>
                            <string>taxable</string>
                            <string>True</string>
                            <string>new_subline</string>
                            <string>groups</string>
                            <string>old_group</string>
                            <string>currency_precision</string>
                            <string>r_</string>
                            <string>line_description</string>
                            <string>line_title</string>
                            <string>cell</string>
                            <string>tax_category_path</string>
                            <string>c</string>
                            <string>cell_group_id</string>
                            <string>cell_subline_id</string>
                            <string>range_type</string>
                            <string>share_type</string>
                            <string>len</string>
                            <string>cell_value</string>
                            <string>cell_rate</string>
                            <string>cell_base</string>
                            <string>cell_share</string>
                            <string>subline</string>
                            <string>DateTime</string>
                            <string>start_year</string>
                            <string>year_start_date</string>
                            <string>year_stop_date</string>
                            <string>yearly_sums</string>
                            <string>yearly_sums_base_id</string>
                            <string>base_id</string>
                            <string>search_params</string>
                            <string>accounting_folder</string>
                            <string>_apply_</string>
                            <string>paysheet_transactions</string>
                            <string>current_paysheet_uid</string>
                            <string>paysheet</string>
                            <string>paysheet_details</string>
                            <string>float</string>
                            <string>RATE_PRECISION</string>
                            <string>money_format</string>
                            <string>rate_format</string>
                            <string>property_format_dict</string>
                            <string>property</string>
                            <string>value</string>
                            <string>same_type</string>
                            <string>format</string>
                            <string>precision</string>
                            <string>str</string>
                            <string>new_value</string>
                            <string>key</string>
                          </tuple>
                        </value>
                    </item>
                  </dictionary>
                </state>
              </object>
            </value>
        </item>
        <item>
            <key> <string>func_defaults</string> </key>
            <value>
              <tuple>
                <int>0</int>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>id</string> </key>
            <value> <string>PaySheetTransaction_getDetails</string> </value>
        </item>
        <item>
            <key> <string>warnings</string> </key>
            <value>
              <tuple/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
