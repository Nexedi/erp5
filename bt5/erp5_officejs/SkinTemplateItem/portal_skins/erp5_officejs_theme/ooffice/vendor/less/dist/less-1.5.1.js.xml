<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts44314540.26</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>less-1.5.1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>246035</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*! \n
 * LESS - Leaner CSS v1.5.1 \n
 * http://lesscss.org \n
 * \n
 * Copyright (c) 2009-2013, Alexis Sellier <self@cloudhead.net> \n
 * Licensed under the Apache v2 License. \n
 * \n
 * @licence \n
 */ \n
\n
\n
\n
(function (window, undefined) {//\n
// Stub out `require` in the browser\n
//\n
function require(arg) {\n
    return window.less[arg.split(\'/\')[1]];\n
};\n
\n
\n
if (typeof(window.less) === \'undefined\' || typeof(window.less.nodeType) !== \'undefined\') { window.less = {}; }\n
less = window.less;\n
tree = window.less.tree = {};\n
less.mode = \'browser\';\n
\n
var less, tree;\n
\n
// Node.js does not have a header file added which defines less\n
if (less === undefined) {\n
    less = exports;\n
    tree = require(\'./tree\');\n
    less.mode = \'node\';\n
}\n
//\n
// less.js - parser\n
//\n
//    A relatively straight-forward predictive parser.\n
//    There is no tokenization/lexing stage, the input is parsed\n
//    in one sweep.\n
//\n
//    To make the parser fast enough to run in the browser, several\n
//    optimization had to be made:\n
//\n
//    - Matching and slicing on a huge input is often cause of slowdowns.\n
//      The solution is to chunkify the input into smaller strings.\n
//      The chunks are stored in the `chunks` var,\n
//      `j` holds the current chunk index, and `current` holds\n
//      the index of the current chunk in relation to `input`.\n
//      This gives us an almost 4x speed-up.\n
//\n
//    - In many cases, we don\'t need to match individual tokens;\n
//      for example, if a value doesn\'t hold any variables, operations\n
//      or dynamic references, the parser can effectively \'skip\' it,\n
//      treating it as a literal.\n
//      An example would be \'1px solid #000\' - which evaluates to itself,\n
//      we don\'t need to know what the individual components are.\n
//      The drawback, of course is that you don\'t get the benefits of\n
//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n
//      and a smaller speed-up in the code-gen.\n
//\n
//\n
//    Token matching is done with the `$` function, which either takes\n
//    a terminal string or regexp, or a non-terminal function to call.\n
//    It also takes care of moving all the indices forwards.\n
//\n
//\n
less.Parser = function Parser(env) {\n
    var input,       // LeSS input string\n
        i,           // current index in `input`\n
        j,           // current chunk\n
        temp,        // temporarily holds a chunk\'s state, for backtracking\n
        memo,        // temporarily holds `i`, when backtracking\n
        furthest,    // furthest index the parser has gone to\n
        chunks,      // chunkified input\n
        current,     // index of current chunk, in `input`\n
        parser,\n
        rootFilename = env && env.filename;\n
\n
    // Top parser on an import tree must be sure there is one "env"\n
    // which will then be passed around by reference.\n
    if (!(env instanceof tree.parseEnv)) {\n
        env = new tree.parseEnv(env);\n
    }\n
\n
    var imports = this.imports = {\n
        paths: env.paths || [],  // Search paths, when importing\n
        queue: [],               // Files which haven\'t been imported yet\n
        files: env.files,        // Holds the imported parse trees\n
        contents: env.contents,  // Holds the imported file contents\n
        mime:  env.mime,         // MIME type of .less files\n
        error: null,             // Error in parsing/evaluating an import\n
        push: function (path, currentFileInfo, importOptions, callback) {\n
            var parserImports = this;\n
            this.queue.push(path);\n
\n
            var fileParsedFunc = function (e, root, fullPath) {\n
                parserImports.queue.splice(parserImports.queue.indexOf(path), 1); // Remove the path from the queue\n
\n
                var importedPreviously = fullPath in parserImports.files || fullPath === rootFilename;\n
\n
                parserImports.files[fullPath] = root;                        // Store the root\n
\n
                if (e && !parserImports.error) { parserImports.error = e; }\n
\n
                callback(e, root, importedPreviously, fullPath);\n
            };\n
\n
            if (less.Parser.importer) {\n
                less.Parser.importer(path, currentFileInfo, fileParsedFunc, env);\n
            } else {\n
                less.Parser.fileLoader(path, currentFileInfo, function(e, contents, fullPath, newFileInfo) {\n
                    if (e) {fileParsedFunc(e); return;}\n
\n
                    var newEnv = new tree.parseEnv(env);\n
\n
                    newEnv.currentFileInfo = newFileInfo;\n
                    newEnv.processImports = false;\n
                    newEnv.contents[fullPath] = contents;\n
\n
                    if (currentFileInfo.reference || importOptions.reference) {\n
                        newFileInfo.reference = true;\n
                    }\n
\n
                    if (importOptions.inline) {\n
                        fileParsedFunc(null, contents, fullPath);\n
                    } else {\n
                        new(less.Parser)(newEnv).parse(contents, function (e, root) {\n
                            fileParsedFunc(e, root, fullPath);\n
                        });\n
                    }\n
                }, env);\n
            }\n
        }\n
    };\n
\n
    function save()    { temp = chunks[j], memo = i, current = i; }\n
    function restore() { chunks[j] = temp, i = memo, current = i; }\n
\n
    function sync() {\n
        if (i > current) {\n
            chunks[j] = chunks[j].slice(i - current);\n
            current = i;\n
        }\n
    }\n
    function isWhitespace(c) {\n
        // Could change to \\s?\n
        var code = c.charCodeAt(0);\n
        return code === 32 || code === 10 || code === 9;\n
    }\n
    //\n
    // Parse from a token, regexp or string, and move forward if match\n
    //\n
    function $(tok) {\n
        var match, length;\n
\n
        //\n
        // Non-terminal\n
        //\n
        if (tok instanceof Function) {\n
            return tok.call(parser.parsers);\n
        //\n
        // Terminal\n
        //\n
        //     Either match a single character in the input,\n
        //     or match a regexp in the current chunk (chunk[j]).\n
        //\n
        } else if (typeof(tok) === \'string\') {\n
            match = input.charAt(i) === tok ? tok : null;\n
            length = 1;\n
            sync ();\n
        } else {\n
            sync ();\n
\n
            if (match = tok.exec(chunks[j])) {\n
                length = match[0].length;\n
            } else {\n
                return null;\n
            }\n
        }\n
\n
        // The match is confirmed, add the match length to `i`,\n
        // and consume any extra white-space characters (\' \' || \'\\n\')\n
        // which come after that. The reason for this is that LeSS\'s\n
        // grammar is mostly white-space insensitive.\n
        //\n
        if (match) {\n
            skipWhitespace(length);\n
\n
            if(typeof(match) === \'string\') {\n
                return match;\n
            } else {\n
                return match.length === 1 ? match[0] : match;\n
            }\n
        }\n
    }\n
\n
    function skipWhitespace(length) {\n
        var oldi = i, oldj = j,\n
            endIndex = i + chunks[j].length,\n
            mem = i += length;\n
\n
        while (i < endIndex) {\n
            if (! isWhitespace(input.charAt(i))) { break; }\n
            i++;\n
        }\n
        chunks[j] = chunks[j].slice(length + (i - mem));\n
        current = i;\n
\n
        if (chunks[j].length === 0 && j < chunks.length - 1) { j++; }\n
\n
        return oldi !== i || oldj !== j;\n
    }\n
\n
    function expect(arg, msg) {\n
        var result = $(arg);\n
        if (! result) {\n
            error(msg || (typeof(arg) === \'string\' ? "expected \'" + arg + "\' got \'" + input.charAt(i) + "\'"\n
                                                   : "unexpected token"));\n
        } else {\n
            return result;\n
        }\n
    }\n
\n
    function error(msg, type) {\n
        var e = new Error(msg);\n
        e.index = i;\n
        e.type = type || \'Syntax\';\n
        throw e;\n
    }\n
\n
    // Same as $(), but don\'t change the state of the parser,\n
    // just return the match.\n
    function peek(tok) {\n
        if (typeof(tok) === \'string\') {\n
            return input.charAt(i) === tok;\n
        } else {\n
            return tok.test(chunks[j]);\n
        }\n
    }\n
\n
    function getInput(e, env) {\n
        if (e.filename && env.currentFileInfo.filename && (e.filename !== env.currentFileInfo.filename)) {\n
            return parser.imports.contents[e.filename];\n
        } else {\n
            return input;\n
        }\n
    }\n
\n
    function getLocation(index, inputStream) {\n
        var n = index + 1,\n
            line = null,\n
            column = -1;\n
\n
        while (--n >= 0 && inputStream.charAt(n) !== \'\\n\') {\n
            column++;\n
        }\n
\n
        if (typeof index === \'number\') {\n
            line = (inputStream.slice(0, index).match(/\\n/g) || "").length;\n
        }\n
\n
        return {\n
            line: line,\n
            column: column\n
        };\n
    }\n
\n
    function getDebugInfo(index, inputStream, env) {\n
        var filename = env.currentFileInfo.filename;\n
        if(less.mode !== \'browser\' && less.mode !== \'rhino\') {\n
            filename = require(\'path\').resolve(filename);\n
        }\n
\n
        return {\n
            lineNumber: getLocation(index, inputStream).line + 1,\n
            fileName: filename\n
        };\n
    }\n
\n
    function LessError(e, env) {\n
        var input = getInput(e, env),\n
            loc = getLocation(e.index, input),\n
            line = loc.line,\n
            col  = loc.column,\n
            callLine = e.call && getLocation(e.call, input).line,\n
            lines = input.split(\'\\n\');\n
\n
        this.type = e.type || \'Syntax\';\n
        this.message = e.message;\n
        this.filename = e.filename || env.currentFileInfo.filename;\n
        this.index = e.index;\n
        this.line = typeof(line) === \'number\' ? line + 1 : null;\n
        this.callLine = callLine + 1;\n
        this.callExtract = lines[callLine];\n
        this.stack = e.stack;\n
        this.column = col;\n
        this.extract = [\n
            lines[line - 1],\n
            lines[line],\n
            lines[line + 1]\n
        ];\n
    }\n
\n
    LessError.prototype = new Error();\n
    LessError.prototype.constructor = LessError;\n
\n
    this.env = env = env || {};\n
\n
    // The optimization level dictates the thoroughness of the parser,\n
    // the lower the number, the less nodes it will create in the tree.\n
    // This could matter for debugging, or if you want to access\n
    // the individual nodes in the tree.\n
    this.optimization = (\'optimization\' in this.env) ? this.env.optimization : 1;\n
\n
    //\n
    // The Parser\n
    //\n
    return parser = {\n
\n
        imports: imports,\n
        //\n
        // Parse an input string into an abstract syntax tree,\n
        // call `callback` when done.\n
        //\n
        parse: function (str, callback) {\n
            var root, line, lines, error = null;\n
\n
            i = j = current = furthest = 0;\n
            input = str.replace(/\\r\\n/g, \'\\n\');\n
\n
            // Remove potential UTF Byte Order Mark\n
            input = input.replace(/^\\uFEFF/, \'\');\n
\n
            parser.imports.contents[env.currentFileInfo.filename] = input;\n
\n
            // Split the input into chunks.\n
            chunks = (function (chunks) {\n
                var j = 0,\n
                    skip = /(?:@\\{[\\w-]+\\}|[^"\'`\\{\\}\\/\\(\\)\\\\])+/g,\n
                    comment = /\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/|\\/\\/.*/g,\n
                    string = /"((?:[^"\\\\\\r\\n]|\\\\.)*)"|\'((?:[^\'\\\\\\r\\n]|\\\\.)*)\'|`((?:[^`]|\\\\.)*)`/g,\n
                    level = 0,\n
                    match,\n
                    chunk = chunks[0],\n
                    inParam;\n
\n
                for (var i = 0, c, cc; i < input.length;) {\n
                    skip.lastIndex = i;\n
                    if (match = skip.exec(input)) {\n
                        if (match.index === i) {\n
                            i += match[0].length;\n
                            chunk.push(match[0]);\n
                        }\n
                    }\n
                    c = input.charAt(i);\n
                    comment.lastIndex = string.lastIndex = i;\n
\n
                    if (match = string.exec(input)) {\n
                        if (match.index === i) {\n
                            i += match[0].length;\n
                            chunk.push(match[0]);\n
                            continue;\n
                        }\n
                    }\n
\n
                    if (!inParam && c === \'/\') {\n
                        cc = input.charAt(i + 1);\n
                        if (cc === \'/\' || cc === \'*\') {\n
                            if (match = comment.exec(input)) {\n
                                if (match.index === i) {\n
                                    i += match[0].length;\n
                                    chunk.push(match[0]);\n
                                    continue;\n
                                }\n
                            }\n
                        }\n
                    }\n
                    \n
                    switch (c) {\n
                        case \'{\':\n
                            if (!inParam) {\n
                                level++;\n
                                chunk.push(c);\n
                                break;\n
                            }\n
                            /* falls through */\n
                        case \'}\':\n
                            if (!inParam) {\n
                                level--;\n
                                chunk.push(c);\n
                                chunks[++j] = chunk = [];\n
                                break;\n
                            }\n
                            /* falls through */\n
                        case \'(\':\n
                            if (!inParam) {\n
                                inParam = true;\n
                                chunk.push(c);\n
                                break;\n
                            }\n
                            /* falls through */\n
                        case \')\':\n
                            if (inParam) {\n
                                inParam = false;\n
                                chunk.push(c);\n
                                break;\n
                            }\n
                            /* falls through */\n
                        default:\n
                            chunk.push(c);\n
                    }\n
                    \n
                    i++;\n
                }\n
                if (level !== 0) {\n
                    error = new(LessError)({\n
                        index: i-1,\n
                        type: \'Parse\',\n
                        message: (level > 0) ? "missing closing `}`" : "missing opening `{`",\n
                        filename: env.currentFileInfo.filename\n
                    }, env);\n
                }\n
\n
                return chunks.map(function (c) { return c.join(\'\'); });\n
            })([[]]);\n
\n
            if (error) {\n
                return callback(new(LessError)(error, env));\n
            }\n
\n
            // Start with the primary rule.\n
            // The whole syntax tree is held under a Ruleset node,\n
            // with the `root` property set to true, so no `{}` are\n
            // output. The callback is called when the input is parsed.\n
            try {\n
                root = new(tree.Ruleset)([], $(this.parsers.primary));\n
                root.root = true;\n
                root.firstRoot = true;\n
            } catch (e) {\n
                return callback(new(LessError)(e, env));\n
            }\n
\n
            root.toCSS = (function (evaluate) {\n
                return function (options, variables) {\n
                    options = options || {};\n
                    var evaldRoot,\n
                        css,\n
                        evalEnv = new tree.evalEnv(options);\n
                        \n
                    //\n
                    // Allows setting variables with a hash, so:\n
                    //\n
                    //   `{ color: new(tree.Color)(\'#f01\') }` will become:\n
                    //\n
                    //   new(tree.Rule)(\'@color\',\n
                    //     new(tree.Value)([\n
                    //       new(tree.Expression)([\n
                    //         new(tree.Color)(\'#f01\')\n
                    //       ])\n
                    //     ])\n
                    //   )\n
                    //\n
                    if (typeof(variables) === \'object\' && !Array.isArray(variables)) {\n
                        variables = Object.keys(variables).map(function (k) {\n
                            var value = variables[k];\n
\n
                            if (! (value instanceof tree.Value)) {\n
                                if (! (value instanceof tree.Expression)) {\n
                                    value = new(tree.Expression)([value]);\n
                                }\n
                                value = new(tree.Value)([value]);\n
                            }\n
                            return new(tree.Rule)(\'@\' + k, value, false, null, 0);\n
                        });\n
                        evalEnv.frames = [new(tree.Ruleset)(null, variables)];\n
                    }\n
\n
                    try {\n
                        evaldRoot = evaluate.call(this, evalEnv);\n
\n
                        new(tree.joinSelectorVisitor)()\n
                            .run(evaldRoot);\n
\n
                        new(tree.processExtendsVisitor)()\n
                            .run(evaldRoot);\n
\n
                        new(tree.toCSSVisitor)({compress: Boolean(options.compress)})\n
                            .run(evaldRoot);\n
\n
                        if (options.sourceMap) {\n
                            evaldRoot = new tree.sourceMapOutput(\n
                                {\n
                                    writeSourceMap: options.writeSourceMap,\n
                                    rootNode: evaldRoot,\n
                                    contentsMap: parser.imports.contents,\n
                                    sourceMapFilename: options.sourceMapFilename,\n
                                    sourceMapURL: options.sourceMapURL,\n
                                    outputFilename: options.sourceMapOutputFilename,\n
                                    sourceMapBasepath: options.sourceMapBasepath,\n
                                    sourceMapRootpath: options.sourceMapRootpath,\n
                                    outputSourceFiles: options.outputSourceFiles,\n
                                    sourceMapGenerator: options.sourceMapGenerator\n
                                });\n
                        }\n
\n
                        css = evaldRoot.toCSS({\n
                                compress: Boolean(options.compress),\n
                                dumpLineNumbers: env.dumpLineNumbers,\n
                                strictUnits: Boolean(options.strictUnits)});\n
                    } catch (e) {\n
                        throw new(LessError)(e, env);\n
                    }\n
\n
                    if (options.cleancss && less.mode === \'node\') {\n
                        var CleanCSS = require(\'clean-css\');\n
                        //TODO would be nice for no advanced to be an option\n
                        return new CleanCSS({keepSpecialComments: \'*\', processImport: false, noRebase: true, noAdvanced: true}).minify(css);\n
                    } else if (options.compress) {\n
                        return css.replace(/(^(\\s)+)|((\\s)+$)/g, "");\n
                    } else {\n
                        return css;\n
                    }\n
                };\n
            })(root.eval);\n
\n
            // If `i` is smaller than the `input.length - 1`,\n
            // it means the parser wasn\'t able to parse the whole\n
            // string, so we\'ve got a parsing error.\n
            //\n
            // We try to extract a \\n delimited string,\n
            // showing the line where the parse error occured.\n
            // We split it up into two parts (the part which parsed,\n
            // and the part which didn\'t), so we can color them differently.\n
            if (i < input.length - 1) {\n
                i = furthest;\n
                var loc = getLocation(i, input);\n
                lines = input.split(\'\\n\');\n
                line = loc.line + 1;\n
\n
                error = {\n
                    type: "Parse",\n
                    message: "Unrecognised input",\n
                    index: i,\n
                    filename: env.currentFileInfo.filename,\n
                    line: line,\n
                    column: loc.column,\n
                    extract: [\n
                        lines[line - 2],\n
                        lines[line - 1],\n
                        lines[line]\n
                    ]\n
                };\n
            }\n
\n
            var finish = function (e) {\n
                e = error || e || parser.imports.error;\n
\n
                if (e) {\n
                    if (!(e instanceof LessError)) {\n
                        e = new(LessError)(e, env);\n
                    }\n
\n
                    return callback(e);\n
                }\n
                else {\n
                    return callback(null, root);\n
                }\n
            };\n
\n
            if (env.processImports !== false) {\n
                new tree.importVisitor(this.imports, finish)\n
                    .run(root);\n
            } else {\n
                return finish();\n
            }\n
        },\n
\n
        //\n
        // Here in, the parsing rules/functions\n
        //\n
        // The basic structure of the syntax tree generated is as follows:\n
        //\n
        //   Ruleset ->  Rule -> Value -> Expression -> Entity\n
        //\n
        // Here\'s some LESS code:\n
        //\n
        //    .class {\n
        //      color: #fff;\n
        //      border: 1px solid #000;\n
        //      width: @w + 4px;\n
        //      > .child {...}\n
        //    }\n
        //\n
        // And here\'s what the parse tree might look like:\n
        //\n
        //     Ruleset (Selector \'.class\', [\n
        //         Rule ("color",  Value ([Expression [Color #fff]]))\n
        //         Rule ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))\n
        //         Rule ("width",  Value ([Expression [Operation "+" [Variable "@w"][Dimension 4px]]]))\n
        //         Ruleset (Selector [Element \'>\', \'.child\'], [...])\n
        //     ])\n
        //\n
        //  In general, most rules will try to parse a token with the `$()` function, and if the return\n
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n
        //  first, before parsing, that\'s when we use `peek()`.\n
        //\n
        parsers: {\n
            //\n
            // The `primary` rule is the *entry* and *exit* point of the parser.\n
            // The rules here can appear at any level of the parse tree.\n
            //\n
            // The recursive nature of the grammar is an interplay between the `block`\n
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n
            // as represented by this simplified grammar:\n
            //\n
            //     primary  →  (ruleset | rule)+\n
            //     ruleset  →  selector+ block\n
            //     block    →  \'{\' primary \'}\'\n
            //\n
            // Only at one point is the primary rule not called from the\n
            // block rule: at the root level.\n
            //\n
            primary: function () {\n
                var node, root = [];\n
\n
                while ((node = $(this.extendRule) || $(this.mixin.definition) || $(this.rule)    ||  $(this.ruleset) ||\n
                               $(this.mixin.call)       || $(this.comment) ||  $(this.directive))\n
                               || $(/^[\\s\\n]+/) || $(/^;+/)) {\n
                    node && root.push(node);\n
                }\n
                return root;\n
            },\n
\n
            // We create a Comment node for CSS comments `/* */`,\n
            // but keep the LeSS comments `//` silent, by just skipping\n
            // over them.\n
            comment: function () {\n
                var comment;\n
\n
                if (input.charAt(i) !== \'/\') { return; }\n
\n
                if (input.charAt(i + 1) === \'/\') {\n
                    return new(tree.Comment)($(/^\\/\\/.*/), true, i, env.currentFileInfo);\n
                } else if (comment = $(/^\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/\\n?/)) {\n
                    return new(tree.Comment)(comment, false, i, env.currentFileInfo);\n
                }\n
            },\n
\n
            comments: function () {\n
                var comment, comments = [];\n
\n
                while(comment = $(this.comment)) {\n
                    comments.push(comment);\n
                }\n
\n
                return comments;\n
            },\n
\n
            //\n
            // Entities are tokens which can be found inside an Expression\n
            //\n
            entities: {\n
                //\n
                // A string, which supports escaping " and \'\n
                //\n
                //     "milky way" \'he\\\'s the one!\'\n
                //\n
                quoted: function () {\n
                    var str, j = i, e, index = i;\n
\n
                    if (input.charAt(j) === \'~\') { j++, e = true; } // Escaped strings\n
                    if (input.charAt(j) !== \'"\' && input.charAt(j) !== "\'") { return; }\n
\n
                    e && $(\'~\');\n
\n
                    if (str = $(/^"((?:[^"\\\\\\r\\n]|\\\\.)*)"|\'((?:[^\'\\\\\\r\\n]|\\\\.)*)\'/)) {\n
                        return new(tree.Quoted)(str[0], str[1] || str[2], e, index, env.currentFileInfo);\n
                    }\n
                },\n
\n
                //\n
                // A catch-all word, such as:\n
                //\n
                //     black border-collapse\n
                //\n
                keyword: function () {\n
                    var k;\n
\n
                    if (k = $(/^[_A-Za-z-][_A-Za-z0-9-]*/)) {\n
                        var color = tree.Color.fromKeyword(k);\n
                        if (color) {\n
                            return color;\n
                        }\n
                        return new(tree.Keyword)(k);\n
                    }\n
                },\n
\n
                //\n
                // A function call\n
                //\n
                //     rgb(255, 0, 255)\n
                //\n
                // We also try to catch IE\'s `alpha()`, but let the `alpha` parser\n
                // deal with the details.\n
                //\n
                // The arguments are parsed with the `entities.arguments` parser.\n
                //\n
                call: function () {\n
                    var name, nameLC, args, alpha_ret, index = i;\n
\n
                    if (! (name = /^([\\w-]+|%|progid:[\\w\\.]+)\\(/.exec(chunks[j]))) { return; }\n
\n
                    name = name[1];\n
                    nameLC = name.toLowerCase();\n
\n
                    if (nameLC === \'url\') { return null; }\n
                    else                  { i += name.length; }\n
\n
                    if (nameLC === \'alpha\') {\n
                        alpha_ret = $(this.alpha);\n
                        if(typeof alpha_ret !== \'undefined\') {\n
                            return alpha_ret;\n
                        }\n
                    }\n
\n
                    $(\'(\'); // Parse the \'(\' and consume whitespace.\n
\n
                    args = $(this.entities.arguments);\n
\n
                    if (! $(\')\')) {\n
                        return;\n
                    }\n
\n
                    if (name) { return new(tree.Call)(name, args, index, env.currentFileInfo); }\n
                },\n
                arguments: function () {\n
                    var args = [], arg;\n
\n
                    while (arg = $(this.entities.assignment) || $(this.expression)) {\n
                        args.push(arg);\n
                        if (! $(\',\')) {\n
                            break;\n
                        }\n
                    }\n
                    return args;\n
                },\n
                literal: function () {\n
                    return $(this.entities.dimension) ||\n
                           $(this.entities.color) ||\n
                           $(this.entities.quoted) ||\n
                           $(this.entities.unicodeDescriptor);\n
                },\n
\n
                // Assignments are argument entities for calls.\n
                // They are present in ie filter properties as shown below.\n
                //\n
                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n
                //\n
\n
                assignment: function () {\n
                    var key, value;\n
                    if ((key = $(/^\\w+(?=\\s?=)/i)) && $(\'=\') && (value = $(this.entity))) {\n
                        return new(tree.Assignment)(key, value);\n
                    }\n
                },\n
\n
                //\n
                // Parse url() tokens\n
                //\n
                // We use a specific rule for urls, because they don\'t really behave like\n
                // standard function calls. The difference is that the argument doesn\'t have\n
                // to be enclosed within a string, so it can\'t be parsed as an Expression.\n
                //\n
                url: function () {\n
                    var value;\n
\n
                    if (input.charAt(i) !== \'u\' || !$(/^url\\(/)) {\n
                        return;\n
                    }\n
\n
                    value = $(this.entities.quoted)  || $(this.entities.variable) ||\n
                            $(/^(?:(?:\\\\[\\(\\)\'"])|[^\\(\\)\'"])+/) || "";\n
\n
                    expect(\')\');\n
\n
                    /*jshint eqnull:true */\n
                    return new(tree.URL)((value.value != null || value instanceof tree.Variable)\n
                                        ? value : new(tree.Anonymous)(value), env.currentFileInfo);\n
                },\n
\n
                //\n
                // A Variable entity, such as `@fink`, in\n
                //\n
                //     width: @fink + 2px\n
                //\n
                // We use a different parser for variable definitions,\n
                // see `parsers.variable`.\n
                //\n
                variable: function () {\n
                    var name, index = i;\n
\n
                    if (input.charAt(i) === \'@\' && (name = $(/^@@?[\\w-]+/))) {\n
                        return new(tree.Variable)(name, index, env.currentFileInfo);\n
                    }\n
                },\n
\n
                // A variable entity useing the protective {} e.g. @{var}\n
                variableCurly: function () {\n
                    var curly, index = i;\n
\n
                    if (input.charAt(i) === \'@\' && (curly = $(/^@\\{([\\w-]+)\\}/))) {\n
                        return new(tree.Variable)("@" + curly[1], index, env.currentFileInfo);\n
                    }\n
                },\n
\n
                //\n
                // A Hexadecimal color\n
                //\n
                //     #4F3C2F\n
                //\n
                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n
                //\n
                color: function () {\n
                    var rgb;\n
\n
                    if (input.charAt(i) === \'#\' && (rgb = $(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))) {\n
                        return new(tree.Color)(rgb[1]);\n
                    }\n
                },\n
\n
                //\n
                // A Dimension, that is, a number and a unit\n
                //\n
                //     0.5em 95%\n
                //\n
                dimension: function () {\n
                    var value, c = input.charCodeAt(i);\n
                    //Is the first char of the dimension 0-9, \'.\', \'+\' or \'-\'\n
                    if ((c > 57 || c < 43) || c === 47 || c == 44) {\n
                        return;\n
                    }\n
\n
                    if (value = $(/^([+-]?\\d*\\.?\\d+)(%|[a-z]+)?/)) {\n
                        return new(tree.Dimension)(value[1], value[2]);\n
                    }\n
                },\n
\n
                //\n
                // A unicode descriptor, as is used in unicode-range\n
                //\n
                // U+0??  or U+00A1-00A9\n
                //\n
                unicodeDescriptor: function () {\n
                    var ud;\n
                    \n
                    if (ud = $(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/)) {\n
                        return new(tree.UnicodeDescriptor)(ud[0]);\n
                    }\n
                },\n
\n
                //\n
                // JavaScript code to be evaluated\n
                //\n
                //     `window.location.href`\n
                //\n
                javascript: function () {\n
                    var str, j = i, e;\n
\n
                    if (input.charAt(j) === \'~\') { j++; e = true; } // Escaped strings\n
                    if (input.charAt(j) !== \'`\') { return; }\n
                    if (env.javascriptEnabled !== undefined && !env.javascriptEnabled) {\n
                        error("You are using JavaScript, which has been disabled.");\n
                    }\n
\n
                    if (e) { $(\'~\'); }\n
\n
                    if (str = $(/^`([^`]*)`/)) {\n
                        return new(tree.JavaScript)(str[1], i, e);\n
                    }\n
                }\n
            },\n
\n
            //\n
            // The variable part of a variable definition. Used in the `rule` parser\n
            //\n
            //     @fink:\n
            //\n
            variable: function () {\n
                var name;\n
\n
                if (input.charAt(i) === \'@\' && (name = $(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n
            },\n
\n
            //\n
            // extend syntax - used to extend selectors\n
            //\n
            extend: function(isRule) {\n
                var elements, e, index = i, option, extendList = [];\n
\n
                if (!$(isRule ? /^&:extend\\(/ : /^:extend\\(/)) { return; }\n
\n
                do {\n
                    option = null;\n
                    elements = [];\n
                    while (true) {\n
                        option = $(/^(all)(?=\\s*(\\)|,))/);\n
                        if (option) { break; }\n
                        e = $(this.element);\n
                        if (!e) { break; }\n
                        elements.push(e);\n
                    }\n
\n
                    option = option && option[1];\n
\n
                    extendList.push(new(tree.Extend)(new(tree.Selector)(elements), option, index));\n
\n
                } while($(","));\n
                \n
                expect(/^\\)/);\n
\n
                if (isRule) {\n
                    expect(/^;/);\n
                }\n
\n
                return extendList;\n
            },\n
\n
            //\n
            // extendRule - used in a rule to extend all the parent selectors\n
            //\n
            extendRule: function() {\n
                return this.extend(true);\n
            },\n
            \n
            //\n
            // Mixins\n
            //\n
            mixin: {\n
                //\n
                // A Mixin call, with an optional argument list\n
                //\n
                //     #mixins > .square(#fff);\n
                //     .rounded(4px, black);\n
                //     .button;\n
                //\n
                // The `while` loop is there because mixins can be\n
                // namespaced, but we only support the child and descendant\n
                // selector for now.\n
                //\n
                call: function () {\n
                    var elements = [], e, c, args, index = i, s = input.charAt(i), important = false;\n
\n
                    if (s !== \'.\' && s !== \'#\') { return; }\n
\n
                    save(); // stop us absorbing part of an invalid selector\n
\n
                    while (e = $(/^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/)) {\n
                        elements.push(new(tree.Element)(c, e, i, env.currentFileInfo));\n
                        c = $(\'>\');\n
                    }\n
                    if ($(\'(\')) {\n
                        args = this.mixin.args.call(this, true).args;\n
                        expect(\')\');\n
                    }\n
\n
                    args = args || [];\n
\n
                    if ($(this.important)) {\n
                        important = true;\n
                    }\n
\n
                    if (elements.length > 0 && ($(\';\') || peek(\'}\'))) {\n
                        return new(tree.mixin.Call)(elements, args, index, env.currentFileInfo, important);\n
                    }\n
\n
                    restore();\n
                },\n
                args: function (isCall) {\n
                    var expressions = [], argsSemiColon = [], isSemiColonSeperated, argsComma = [], expressionContainsNamed, name, nameLoop, value, arg,\n
                        returner = {args:null, variadic: false};\n
                    while (true) {\n
                        if (isCall) {\n
                            arg = $(this.expression);\n
                        } else {\n
                            $(this.comments);\n
                            if (input.charAt(i) === \'.\' && $(/^\\.{3}/)) {\n
                                returner.variadic = true;\n
                                if ($(";") && !isSemiColonSeperated) {\n
                                    isSemiColonSeperated = true;\n
                                }\n
                                (isSemiColonSeperated ? argsSemiColon : argsComma)\n
                                    .push({ variadic: true });\n
                                break;\n
                            }\n
                            arg = $(this.entities.variable) || $(this.entities.literal)\n
                                || $(this.entities.keyword);\n
                        }\n
\n
                        if (!arg) {\n
                            break;\n
                        }\n
\n
                        nameLoop = null;\n
                        if (arg.throwAwayComments) {\n
                            arg.throwAwayComments();\n
                        }\n
                        value = arg;\n
                        var val = null;\n
\n
                        if (isCall) {\n
                            // Variable\n
                            if (arg.value.length == 1) {\n
                                val = arg.value[0];\n
                            }\n
                        } else {\n
                            val = arg;\n
                        }\n
\n
                        if (val && val instanceof tree.Variable) {\n
                            if ($(\':\')) {\n
                                if (expressions.length > 0) {\n
                                    if (isSemiColonSeperated) {\n
                                        error("Cannot mix ; and , as delimiter types");\n
                                    }\n
                                    expressionContainsNamed = true;\n
                                }\n
                                value = expect(this.expression);\n
                                nameLoop = (name = val.name);\n
                            } else if (!isCall && $(/^\\.{3}/)) {\n
                                returner.variadic = true;\n
                                if ($(";") && !isSemiColonSeperated) {\n
                                    isSemiColonSeperated = true;\n
                                }\n
                                (isSemiColonSeperated ? argsSemiColon : argsComma)\n
                                    .push({ name: arg.name, variadic: true });\n
                                break;\n
                            } else if (!isCall) {\n
                                name = nameLoop = val.name;\n
                                value = null;\n
                            }\n
                        }\n
\n
                        if (value) {\n
                            expressions.push(value);\n
                        }\n
\n
                        argsComma.push({ name:nameLoop, value:value });\n
\n
                        if ($(\',\')) {\n
                            continue;\n
                        }\n
\n
                        if ($(\';\') || isSemiColonSeperated) {\n
\n
                            if (expressionContainsNamed) {\n
                                error("Cannot mix ; and , as delimiter types");\n
                            }\n
\n
                            isSemiColonSeperated = true;\n
\n
                            if (expressions.length > 1) {\n
                                value = new(tree.Value)(expressions);\n
                            }\n
                            argsSemiColon.push({ name:name, value:value });\n
\n
                            name = null;\n
                            expressions = [];\n
                            expressionContainsNamed = false;\n
                        }\n
                    }\n
\n
                    returner.args = isSemiColonSeperated ? argsSemiColon : argsComma;\n
                    return returner;\n
                },\n
                //\n
                // A Mixin definition, with a list of parameters\n
                //\n
                //     .rounded (@radius: 2px, @color) {\n
                //        ...\n
                //     }\n
                //\n
                // Until we have a finer grained state-machine, we have to\n
                // do a look-ahead, to make sure we don\'t have a mixin call.\n
                // See the `rule` function for more information.\n
                //\n
                // We start by matching `.rounded (`, and then proceed on to\n
                // the argument list, which has optional default values.\n
                // We store the parameters in `params`, with a `value` key,\n
                // if there is a value, such as in the case of `@radius`.\n
                //\n
                // Once we\'ve got our params list, and a closing `)`, we parse\n
                // the `{...}` block.\n
                //\n
                definition: function () {\n
                    var name, params = [], match, ruleset, cond, variadic = false;\n
                    if ((input.charAt(i) !== \'.\' && input.charAt(i) !== \'#\') ||\n
                        peek(/^[^{]*\\}/)) {\n
                        return;\n
                    }\n
\n
                    save();\n
\n
                    if (match = $(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/)) {\n
                        name = match[1];\n
\n
                        var argInfo = this.mixin.args.call(this, false);\n
                        params = argInfo.args;\n
                        variadic = argInfo.variadic;\n
\n
                        // .mixincall("@{a}");\n
                        // looks a bit like a mixin definition.. so we have to be nice and restore\n
                        if (!$(\')\')) {\n
                            furthest = i;\n
                            restore();\n
                        }\n
                        \n
                        $(this.comments);\n
\n
                        if ($(/^when/)) { // Guard\n
                            cond = expect(this.conditions, \'expected condition\');\n
                        }\n
\n
                        ruleset = $(this.block);\n
\n
                        if (ruleset) {\n
                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n
                        } else {\n
                            restore();\n
                        }\n
                    }\n
                }\n
            },\n
\n
            //\n
            // Entities are the smallest recognized token,\n
            // and can be found inside a rule\'s value.\n
            //\n
            entity: function () {\n
                return $(this.entities.literal) || $(this.entities.variable) || $(this.entities.url) ||\n
                       $(this.entities.call)    || $(this.entities.keyword)  ||$(this.entities.javascript) ||\n
                       $(this.comment);\n
            },\n
\n
            //\n
            // A Rule terminator. Note that we use `peek()` to check for \'}\',\n
            // because the `block` rule will be expecting it, but we still need to make sure\n
            // it\'s there, if \';\' was ommitted.\n
            //\n
            end: function () {\n
                return $(\';\') || peek(\'}\');\n
            },\n
\n
            //\n
            // IE\'s alpha function\n
            //\n
            //     alpha(opacity=88)\n
            //\n
            alpha: function () {\n
                var value;\n
\n
                if (! $(/^\\(opacity=/i)) { return; }\n
                if (value = $(/^\\d+/) || $(this.entities.variable)) {\n
                    expect(\')\');\n
                    return new(tree.Alpha)(value);\n
                }\n
            },\n
\n
            //\n
            // A Selector Element\n
            //\n
            //     div\n
            //     + h1\n
            //     #socks\n
            //     input[type="text"]\n
            //\n
            // Elements are the building blocks for Selectors,\n
            // they are made out of a `Combinator` (see combinator rule),\n
            // and an element name, such as a tag a class, or `*`.\n
            //\n
            element: function () {\n
                var e, c, v;\n
\n
                c = $(this.combinator);\n
\n
                e = $(/^(?:\\d+\\.\\d+|\\d+)%/) || $(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n
                    $(\'*\') || $(\'&\') || $(this.attribute) || $(/^\\([^()@]+\\)/) || $(/^[\\.#](?=@)/) || $(this.entities.variableCurly);\n
\n
                if (! e) {\n
                    if ($(\'(\')) {\n
                        if ((v = ($(this.selector))) &&\n
                                $(\')\')) {\n
                            e = new(tree.Paren)(v);\n
                        }\n
                    }\n
                }\n
\n
                if (e) { return new(tree.Element)(c, e, i, env.currentFileInfo); }\n
            },\n
\n
            //\n
            // Combinators combine elements together, in a Selector.\n
            //\n
            // Because our parser isn\'t white-space sensitive, special care\n
            // has to be taken, when parsing the descendant combinator, ` `,\n
            // as it\'s an empty space. We have to check the previous character\n
            // in the input, to see if it\'s a ` ` character. More info on how\n
            // we deal with this in *combinator.js*.\n
            //\n
            combinator: function () {\n
                var c = input.charAt(i);\n
\n
                if (c === \'>\' || c === \'+\' || c === \'~\' || c === \'|\') {\n
                    i++;\n
                    while (input.charAt(i).match(/\\s/)) { i++; }\n
                    return new(tree.Combinator)(c);\n
                } else if (input.charAt(i - 1).match(/\\s/)) {\n
                    return new(tree.Combinator)(" ");\n
                } else {\n
                    return new(tree.Combinator)(null);\n
                }\n
            },\n
            //\n
            // A CSS selector (see selector below)\n
            // with less extensions e.g. the ability to extend and guard\n
            //\n
            lessSelector: function () {\n
                return this.selector(true);\n
            },\n
            //\n
            // A CSS Selector\n
            //\n
            //     .class > div + h1\n
            //     li a:hover\n
            //\n
            // Selectors are made out of one or more Elements, see above.\n
            //\n
            selector: function (isLess) {\n
                var e, elements = [], c, extend, extendList = [], when, condition;\n
\n
                while ((isLess && (extend = $(this.extend))) || (isLess && (when = $(/^when/))) || (e = $(this.element))) {\n
                    if (when) {\n
                        condition = expect(this.conditions, \'expected condition\');\n
                    } else if (condition) {\n
                        error("CSS guard can only be used at the end of selector");\n
                    } else if (extend) {\n
                        extendList.push.apply(extendList, extend);\n
                    } else {\n
                        if (extendList.length) {\n
                            error("Extend can only be used at the end of selector");\n
                        }\n
                        c = input.charAt(i);\n
                        elements.push(e);\n
                        e = null;\n
                    }\n
                    if (c === \'{\' || c === \'}\' || c === \';\' || c === \',\' || c === \')\') {\n
                        break;\n
                    }\n
                }\n
\n
                if (elements.length > 0) { return new(tree.Selector)(elements, extendList, condition, i, env.currentFileInfo); }\n
                if (extendList.length) { error("Extend must be used to extend a selector, it cannot be used on its own"); }\n
            },\n
            attribute: function () {\n
                var key, val, op;\n
\n
                if (! $(\'[\')) { return; }\n
\n
                if (!(key = $(this.entities.variableCurly))) {\n
                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n
                }\n
\n
                if ((op = $(/^[|~*$^]?=/))) {\n
                    val = $(this.entities.quoted) || $(/^[0-9]+%/) || $(/^[\\w-]+/) || $(this.entities.variableCurly);\n
                }\n
\n
                expect(\']\');\n
\n
                return new(tree.Attribute)(key, op, val);\n
            },\n
\n
            //\n
            // The `block` rule is used by `ruleset` and `mixin.definition`.\n
            // It\'s a wrapper around the `primary` rule, with added `{}`.\n
            //\n
            block: function () {\n
                var content;\n
                if ($(\'{\') && (content = $(this.primary)) && $(\'}\')) {\n
                    return content;\n
                }\n
            },\n
\n
            //\n
            // div, .class, body > p {...}\n
            //\n
            ruleset: function () {\n
                var selectors = [], s, rules, debugInfo;\n
                \n
                save();\n
\n
                if (env.dumpLineNumbers) {\n
                    debugInfo = getDebugInfo(i, input, env);\n
                }\n
\n
                while (s = $(this.lessSelector)) {\n
                    selectors.push(s);\n
                    $(this.comments);\n
                    if (! $(\',\')) { break; }\n
                    if (s.condition) {\n
                        error("Guards are only currently allowed on a single selector.");\n
                    }\n
                    $(this.comments);\n
                }\n
\n
                if (selectors.length > 0 && (rules = $(this.block))) {\n
                    var ruleset = new(tree.Ruleset)(selectors, rules, env.strictImports);\n
                    if (env.dumpLineNumbers) {\n
                        ruleset.debugInfo = debugInfo;\n
                    }\n
                    return ruleset;\n
                } else {\n
                    // Backtrack\n
                    furthest = i;\n
                    restore();\n
                }\n
            },\n
            rule: function (tryAnonymous) {\n
                var name, value, c = input.charAt(i), important, merge = false;\n
                save();\n
\n
                if (c === \'.\' || c === \'#\' || c === \'&\') { return; }\n
\n
                if (name = $(this.variable) || $(this.ruleProperty)) {\n
                    // prefer to try to parse first if its a variable or we are compressing\n
                    // but always fallback on the other one\n
                    value = !tryAnonymous && (env.compress || (name.charAt(0) === \'@\')) ?\n
                        ($(this.value) || $(this.anonymousValue)) :\n
                        ($(this.anonymousValue) || $(this.value));\n
\n
\n
                    important = $(this.important);\n
                    if (name[name.length-1] === "+") {\n
                        merge = true;\n
                        name = name.substr(0, name.length - 1);\n
                    }\n
\n
                    if (value && $(this.end)) {\n
                        return new (tree.Rule)(name, value, important, merge, memo, env.currentFileInfo);\n
                    } else {\n
                        furthest = i;\n
                        restore();\n
                        if (value && !tryAnonymous) {\n
                            return this.rule(true);\n
                        }\n
                    }\n
                }\n
            },\n
            anonymousValue: function () {\n
                var match;\n
                if (match = /^([^@+\\/\'"*`(;{}-]*);/.exec(chunks[j])) {\n
                    i += match[0].length - 1;\n
                    return new(tree.Anonymous)(match[1]);\n
                }\n
            },\n
\n
            //\n
            // An @import directive\n
            //\n
            //     @import "lib";\n
            //\n
            // Depending on our environemnt, importing is done differently:\n
            // In the browser, it\'s an XHR request, in Node, it would be a\n
            // file-system operation. The function used for importing is\n
            // stored in `import`, which we pass to the Import constructor.\n
            //\n
            "import": function () {\n
                var path, features, index = i;\n
\n
                save();\n
\n
                var dir = $(/^@import?\\s+/);\n
\n
                var options = (dir ? $(this.importOptions) : null) || {};\n
\n
                if (dir && (path = $(this.entities.quoted) || $(this.entities.url))) {\n
                    features = $(this.mediaFeatures);\n
                    if ($(\';\')) {\n
                        features = features && new(tree.Value)(features);\n
                        return new(tree.Import)(path, features, options, index, env.currentFileInfo);\n
                    }\n
                }\n
\n
                restore();\n
            },\n
\n
            importOptions: function() {\n
                var o, options = {}, optionName, value;\n
\n
                // list of options, surrounded by parens\n
                if (! $(\'(\')) { return null; }\n
                do {\n
                    if (o = $(this.importOption)) {\n
                        optionName = o;\n
                        value = true;\n
                        switch(optionName) {\n
                            case "css":\n
                                optionName = "less";\n
                                value = false;\n
                            break;\n
                            case "once":\n
                                optionName = "multiple";\n
                                value = false;\n
                            break;\n
                        }\n
                        options[optionName] = value;\n
                        if (! $(\',\')) { break; }\n
                    }\n
                } while (o);\n
                expect(\')\');\n
                return options;\n
            },\n
\n
            importOption: function() {\n
                var opt = $(/^(less|css|multiple|once|inline|reference)/);\n
                if (opt) {\n
                    return opt[1];\n
                }\n
            },\n
\n
            mediaFeature: function () {\n
                var e, p, nodes = [];\n
\n
                do {\n
                    if (e = ($(this.entities.keyword) || $(this.entities.variable))) {\n
                        nodes.push(e);\n
                    } else if ($(\'(\')) {\n
                        p = $(this.property);\n
                        e = $(this.value);\n
                        if ($(\')\')) {\n
                            if (p && e) {\n
                                nodes.push(new(tree.Paren)(new(tree.Rule)(p, e, null, null, i, env.currentFileInfo, true)));\n
                            } else if (e) {\n
                                nodes.push(new(tree.Paren)(e));\n
                            } else {\n
                                return null;\n
                            }\n
                        } else { return null; }\n
                    }\n
                } while (e);\n
\n
                if (nodes.length > 0) {\n
                    return new(tree.Expression)(nodes);\n
                }\n
            },\n
\n
            mediaFeatures: function () {\n
                var e, features = [];\n
\n
                do {\n
                  if (e = $(this.mediaFeature)) {\n
                      features.push(e);\n
                      if (! $(\',\')) { break; }\n
                  } else if (e = $(this.entities.variable)) {\n
                      features.push(e);\n
                      if (! $(\',\')) { break; }\n
                  }\n
                } while (e);\n
\n
                return features.length > 0 ? features : null;\n
            },\n
\n
            media: function () {\n
                var features, rules, media, debugInfo;\n
\n
                if (env.dumpLineNumbers) {\n
                    debugInfo = getDebugInfo(i, input, env);\n
                }\n
\n
                if ($(/^@media/)) {\n
                    features = $(this.mediaFeatures);\n
\n
                    if (rules = $(this.block)) {\n
                        media = new(tree.Media)(rules, features, i, env.currentFileInfo);\n
                        if (env.dumpLineNumbers) {\n
                            media.debugInfo = debugInfo;\n
                        }\n
                        return media;\n
                    }\n
                }\n
            },\n
\n
            //\n
            // A CSS Directive\n
            //\n
            //     @charset "utf-8";\n
            //\n
            directive: function () {\n
                var name, value, rules, nonVendorSpecificName,\n
                    hasBlock, hasIdentifier, hasExpression, identifier;\n
\n
                if (input.charAt(i) !== \'@\') { return; }\n
\n
                if (value = $(this[\'import\']) || $(this.media)) {\n
                    return value;\n
                }\n
\n
                save();\n
\n
                name = $(/^@[a-z-]+/);\n
                \n
                if (!name) { return; }\n
\n
                nonVendorSpecificName = name;\n
                if (name.charAt(1) == \'-\' && name.indexOf(\'-\', 2) > 0) {\n
                    nonVendorSpecificName = "@" + name.slice(name.indexOf(\'-\', 2) + 1);\n
                }\n
\n
                switch(nonVendorSpecificName) {\n
                    case "@font-face":\n
                        hasBlock = true;\n
                        break;\n
                    case "@viewport":\n
                    case "@top-left":\n
                    case "@top-left-corner":\n
                    case "@top-center":\n
                    case "@top-right":\n
                    case "@top-right-corner":\n
                    case "@bottom-left":\n
                    case "@bottom-left-corner":\n
                    case "@bottom-center":\n
                    case "@bottom-right":\n
                    case "@bottom-right-corner":\n
                    case "@left-top":\n
                    case "@left-middle":\n
                    case "@left-bottom":\n
                    case "@right-top":\n
                    case "@right-middle":\n
                    case "@right-bottom":\n
                        hasBlock = true;\n
                        break;\n
                    case "@host":\n
                    case "@page":\n
                    case "@document":\n
                    case "@supports":\n
                    case "@keyframes":\n
                        hasBlock = true;\n
                        hasIdentifier = true;\n
                        break;\n
                    case "@namespace":\n
                        hasExpression = true;\n
                        break;\n
                }\n
\n
                if (hasIdentifier) {\n
                    identifier = ($(/^[^{]+/) || \'\').trim();\n
                    if (identifier) {\n
                        name += " " + identifier;\n
                    }\n
                }\n
\n
                if (hasBlock)\n
                {\n
                    if (rules = $(this.block)) {\n
                        return new(tree.Directive)(name, rules, i, env.currentFileInfo);\n
                    }\n
                } else {\n
                    if ((value = hasExpression ? $(this.expression) : $(this.entity)) && $(\';\')) {\n
                        var directive = new(tree.Directive)(name, value, i, env.currentFileInfo);\n
                        if (env.dumpLineNumbers) {\n
                            directive.debugInfo = getDebugInfo(i, input, env);\n
                        }\n
                        return directive;\n
                    }\n
                }\n
\n
                restore();\n
            },\n
\n
            //\n
            // A Value is a comma-delimited list of Expressions\n
            //\n
            //     font-family: Baskerville, Georgia, serif;\n
            //\n
            // In a Rule, a Value represents everything after the `:`,\n
            // and before the `;`.\n
            //\n
            value: function () {\n
                var e, expressions = [];\n
\n
                while (e = $(this.expression)) {\n
                    expressions.push(e);\n
                    if (! $(\',\')) { break; }\n
                }\n
\n
                if (expressions.length > 0) {\n
                    return new(tree.Value)(expressions);\n
                }\n
            },\n
            important: function () {\n
                if (input.charAt(i) === \'!\') {\n
                    return $(/^! *important/);\n
                }\n
            },\n
            sub: function () {\n
                var a, e;\n
\n
                if ($(\'(\')) {\n
                    if (a = $(this.addition)) {\n
                        e = new(tree.Expression)([a]);\n
                        expect(\')\');\n
                        e.parens = true;\n
                        return e;\n
                    }\n
                }\n
            },\n
            multiplication: function () {\n
                var m, a, op, operation, isSpaced;\n
                if (m = $(this.operand)) {\n
                    isSpaced = isWhitespace(input.charAt(i - 1));\n
                    while (!peek(/^\\/[*\\/]/) && (op = ($(\'/\') || $(\'*\')))) {\n
                        if (a = $(this.operand)) {\n
                            m.parensInOp = true;\n
                            a.parensInOp = true;\n
                            operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n
                            isSpaced = isWhitespace(input.charAt(i - 1));\n
                        } else {\n
                            break;\n
                        }\n
                    }\n
                    return operation || m;\n
                }\n
            },\n
            addition: function () {\n
                var m, a, op, operation, isSpaced;\n
                if (m = $(this.multiplication)) {\n
                    isSpaced = isWhitespace(input.charAt(i - 1));\n
                    while ((op = $(/^[-+]\\s+/) || (!isSpaced && ($(\'+\') || $(\'-\')))) &&\n
                           (a = $(this.multiplication))) {\n
                        m.parensInOp = true;\n
                        a.parensInOp = true;\n
                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n
                        isSpaced = isWhitespace(input.charAt(i - 1));\n
                    }\n
                    return operation || m;\n
                }\n
            },\n
            conditions: function () {\n
                var a, b, index = i, condition;\n
\n
                if (a = $(this.condition)) {\n
                    while (peek(/^,\\s*(not\\s*)?\\(/) && $(\',\') && (b = $(this.condition))) {\n
                        condition = new(tree.Condition)(\'or\', condition || a, b, index);\n
                    }\n
                    return condition || a;\n
                }\n
            },\n
            condition: function () {\n
                var a, b, c, op, index = i, negate = false;\n
\n
                if ($(/^not/)) { negate = true; }\n
                expect(\'(\');\n
                if (a = $(this.addition) || $(this.entities.keyword) || $(this.entities.quoted)) {\n
                    if (op = $(/^(?:>=|<=|=<|[<=>])/)) {\n
                        if (b = $(this.addition) || $(this.entities.keyword) || $(this.entities.quoted)) {\n
                            c = new(tree.Condition)(op, a, b, index, negate);\n
                        } else {\n
                            error(\'expected expression\');\n
                        }\n
                    } else {\n
                        c = new(tree.Condition)(\'=\', a, new(tree.Keyword)(\'true\'), index, negate);\n
                    }\n
                    expect(\')\');\n
                    return $(/^and/) ? new(tree.Condition)(\'and\', c, $(this.condition)) : c;\n
                }\n
            },\n
\n
            //\n
            // An operand is anything that can be part of an operation,\n
            // such as a Color, or a Variable\n
            //\n
            operand: function () {\n
                var negate, p = input.charAt(i + 1);\n
\n
                if (input.charAt(i) === \'-\' && (p === \'@\' || p === \'(\')) { negate = $(\'-\'); }\n
                var o = $(this.sub) || $(this.entities.dimension) ||\n
                        $(this.entities.color) || $(this.entities.variable) ||\n
                        $(this.entities.call);\n
\n
                if (negate) {\n
                    o.parensInOp = true;\n
                    o = new(tree.Negative)(o);\n
                }\n
\n
                return o;\n
            },\n
\n
            //\n
            // Expressions either represent mathematical operations,\n
            // or white-space delimited Entities.\n
            //\n
            //     1px solid black\n
            //     @var * 2\n
            //\n
            expression: function () {\n
                var e, delim, entities = [];\n
\n
                while (e = $(this.addition) || $(this.entity)) {\n
                    entities.push(e);\n
                    // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here\n
                    if (!peek(/^\\/[\\/*]/) && (delim = $(\'/\'))) {\n
                        entities.push(new(tree.Anonymous)(delim));\n
                    }\n
                }\n
                if (entities.length > 0) {\n
                    return new(tree.Expression)(entities);\n
                }\n
            },\n
            property: function () {\n
                var name;\n
\n
                if (name = $(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/)) {\n
                    return name[1];\n
                }\n
            },\n
            ruleProperty: function () {\n
                var name;\n
\n
                if (name = $(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*(\\+?)\\s*:/)) {\n
                    return name[1] + (name[2] || "");\n
                }\n
            }\n
        }\n
    };\n
};\n
\n
\n
(function (tree) {\n
\n
tree.functions = {\n
    rgb: function (r, g, b) {\n
        return this.rgba(r, g, b, 1.0);\n
    },\n
    rgba: function (r, g, b, a) {\n
        var rgb = [r, g, b].map(function (c) { return scaled(c, 256); });\n
        a = number(a);\n
        return new(tree.Color)(rgb, a);\n
    },\n
    hsl: function (h, s, l) {\n
        return this.hsla(h, s, l, 1.0);\n
    },\n
    hsla: function (h, s, l, a) {\n
        function hue(h) {\n
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n
            if      (h * 6 < 1) { return m1 + (m2 - m1) * h * 6; }\n
            else if (h * 2 < 1) { return m2; }\n
            else if (h * 3 < 2) { return m1 + (m2 - m1) * (2/3 - h) * 6; }\n
            else                { return m1; }\n
        }\n
\n
        h = (number(h) % 360) / 360;\n
        s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));\n
\n
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n
        var m1 = l * 2 - m2;\n
\n
        return this.rgba(hue(h + 1/3) * 255,\n
                         hue(h)       * 255,\n
                         hue(h - 1/3) * 255,\n
                         a);\n
    },\n
\n
    hsv: function(h, s, v) {\n
        return this.hsva(h, s, v, 1.0);\n
    },\n
\n
    hsva: function(h, s, v, a) {\n
        h = ((number(h) % 360) / 360) * 360;\n
        s = number(s); v = number(v); a = number(a);\n
\n
        var i, f;\n
        i = Math.floor((h / 60) % 6);\n
        f = (h / 60) - i;\n
\n
        var vs = [v,\n
                  v * (1 - s),\n
                  v * (1 - f * s),\n
                  v * (1 - (1 - f) * s)];\n
        var perm = [[0, 3, 1],\n
                    [2, 0, 1],\n
                    [1, 0, 3],\n
                    [1, 2, 0],\n
                    [3, 1, 0],\n
                    [0, 1, 2]];\n
\n
        return this.rgba(vs[perm[i][0]] * 255,\n
                         vs[perm[i][1]] * 255,\n
                         vs[perm[i][2]] * 255,\n
                         a);\n
    },\n
\n
    hue: function (color) {\n
        return new(tree.Dimension)(Math.round(color.toHSL().h));\n
    },\n
    saturation: function (color) {\n
        return new(tree.Dimension)(Math.round(color.toHSL().s * 100), \'%\');\n
    },\n
    lightness: function (color) {\n
        return new(tree.Dimension)(Math.round(color.toHSL().l * 100), \'%\');\n
    },\n
    hsvhue: function(color) {\n
        return new(tree.Dimension)(Math.round(color.toHSV().h));\n
    },\n
    hsvsaturation: function (color) {\n
        return new(tree.Dimension)(Math.round(color.toHSV().s * 100), \'%\');\n
    },\n
    hsvvalue: function (color) {\n
        return new(tree.Dimension)(Math.round(color.toHSV().v * 100), \'%\');\n
    },\n
    red: function (color) {\n
        return new(tree.Dimension)(color.rgb[0]);\n
    },\n
    green: function (color) {\n
        return new(tree.Dimension)(color.rgb[1]);\n
    },\n
    blue: function (color) {\n
        return new(tree.Dimension)(color.rgb[2]);\n
    },\n
    alpha: function (color) {\n
        return new(tree.Dimension)(color.toHSL().a);\n
    },\n
    luma: function (color) {\n
        return new(tree.Dimension)(Math.round(color.luma() * color.alpha * 100), \'%\');\n
    },\n
    saturate: function (color, amount) {\n
        // filter: saturate(3.2);\n
        // should be kept as is, so check for color\n
        if (!color.rgb) {\n
            return null;\n
        }\n
        var hsl = color.toHSL();\n
\n
        hsl.s += amount.value / 100;\n
        hsl.s = clamp(hsl.s);\n
        return hsla(hsl);\n
    },\n
    desaturate: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.s -= amount.value / 100;\n
        hsl.s = clamp(hsl.s);\n
        return hsla(hsl);\n
    },\n
    lighten: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.l += amount.value / 100;\n
        hsl.l = clamp(hsl.l);\n
        return hsla(hsl);\n
    },\n
    darken: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.l -= amount.value / 100;\n
        hsl.l = clamp(hsl.l);\n
        return hsla(hsl);\n
    },\n
    fadein: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.a += amount.value / 100;\n
        hsl.a = clamp(hsl.a);\n
        return hsla(hsl);\n
    },\n
    fadeout: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.a -= amount.value / 100;\n
        hsl.a = clamp(hsl.a);\n
        return hsla(hsl);\n
    },\n
    fade: function (color, amount) {\n
        var hsl = color.toHSL();\n
\n
        hsl.a = amount.value / 100;\n
        hsl.a = clamp(hsl.a);\n
        return hsla(hsl);\n
    },\n
    spin: function (color, amount) {\n
        var hsl = color.toHSL();\n
        var hue = (hsl.h + amount.value) % 360;\n
\n
        hsl.h = hue < 0 ? 360 + hue : hue;\n
\n
        return hsla(hsl);\n
    },\n
    //\n
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein\n
    // http://sass-lang.com\n
    //\n
    mix: function (color1, color2, weight) {\n
        if (!weight) {\n
            weight = new(tree.Dimension)(50);\n
        }\n
        var p = weight.value / 100.0;\n
        var w = p * 2 - 1;\n
        var a = color1.toHSL().a - color2.toHSL().a;\n
\n
        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n
        var w2 = 1 - w1;\n
\n
        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n
                   color1.rgb[1] * w1 + color2.rgb[1] * w2,\n
                   color1.rgb[2] * w1 + color2.rgb[2] * w2];\n
\n
        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n
\n
        return new(tree.Color)(rgb, alpha);\n
    },\n
    greyscale: function (color) {\n
        return this.desaturate(color, new(tree.Dimension)(100));\n
    },\n
    contrast: function (color, dark, light, threshold) {\n
        // filter: contrast(3.2);\n
        // should be kept as is, so check for color\n
        if (!color.rgb) {\n
            return null;\n
        }\n
        if (typeof light === \'undefined\') {\n
            light = this.rgba(255, 255, 255, 1.0);\n
        }\n
        if (typeof dark === \'undefined\') {\n
            dark = this.rgba(0, 0, 0, 1.0);\n
        }\n
        //Figure out which is actually light and dark!\n
        if (dark.luma() > light.luma()) {\n
            var t = light;\n
            light = dark;\n
            dark = t;\n
        }\n
        if (typeof threshold === \'undefined\') {\n
            threshold = 0.43;\n
        } else {\n
            threshold = number(threshold);\n
        }\n
        if ((color.luma() * color.alpha) < threshold) {\n
            return light;\n
        } else {\n
            return dark;\n
        }\n
    },\n
    e: function (str) {\n
        return new(tree.Anonymous)(str instanceof tree.JavaScript ? str.evaluated : str);\n
    },\n
    escape: function (str) {\n
        return new(tree.Anonymous)(encodeURI(str.value).replace(/=/g, "%3D").replace(/:/g, "%3A").replace(/#/g, "%23").replace(/;/g, "%3B").replace(/\\(/g, "%28").replace(/\\)/g, "%29"));\n
    },\n
    \'%\': function (quoted /* arg, arg, ...*/) {\n
        var args = Array.prototype.slice.call(arguments, 1),\n
            str = quoted.value;\n
\n
        for (var i = 0; i < args.length; i++) {\n
            /*jshint loopfunc:true */\n
            str = str.replace(/%[sda]/i, function(token) {\n
                var value = token.match(/s/i) ? args[i].value : args[i].toCSS();\n
                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n
            });\n
        }\n
        str = str.replace(/%%/g, \'%\');\n
        return new(tree.Quoted)(\'"\' + str + \'"\', str);\n
    },\n
    unit: function (val, unit) {\n
        if(!(val instanceof tree.Dimension)) {\n
            throw { type: "Argument", message: "the first argument to unit must be a number" + (val instanceof tree.Operation ? ". Have you forgotten parenthesis?" : "") };\n
        }\n
        return new(tree.Dimension)(val.value, unit ? unit.toCSS() : "");\n
    },\n
    convert: function (val, unit) {\n
        return val.convertTo(unit.value);\n
    },\n
    round: function (n, f) {\n
        var fraction = typeof(f) === "undefined" ? 0 : f.value;\n
        return this._math(function(num) { return num.toFixed(fraction); }, null, n);\n
    },\n
    pi: function () {\n
        return new(tree.Dimension)(Math.PI);\n
    },\n
    mod: function(a, b) {\n
        return new(tree.Dimension)(a.value % b.value, a.unit);\n
    },\n
    pow: function(x, y) {\n
        if (typeof x === "number" && typeof y === "number") {\n
            x = new(tree.Dimension)(x);\n
            y = new(tree.Dimension)(y);\n
        } else if (!(x instanceof tree.Dimension) || !(y instanceof tree.Dimension)) {\n
            throw { type: "Argument", message: "arguments must be numbers" };\n
        }\n
\n
        return new(tree.Dimension)(Math.pow(x.value, y.value), x.unit);\n
    },\n
    _math: function (fn, unit, n) {\n
        if (n instanceof tree.Dimension) {\n
            /*jshint eqnull:true */\n
            return new(tree.Dimension)(fn(parseFloat(n.value)), unit == null ? n.unit : unit);\n
        } else if (typeof(n) === \'number\') {\n
            return fn(n);\n
        } else {\n
            throw { type: "Argument", message: "argument must be a number" };\n
        }\n
    },\n
    _minmax: function (isMin, args) {\n
        args = Array.prototype.slice.call(args);\n
        switch(args.length) {\n
        case 0: throw { type: "Argument", message: "one or more arguments required" };\n
        case 1: return args[0];\n
        }\n
        var i, j, current, currentUnified, referenceUnified, unit,\n
            order  = [], // elems only contains original argument values.\n
            values = {}; // key is the unit.toString() for unified tree.Dimension values,\n
                         // value is the index into the order array.\n
        for (i = 0; i < args.length; i++) {\n
            current = args[i];\n
            if (!(current instanceof tree.Dimension)) {\n
                order.push(current);\n
                continue;\n
            }\n
            currentUnified = current.unify();\n
            unit = currentUnified.unit.toString();\n
            j = values[unit];\n
            if (j === undefined) {\n
                values[unit] = order.length;\n
                order.push(current);\n
                continue;\n
            }\n
            referenceUnified = order[j].unify();\n
            if ( isMin && currentUnified.value < referenceUnified.value ||\n
                !isMin && currentUnified.value > referenceUnified.value) {\n
                order[j] = current;\n
            }\n
        }\n
        if (order.length == 1) {\n
            return order[0];\n
        }\n
        args = order.map(function (a) { return a.toCSS(this.env); })\n
                    .join(this.env.compress ? "," : ", ");\n
        return new(tree.Anonymous)((isMin ? "min" : "max") + "(" + args + ")");\n
    },\n
    min: function () {\n
        return this._minmax(true, arguments);\n
    },\n
    max: function () {\n
        return this._minmax(false, arguments);\n
    },\n
    argb: function (color) {\n
        return new(tree.Anonymous)(color.toARGB());\n
\n
    },\n
    percentage: function (n) {\n
        return new(tree.Dimension)(n.value * 100, \'%\');\n
    },\n
    color: function (n) {\n
        if (n instanceof tree.Quoted) {\n
            var colorCandidate = n.value,\n
                returnColor;\n
            returnColor = tree.Color.fromKeyword(colorCandidate);\n
            if (returnColor) {\n
                return returnColor;\n
            }\n
            if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/.test(colorCandidate)) {\n
                return new(tree.Color)(colorCandidate.slice(1));\n
            }\n
            throw { type: "Argument", message: "argument must be a color keyword or 3/6 digit hex e.g. #FFF" };\n
        } else {\n
            throw { type: "Argument", message: "argument must be a string" };\n
        }\n
    },\n
    iscolor: function (n) {\n
        return this._isa(n, tree.Color);\n
    },\n
    isnumber: function (n) {\n
        return this._isa(n, tree.Dimension);\n
    },\n
    isstring: function (n) {\n
        return this._isa(n, tree.Quoted);\n
    },\n
    iskeyword: function (n) {\n
        return this._isa(n, tree.Keyword);\n
    },\n
    isurl: function (n) {\n
        return this._isa(n, tree.URL);\n
    },\n
    ispixel: function (n) {\n
        return this.isunit(n, \'px\');\n
    },\n
    ispercentage: function (n) {\n
        return this.isunit(n, \'%\');\n
    },\n
    isem: function (n) {\n
        return this.isunit(n, \'em\');\n
    },\n
    isunit: function (n, unit) {\n
        return (n instanceof tree.Dimension) && n.unit.is(unit.value || unit) ? tree.True : tree.False;\n
    },\n
    _isa: function (n, Type) {\n
        return (n instanceof Type) ? tree.True : tree.False;\n
    },\n
    \n
    /* Blending modes */\n
    \n
    multiply: function(color1, color2) {\n
        var r = color1.rgb[0] * color2.rgb[0] / 255;\n
        var g = color1.rgb[1] * color2.rgb[1] / 255;\n
        var b = color1.rgb[2] * color2.rgb[2] / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    screen: function(color1, color2) {\n
        var r = 255 - (255 - color1.rgb[0]) * (255 - color2.rgb[0]) / 255;\n
        var g = 255 - (255 - color1.rgb[1]) * (255 - color2.rgb[1]) / 255;\n
        var b = 255 - (255 - color1.rgb[2]) * (255 - color2.rgb[2]) / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    overlay: function(color1, color2) {\n
        var r = color1.rgb[0] < 128 ? 2 * color1.rgb[0] * color2.rgb[0] / 255 : 255 - 2 * (255 - color1.rgb[0]) * (255 - color2.rgb[0]) / 255;\n
        var g = color1.rgb[1] < 128 ? 2 * color1.rgb[1] * color2.rgb[1] / 255 : 255 - 2 * (255 - color1.rgb[1]) * (255 - color2.rgb[1]) / 255;\n
        var b = color1.rgb[2] < 128 ? 2 * color1.rgb[2] * color2.rgb[2] / 255 : 255 - 2 * (255 - color1.rgb[2]) * (255 - color2.rgb[2]) / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    softlight: function(color1, color2) {\n
        var t = color2.rgb[0] * color1.rgb[0] / 255;\n
        var r = t + color1.rgb[0] * (255 - (255 - color1.rgb[0]) * (255 - color2.rgb[0]) / 255 - t) / 255;\n
        t = color2.rgb[1] * color1.rgb[1] / 255;\n
        var g = t + color1.rgb[1] * (255 - (255 - color1.rgb[1]) * (255 - color2.rgb[1]) / 255 - t) / 255;\n
        t = color2.rgb[2] * color1.rgb[2] / 255;\n
        var b = t + color1.rgb[2] * (255 - (255 - color1.rgb[2]) * (255 - color2.rgb[2]) / 255 - t) / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    hardlight: function(color1, color2) {\n
        var r = color2.rgb[0] < 128 ? 2 * color2.rgb[0] * color1.rgb[0] / 255 : 255 - 2 * (255 - color2.rgb[0]) * (255 - color1.rgb[0]) / 255;\n
        var g = color2.rgb[1] < 128 ? 2 * color2.rgb[1] * color1.rgb[1] / 255 : 255 - 2 * (255 - color2.rgb[1]) * (255 - color1.rgb[1]) / 255;\n
        var b = color2.rgb[2] < 128 ? 2 * color2.rgb[2] * color1.rgb[2] / 255 : 255 - 2 * (255 - color2.rgb[2]) * (255 - color1.rgb[2]) / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    difference: function(color1, color2) {\n
        var r = Math.abs(color1.rgb[0] - color2.rgb[0]);\n
        var g = Math.abs(color1.rgb[1] - color2.rgb[1]);\n
        var b = Math.abs(color1.rgb[2] - color2.rgb[2]);\n
        return this.rgb(r, g, b);\n
    },\n
    exclusion: function(color1, color2) {\n
        var r = color1.rgb[0] + color2.rgb[0] * (255 - color1.rgb[0] - color1.rgb[0]) / 255;\n
        var g = color1.rgb[1] + color2.rgb[1] * (255 - color1.rgb[1] - color1.rgb[1]) / 255;\n
        var b = color1.rgb[2] + color2.rgb[2] * (255 - color1.rgb[2] - color1.rgb[2]) / 255;\n
        return this.rgb(r, g, b);\n
    },\n
    average: function(color1, color2) {\n
        var r = (color1.rgb[0] + color2.rgb[0]) / 2;\n
        var g = (color1.rgb[1] + color2.rgb[1]) / 2;\n
        var b = (color1.rgb[2] + color2.rgb[2]) / 2;\n
        return this.rgb(r, g, b);\n
    },\n
    negation: function(color1, color2) {\n
        var r = 255 - Math.abs(255 - color2.rgb[0] - color1.rgb[0]);\n
        var g = 255 - Math.abs(255 - color2.rgb[1] - color1.rgb[1]);\n
        var b = 255 - Math.abs(255 - color2.rgb[2] - color1.rgb[2]);\n
        return this.rgb(r, g, b);\n
    },\n
    tint: function(color, amount) {\n
        return this.mix(this.rgb(255,255,255), color, amount);\n
    },\n
    shade: function(color, amount) {\n
        return this.mix(this.rgb(0, 0, 0), color, amount);\n
    },   \n
    extract: function(values, index) {\n
        index = index.value - 1; // (1-based index)       \n
        // handle non-array values as an array of length 1\n
        // return \'undefined\' if index is invalid\n
        return Array.isArray(values.value) \n
            ? values.value[index] : Array(values)[index];\n
    },\n
    length: function(values) {\n
        var n = Array.isArray(values.value) ? values.value.length : 1;\n
        return new tree.Dimension(n);\n
    },\n
\n
    "data-uri": function(mimetypeNode, filePathNode) {\n
\n
        if (typeof window !== \'undefined\') {\n
            return new tree.URL(filePathNode || mimetypeNode, this.currentFileInfo).eval(this.env);\n
        }\n
\n
        var mimetype = mimetypeNode.value;\n
        var filePath = (filePathNode && filePathNode.value);\n
\n
        var fs = require("fs"),\n
            path = require("path"),\n
            useBase64 = false;\n
\n
        if (arguments.length < 2) {\n
            filePath = mimetype;\n
        }\n
\n
        if (this.env.isPathRelative(filePath)) {\n
            if (this.currentFileInfo.relativeUrls) {\n
                filePath = path.join(this.currentFileInfo.currentDirectory, filePath);\n
            } else {\n
                filePath = path.join(this.currentFileInfo.entryPath, filePath);\n
            }\n
        }\n
\n
        // detect the mimetype if not given\n
        if (arguments.length < 2) {\n
            var mime;\n
            try {\n
                mime = require(\'mime\');\n
            } catch (ex) {\n
                mime = tree._mime;\n
            }\n
\n
            mimetype = mime.lookup(filePath);\n
\n
            // use base 64 unless it\'s an ASCII or UTF-8 format\n
            var charset = mime.charsets.lookup(mimetype);\n
            useBase64 = [\'US-ASCII\', \'UTF-8\'].indexOf(charset) < 0;\n
            if (useBase64) { mimetype += \';base64\'; }\n
        }\n
        else {\n
            useBase64 = /;base64$/.test(mimetype);\n
        }\n
\n
        var buf = fs.readFileSync(filePath);\n
\n
        // IE8 cannot handle a data-uri larger than 32KB. If this is exceeded\n
        // and the --ieCompat flag is enabled, return a normal url() instead.\n
        var DATA_URI_MAX_KB = 32,\n
            fileSizeInKB = parseInt((buf.length / 1024), 10);\n
        if (fileSizeInKB >= DATA_URI_MAX_KB) {\n
\n
            if (this.env.ieCompat !== false) {\n
                if (!this.env.silent) {\n
                    console.warn("Skipped data-uri embedding of %s because its size (%dKB) exceeds IE8-safe %dKB!", filePath, fileSizeInKB, DATA_URI_MAX_KB);\n
                }\n
\n
                return new tree.URL(filePathNode || mimetypeNode, this.currentFileInfo).eval(this.env);\n
            }\n
        }\n
\n
        buf = useBase64 ? buf.toString(\'base64\')\n
                        : encodeURIComponent(buf);\n
\n
        var uri = "\'data:" + mimetype + \',\' + buf + "\'";\n
        return new(tree.URL)(new(tree.Anonymous)(uri));\n
    },\n
\n
    "svg-gradient": function(direction) {\n
\n
        function throwArgumentDescriptor() {\n
            throw { type: "Argument", message: "svg-gradient expects direction, start_color [start_position], [color position,]..., end_color [end_position]" };\n
        }\n
\n
        if (arguments.length < 3) {\n
            throwArgumentDescriptor();\n
        }\n
        var stops = Array.prototype.slice.call(arguments, 1),\n
            gradientDirectionSvg,\n
            gradientType = "linear",\n
            rectangleDimension = \'x="0" y="0" width="1" height="1"\',\n
            useBase64 = true,\n
            renderEnv = {compress: false},\n
            returner,\n
            directionValue = direction.toCSS(renderEnv),\n
            i, color, position, positionValue, alpha;\n
\n
        switch (directionValue) {\n
            case "to bottom":\n
                gradientDirectionSvg = \'x1="0%" y1="0%" x2="0%" y2="100%"\';\n
                break;\n
            case "to right":\n
                gradientDirectionSvg = \'x1="0%" y1="0%" x2="100%" y2="0%"\';\n
                break;\n
            case "to bottom right":\n
                gradientDirectionSvg = \'x1="0%" y1="0%" x2="100%" y2="100%"\';\n
                break;\n
            case "to top right":\n
                gradientDirectionSvg = \'x1="0%" y1="100%" x2="100%" y2="0%"\';\n
                break;\n
            case "ellipse":\n
            case "ellipse at center":\n
                gradientType = "radial";\n
                gradientDirectionSvg = \'cx="50%" cy="50%" r="75%"\';\n
                rectangleDimension = \'x="-50" y="-50" width="101" height="101"\';\n
                break;\n
            default:\n
                throw { type: "Argument", message: "svg-gradient direction must be \'to bottom\', \'to right\', \'to bottom right\', \'to top right\' or \'ellipse at center\'" };\n
        }\n
        returner = \'<?xml version="1.0" ?>\' +\n
            \'<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none">\' +\n
            \'<\' + gradientType + \'Gradient id="gradient" gradientUnits="userSpaceOnUse" \' + gradientDirectionSvg + \'>\';\n
\n
        for (i = 0; i < stops.length; i+= 1) {\n
            if (stops[i].value) {\n
                color = stops[i].value[0];\n
                position = stops[i].value[1];\n
            } else {\n
                color = stops[i];\n
                position = undefined;\n
            }\n
\n
            if (!(color instanceof tree.Color) || (!((i === 0 || i+1 === stops.length) && position === undefined) && !(position instanceof tree.Dimension))) {\n
                throwArgumentDescriptor();\n
            }\n
            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? "0%" : "100%";\n
            alpha = color.alpha;\n
            returner += \'<stop offset="\' + positionValue + \'" stop-color="\' + color.toRGB() + \'"\' + (alpha < 1 ? \' stop-opacity="\' + alpha + \'"\' : \'\') + \'/>\';\n
        }\n
        returner += \'</\' + gradientType + \'Gradient>\' +\n
                    \'<rect \' + rectangleDimension + \' fill="url(#gradient)" /></svg>\';\n
\n
        if (useBase64) {\n
            // only works in node, needs interface to what is supported in environment\n
            try {\n
                returner = new Buffer(returner).toString(\'base64\');\n
            } catch(e) {\n
                useBase64 = false;\n
            }\n
        }\n
\n
        returner = "\'data:image/svg+xml" + (useBase64 ? ";base64" : "") + "," + returner + "\'";\n
        return new(tree.URL)(new(tree.Anonymous)(returner));\n
    }\n
};\n
\n
// these static methods are used as a fallback when the optional \'mime\' dependency is missing\n
tree._mime = {\n
    // this map is intentionally incomplete\n
    // if you want more, install \'mime\' dep\n
    _types: {\n
        \'.htm\' : \'text/html\',\n
        \'.html\': \'text/html\',\n
        \'.gif\' : \'image/gif\',\n
        \'.jpg\' : \'image/jpeg\',\n
        \'.jpeg\': \'image/jpeg\',\n
        \'.png\' : \'image/png\'\n
    },\n
    lookup: function (filepath) {\n
        var ext = require(\'path\').extname(filepath),\n
            type = tree._mime._types[ext];\n
        if (type === undefined) {\n
            throw new Error(\'Optional dependency "mime" is required for \' + ext);\n
        }\n
        return type;\n
    },\n
    charsets: {\n
        lookup: function (type) {\n
            // assumes all text types are UTF-8\n
            return type && (/^text\\//).test(type) ? \'UTF-8\' : \'\';\n
        }\n
    }\n
};\n
\n
var mathFunctions = [{name:"ceil"}, {name:"floor"}, {name: "sqrt"}, {name:"abs"},\n
        {name:"tan", unit: ""}, {name:"sin", unit: ""}, {name:"cos", unit: ""},\n
        {name:"atan", unit: "rad"}, {name:"asin", unit: "rad"}, {name:"acos", unit: "rad"}],\n
    createMathFunction = function(name, unit) {\n
        return function(n) {\n
            /*jshint eqnull:true */\n
            if (unit != null) {\n
                n = n.unify();\n
            }\n
            return this._math(Math[name], unit, n);\n
        };\n
    };\n
\n
for(var i = 0; i < mathFunctions.length; i++) {\n
    tree.functions[mathFunctions[i].name] = createMathFunction(mathFunctions[i].name, mathFunctions[i].unit);\n
}\n
\n
function hsla(color) {\n
    return tree.functions.hsla(color.h, color.s, color.l, color.a);\n
}\n
\n
function scaled(n, size) {\n
    if (n instanceof tree.Dimension && n.unit.is(\'%\')) {\n
        return parseFloat(n.value * size / 100);\n
    } else {\n
        return number(n);\n
    }\n
}\n
\n
function number(n) {\n
    if (n instanceof tree.Dimension) {\n
        return parseFloat(n.unit.is(\'%\') ? n.value / 100 : n.value);\n
    } else if (typeof(n) === \'number\') {\n
        return n;\n
    } else {\n
        throw {\n
            error: "RuntimeError",\n
            message: "color functions take numbers as parameters"\n
        };\n
    }\n
}\n
\n
function clamp(val) {\n
    return Math.min(1, Math.max(0, val));\n
}\n
\n
tree.functionCall = function(env, currentFileInfo) {\n
    this.env = env;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
\n
tree.functionCall.prototype = tree.functions;\n
\n
})(require(\'./tree\'));\n
\n
(function (tree) {\n
    tree.colors = {\n
        \'aliceblue\':\'#f0f8ff\',\n
        \'antiquewhite\':\'#faebd7\',\n
        \'aqua\':\'#00ffff\',\n
        \'aquamarine\':\'#7fffd4\',\n
        \'azure\':\'#f0ffff\',\n
        \'beige\':\'#f5f5dc\',\n
        \'bisque\':\'#ffe4c4\',\n
        \'black\':\'#000000\',\n
        \'blanchedalmond\':\'#ffebcd\',\n
        \'blue\':\'#0000ff\',\n
        \'blueviolet\':\'#8a2be2\',\n
        \'brown\':\'#a52a2a\',\n
        \'burlywood\':\'#deb887\',\n
        \'cadetblue\':\'#5f9ea0\',\n
        \'chartreuse\':\'#7fff00\',\n
        \'chocolate\':\'#d2691e\',\n
        \'coral\':\'#ff7f50\',\n
        \'cornflowerblue\':\'#6495ed\',\n
        \'cornsilk\':\'#fff8dc\',\n
        \'crimson\':\'#dc143c\',\n
        \'cyan\':\'#00ffff\',\n
        \'darkblue\':\'#00008b\',\n
        \'darkcyan\':\'#008b8b\',\n
        \'darkgoldenrod\':\'#b8860b\',\n
        \'darkgray\':\'#a9a9a9\',\n
        \'darkgrey\':\'#a9a9a9\',\n
        \'darkgreen\':\'#006400\',\n
        \'darkkhaki\':\'#bdb76b\',\n
        \'darkmagenta\':\'#8b008b\',\n
        \'darkolivegreen\':\'#556b2f\',\n
        \'darkorange\':\'#ff8c00\',\n
        \'darkorchid\':\'#9932cc\',\n
        \'darkred\':\'#8b0000\',\n
        \'darksalmon\':\'#e9967a\',\n
        \'darkseagreen\':\'#8fbc8f\',\n
        \'darkslateblue\':\'#483d8b\',\n
        \'darkslategray\':\'#2f4f4f\',\n
        \'darkslategrey\':\'#2f4f4f\',\n
        \'darkturquoise\':\'#00ced1\',\n
        \'darkviolet\':\'#9400d3\',\n
        \'deeppink\':\'#ff1493\',\n
        \'deepskyblue\':\'#00bfff\',\n
        \'dimgray\':\'#696969\',\n
        \'dimgrey\':\'#696969\',\n
        \'dodgerblue\':\'#1e90ff\',\n
        \'firebrick\':\'#b22222\',\n
        \'floralwhite\':\'#fffaf0\',\n
        \'forestgreen\':\'#228b22\',\n
        \'fuchsia\':\'#ff00ff\',\n
        \'gainsboro\':\'#dcdcdc\',\n
        \'ghostwhite\':\'#f8f8ff\',\n
        \'gold\':\'#ffd700\',\n
        \'goldenrod\':\'#daa520\',\n
        \'gray\':\'#808080\',\n
        \'grey\':\'#808080\',\n
        \'green\':\'#008000\',\n
        \'greenyellow\':\'#adff2f\',\n
        \'honeydew\':\'#f0fff0\',\n
        \'hotpink\':\'#ff69b4\',\n
        \'indianred\':\'#cd5c5c\',\n
        \'indigo\':\'#4b0082\',\n
        \'ivory\':\'#fffff0\',\n
        \'khaki\':\'#f0e68c\',\n
        \'lavender\':\'#e6e6fa\',\n
        \'lavenderblush\':\'#fff0f5\',\n
        \'lawngreen\':\'#7cfc00\',\n
        \'lemonchiffon\':\'#fffacd\',\n
        \'lightblue\':\'#add8e6\',\n
        \'lightcoral\':\'#f08080\',\n
        \'lightcyan\':\'#e0ffff\',\n
        \'lightgoldenrodyellow\':\'#fafad2\',\n
        \'lightgray\':\'#d3d3d3\',\n
        \'lightgrey\':\'#d3d3d3\',\n
        \'lightgreen\':\'#90ee90\',\n
        \'lightpink\':\'#ffb6c1\',\n
        \'lightsalmon\':\'#ffa07a\',\n
        \'lightseagreen\':\'#20b2aa\',\n
        \'lightskyblue\':\'#87cefa\',\n
        \'lightslategray\':\'#778899\',\n
        \'lightslategrey\':\'#778899\',\n
        \'lightsteelblue\':\'#b0c4de\',\n
        \'lightyellow\':\'#ffffe0\',\n
        \'lime\':\'#00ff00\',\n
        \'limegreen\':\'#32cd32\',\n
        \'linen\':\'#faf0e6\',\n
        \'magenta\':\'#ff00ff\',\n
        \'maroon\':\'#800000\',\n
        \'mediumaquamarine\':\'#66cdaa\',\n
        \'mediumblue\':\'#0000cd\',\n
        \'mediumorchid\':\'#ba55d3\',\n
        \'mediumpurple\':\'#9370d8\',\n
        \'mediumseagreen\':\'#3cb371\',\n
        \'mediumslateblue\':\'#7b68ee\',\n
        \'mediumspringgreen\':\'#00fa9a\',\n
        \'mediumturquoise\':\'#48d1cc\',\n
        \'mediumvioletred\':\'#c71585\',\n
        \'midnightblue\':\'#191970\',\n
        \'mintcream\':\'#f5fffa\',\n
        \'mistyrose\':\'#ffe4e1\',\n
        \'moccasin\':\'#ffe4b5\',\n
        \'navajowhite\':\'#ffdead\',\n
        \'navy\':\'#000080\',\n
        \'oldlace\':\'#fdf5e6\',\n
        \'olive\':\'#808000\',\n
        \'olivedrab\':\'#6b8e23\',\n
        \'orange\':\'#ffa500\',\n
        \'orangered\':\'#ff4500\',\n
        \'orchid\':\'#da70d6\',\n
        \'palegoldenrod\':\'#eee8aa\',\n
        \'palegreen\':\'#98fb98\',\n
        \'paleturquoise\':\'#afeeee\',\n
        \'palevioletred\':\'#d87093\',\n
        \'papayawhip\':\'#ffefd5\',\n
        \'peachpuff\':\'#ffdab9\',\n
        \'peru\':\'#cd853f\',\n
        \'pink\':\'#ffc0cb\',\n
        \'plum\':\'#dda0dd\',\n
        \'powderblue\':\'#b0e0e6\',\n
        \'purple\':\'#800080\',\n
        \'red\':\'#ff0000\',\n
        \'rosybrown\':\'#bc8f8f\',\n
        \'royalblue\':\'#4169e1\',\n
        \'saddlebrown\':\'#8b4513\',\n
        \'salmon\':\'#fa8072\',\n
        \'sandybrown\':\'#f4a460\',\n
        \'seagreen\':\'#2e8b57\',\n
        \'seashell\':\'#fff5ee\',\n
        \'sienna\':\'#a0522d\',\n
        \'silver\':\'#c0c0c0\',\n
        \'skyblue\':\'#87ceeb\',\n
        \'slateblue\':\'#6a5acd\',\n
        \'slategray\':\'#708090\',\n
        \'slategrey\':\'#708090\',\n
        \'snow\':\'#fffafa\',\n
        \'springgreen\':\'#00ff7f\',\n
        \'steelblue\':\'#4682b4\',\n
        \'tan\':\'#d2b48c\',\n
        \'teal\':\'#008080\',\n
        \'thistle\':\'#d8bfd8\',\n
        \'tomato\':\'#ff6347\',\n
        \'turquoise\':\'#40e0d0\',\n
        \'violet\':\'#ee82ee\',\n
        \'wheat\':\'#f5deb3\',\n
        \'white\':\'#ffffff\',\n
        \'whitesmoke\':\'#f5f5f5\',\n
        \'yellow\':\'#ffff00\',\n
        \'yellowgreen\':\'#9acd32\'\n
    };\n
})(require(\'./tree\'));\n
\n
(function (tree) {\n
\n
tree.debugInfo = function(env, ctx, lineSeperator) {\n
    var result="";\n
    if (env.dumpLineNumbers && !env.compress) {\n
        switch(env.dumpLineNumbers) {\n
            case \'comments\':\n
                result = tree.debugInfo.asComment(ctx);\n
                break;\n
            case \'mediaquery\':\n
                result = tree.debugInfo.asMediaQuery(ctx);\n
                break;\n
            case \'all\':\n
                result = tree.debugInfo.asComment(ctx) + (lineSeperator || "") + tree.debugInfo.asMediaQuery(ctx);\n
                break;\n
        }\n
    }\n
    return result;\n
};\n
\n
tree.debugInfo.asComment = function(ctx) {\n
    return \'/* line \' + ctx.debugInfo.lineNumber + \', \' + ctx.debugInfo.fileName + \' */\\n\';\n
};\n
\n
tree.debugInfo.asMediaQuery = function(ctx) {\n
    return \'@media -sass-debug-info{filename{font-family:\' +\n
        (\'file://\' + ctx.debugInfo.fileName).replace(/([.:/\\\\])/g, function (a) {\n
            if (a == \'\\\\\') {\n
                a = \'\\/\';\n
            }\n
            return \'\\\\\' + a;\n
        }) +\n
        \'}line{font-family:\\\\00003\' + ctx.debugInfo.lineNumber + \'}}\\n\';\n
};\n
\n
tree.find = function (obj, fun) {\n
    for (var i = 0, r; i < obj.length; i++) {\n
        if (r = fun.call(obj, obj[i])) { return r; }\n
    }\n
    return null;\n
};\n
\n
tree.jsify = function (obj) {\n
    if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n
        return \'[\' + obj.value.map(function (v) { return v.toCSS(false); }).join(\', \') + \']\';\n
    } else {\n
        return obj.toCSS(false);\n
    }\n
};\n
\n
tree.toCSS = function (env) {\n
    var strs = [];\n
    this.genCSS(env, {\n
        add: function(chunk, fileInfo, index) {\n
            strs.push(chunk);\n
        },\n
        isEmpty: function () {\n
            return strs.length === 0;\n
        }\n
    });\n
    return strs.join(\'\');\n
};\n
\n
tree.outputRuleset = function (env, output, rules) {\n
    output.add((env.compress ? \'{\' : \' {\\n\'));\n
    env.tabLevel = (env.tabLevel || 0) + 1;\n
    var tabRuleStr = env.compress ? \'\' : Array(env.tabLevel + 1).join("  "),\n
        tabSetStr = env.compress ? \'\' : Array(env.tabLevel).join("  ");\n
    for(var i = 0; i < rules.length; i++) {\n
        output.add(tabRuleStr);\n
        rules[i].genCSS(env, output);\n
        output.add(env.compress ? \'\' : \'\\n\');\n
    }\n
    env.tabLevel--;\n
    output.add(tabSetStr + "}");\n
};\n
\n
})(require(\'./tree\'));\n
\n
(function (tree) {\n
\n
tree.Alpha = function (val) {\n
    this.value = val;\n
};\n
tree.Alpha.prototype = {\n
    type: "Alpha",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        if (this.value.eval) { return new tree.Alpha(this.value.eval(env)); }\n
        return this;\n
    },\n
    genCSS: function (env, output) {\n
        output.add("alpha(opacity=");\n
\n
        if (this.value.genCSS) {\n
            this.value.genCSS(env, output);\n
        } else {\n
            output.add(this.value);\n
        }\n
\n
        output.add(")");\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Anonymous = function (string, index, currentFileInfo, mapLines) {\n
    this.value = string.value || string;\n
    this.index = index;\n
    this.mapLines = mapLines;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Anonymous.prototype = {\n
    type: "Anonymous",\n
    eval: function () { return this; },\n
    compare: function (x) {\n
        if (!x.toCSS) {\n
            return -1;\n
        }\n
        \n
        var left = this.toCSS(),\n
            right = x.toCSS();\n
        \n
        if (left === right) {\n
            return 0;\n
        }\n
        \n
        return left < right ? -1 : 1;\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.value, this.currentFileInfo, this.index, this.mapLines);\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Assignment = function (key, val) {\n
    this.key = key;\n
    this.value = val;\n
};\n
tree.Assignment.prototype = {\n
    type: "Assignment",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        if (this.value.eval) {\n
            return new(tree.Assignment)(this.key, this.value.eval(env));\n
        }\n
        return this;\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.key + \'=\');\n
        if (this.value.genCSS) {\n
            this.value.genCSS(env, output);\n
        } else {\n
            output.add(this.value);\n
        }\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
//\n
// A function call node.\n
//\n
tree.Call = function (name, args, index, currentFileInfo) {\n
    this.name = name;\n
    this.args = args;\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Call.prototype = {\n
    type: "Call",\n
    accept: function (visitor) {\n
        this.args = visitor.visit(this.args);\n
    },\n
    //\n
    // When evaluating a function call,\n
    // we either find the function in `tree.functions` [1],\n
    // in which case we call it, passing the  evaluated arguments,\n
    // if this returns null or we cannot find the function, we \n
    // simply print it out as it appeared originally [2].\n
    //\n
    // The *functions.js* file contains the built-in functions.\n
    //\n
    // The reason why we evaluate the arguments, is in the case where\n
    // we try to pass a variable to a function, like: `saturate(@color)`.\n
    // The function should receive the value, not the variable.\n
    //\n
    eval: function (env) {\n
        var args = this.args.map(function (a) { return a.eval(env); }),\n
            nameLC = this.name.toLowerCase(),\n
            result, func;\n
\n
        if (nameLC in tree.functions) { // 1.\n
            try {\n
                func = new tree.functionCall(env, this.currentFileInfo);\n
                result = func[nameLC].apply(func, args);\n
                /*jshint eqnull:true */\n
                if (result != null) {\n
                    return result;\n
                }\n
            } catch (e) {\n
                throw { type: e.type || "Runtime",\n
                        message: "error evaluating function `" + this.name + "`" +\n
                                 (e.message ? \': \' + e.message : \'\'),\n
                        index: this.index, filename: this.currentFileInfo.filename };\n
            }\n
        }\n
\n
        return new tree.Call(this.name, args, this.index, this.currentFileInfo);\n
    },\n
\n
    genCSS: function (env, output) {\n
        output.add(this.name + "(", this.currentFileInfo, this.index);\n
\n
        for(var i = 0; i < this.args.length; i++) {\n
            this.args[i].genCSS(env, output);\n
            if (i + 1 < this.args.length) {\n
                output.add(", ");\n
            }\n
        }\n
\n
        output.add(")");\n
    },\n
\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
//\n
// RGB Colors - #ff0014, #eee\n
//\n
tree.Color = function (rgb, a) {\n
    //\n
    // The end goal here, is to parse the arguments\n
    // into an integer triplet, such as `128, 255, 0`\n
    //\n
    // This facilitates operations and conversions.\n
    //\n
    if (Array.isArray(rgb)) {\n
        this.rgb = rgb;\n
    } else if (rgb.length == 6) {\n
        this.rgb = rgb.match(/.{2}/g).map(function (c) {\n
            return parseInt(c, 16);\n
        });\n
    } else {\n
        this.rgb = rgb.split(\'\').map(function (c) {\n
            return parseInt(c + c, 16);\n
        });\n
    }\n
    this.alpha = typeof(a) === \'number\' ? a : 1;\n
};\n
\n
var transparentKeyword = "transparent";\n
\n
tree.Color.prototype = {\n
    type: "Color",\n
    eval: function () { return this; },\n
    luma: function () { return (0.2126 * this.rgb[0] / 255) + (0.7152 * this.rgb[1] / 255) + (0.0722 * this.rgb[2] / 255); },\n
\n
    genCSS: function (env, output) {\n
        output.add(this.toCSS(env));\n
    },\n
    toCSS: function (env, doNotCompress) {\n
        var compress = env && env.compress && !doNotCompress;\n
\n
        // If we have some transparency, the only way to represent it\n
        // is via `rgba`. Otherwise, we use the hex representation,\n
        // which has better compatibility with older browsers.\n
        // Values are capped between `0` and `255`, rounded and zero-padded.\n
        if (this.alpha < 1.0) {\n
            if (this.alpha === 0 && this.isTransparentKeyword) {\n
                return transparentKeyword;\n
            }\n
            return "rgba(" + this.rgb.map(function (c) {\n
                return Math.round(c);\n
            }).concat(this.alpha).join(\',\' + (compress ? \'\' : \' \')) + ")";\n
        } else {\n
            var color = this.toRGB();\n
\n
            if (compress) {\n
                var splitcolor = color.split(\'\');\n
\n
                // Convert color to short format\n
                if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n
                    color = \'#\' + splitcolor[1] + splitcolor[3] + splitcolor[5];\n
                }\n
            }\n
\n
            return color;\n
        }\n
    },\n
\n
    //\n
    // Operations have to be done per-channel, if not,\n
    // channels will spill onto each other. Once we have\n
    // our result, in the form of an integer triplet,\n
    // we create a new Color node to hold the result.\n
    //\n
    operate: function (env, op, other) {\n
        var result = [];\n
\n
        if (! (other instanceof tree.Color)) {\n
            other = other.toColor();\n
        }\n
\n
        for (var c = 0; c < 3; c++) {\n
            result[c] = tree.operate(env, op, this.rgb[c], other.rgb[c]);\n
        }\n
        return new(tree.Color)(result, this.alpha + other.alpha);\n
    },\n
\n
    toRGB: function () {\n
        return \'#\' + this.rgb.map(function (i) {\n
            i = Math.round(i);\n
            i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n
            return i.length === 1 ? \'0\' + i : i;\n
        }).join(\'\');\n
    },\n
\n
    toHSL: function () {\n
        var r = this.rgb[0] / 255,\n
            g = this.rgb[1] / 255,\n
            b = this.rgb[2] / 255,\n
            a = this.alpha;\n
\n
        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n
        var h, s, l = (max + min) / 2, d = max - min;\n
\n
        if (max === min) {\n
            h = s = 0;\n
        } else {\n
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n
\n
            switch (max) {\n
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n
                case g: h = (b - r) / d + 2;               break;\n
                case b: h = (r - g) / d + 4;               break;\n
            }\n
            h /= 6;\n
        }\n
        return { h: h * 360, s: s, l: l, a: a };\n
    },\n
    //Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n
    toHSV: function () {\n
        var r = this.rgb[0] / 255,\n
            g = this.rgb[1] / 255,\n
            b = this.rgb[2] / 255,\n
            a = this.alpha;\n
\n
        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n
        var h, s, v = max;\n
\n
        var d = max - min;\n
        if (max === 0) {\n
            s = 0;\n
        } else {\n
            s = d / max;\n
        }\n
\n
        if (max === min) {\n
            h = 0;\n
        } else {\n
            switch(max){\n
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n
                case g: h = (b - r) / d + 2; break;\n
                case b: h = (r - g) / d + 4; break;\n
            }\n
            h /= 6;\n
        }\n
        return { h: h * 360, s: s, v: v, a: a };\n
    },\n
    toARGB: function () {\n
        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n
        return \'#\' + argb.map(function (i) {\n
            i = Math.round(i);\n
            i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n
            return i.length === 1 ? \'0\' + i : i;\n
        }).join(\'\');\n
    },\n
    compare: function (x) {\n
        if (!x.rgb) {\n
            return -1;\n
        }\n
        \n
        return (x.rgb[0] === this.rgb[0] &&\n
            x.rgb[1] === this.rgb[1] &&\n
            x.rgb[2] === this.rgb[2] &&\n
            x.alpha === this.alpha) ? 0 : -1;\n
    }\n
};\n
\n
tree.Color.fromKeyword = function(keyword) {\n
    if (tree.colors.hasOwnProperty(keyword)) {\n
        // detect named color\n
        return new(tree.Color)(tree.colors[keyword].slice(1));\n
    }\n
    if (keyword === transparentKeyword) {\n
        var transparent = new(tree.Color)([0, 0, 0], 0);\n
        transparent.isTransparentKeyword = true;\n
        return transparent;\n
    }\n
};\n
\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Comment = function (value, silent, index, currentFileInfo) {\n
    this.value = value;\n
    this.silent = !!silent;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Comment.prototype = {\n
    type: "Comment",\n
    genCSS: function (env, output) {\n
        if (this.debugInfo) {\n
            output.add(tree.debugInfo(env, this), this.currentFileInfo, this.index);\n
        }\n
        output.add(this.value.trim()); //TODO shouldn\'t need to trim, we shouldn\'t grab the \\n\n
    },\n
    toCSS: tree.toCSS,\n
    isSilent: function(env) {\n
        var isReference = (this.currentFileInfo && this.currentFileInfo.reference && !this.isReferenced),\n
            isCompressed = env.compress && !this.value.match(/^\\/\\*!/);\n
        return this.silent || isReference || isCompressed;\n
    },\n
    eval: function () { return this; },\n
    markReferenced: function () {\n
        this.isReferenced = true;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Condition = function (op, l, r, i, negate) {\n
    this.op = op.trim();\n
    this.lvalue = l;\n
    this.rvalue = r;\n
    this.index = i;\n
    this.negate = negate;\n
};\n
tree.Condition.prototype = {\n
    type: "Condition",\n
    accept: function (visitor) {\n
        this.lvalue = visitor.visit(this.lvalue);\n
        this.rvalue = visitor.visit(this.rvalue);\n
    },\n
    eval: function (env) {\n
        var a = this.lvalue.eval(env),\n
            b = this.rvalue.eval(env);\n
\n
        var i = this.index, result;\n
\n
        result = (function (op) {\n
            switch (op) {\n
                case \'and\':\n
                    return a && b;\n
                case \'or\':\n
                    return a || b;\n
                default:\n
                    if (a.compare) {\n
                        result = a.compare(b);\n
                    } else if (b.compare) {\n
                        result = b.compare(a);\n
                    } else {\n
                        throw { type: "Type",\n
                                message: "Unable to perform comparison",\n
                                index: i };\n
                    }\n
                    switch (result) {\n
                        case -1: return op === \'<\' || op === \'=<\' || op === \'<=\';\n
                        case  0: return op === \'=\' || op === \'>=\' || op === \'=<\' || op === \'<=\';\n
                        case  1: return op === \'>\' || op === \'>=\';\n
                    }\n
            }\n
        })(this.op);\n
        return this.negate ? !result : result;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
//\n
// A number with a unit\n
//\n
tree.Dimension = function (value, unit) {\n
    this.value = parseFloat(value);\n
    this.unit = (unit && unit instanceof tree.Unit) ? unit :\n
      new(tree.Unit)(unit ? [unit] : undefined);\n
};\n
\n
tree.Dimension.prototype = {\n
    type: "Dimension",\n
    accept: function (visitor) {\n
        this.unit = visitor.visit(this.unit);\n
    },\n
    eval: function (env) {\n
        return this;\n
    },\n
    toColor: function () {\n
        return new(tree.Color)([this.value, this.value, this.value]);\n
    },\n
    genCSS: function (env, output) {\n
        if ((env && env.strictUnits) && !this.unit.isSingular()) {\n
            throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: "+this.unit.toString());\n
        }\n
\n
        var value = this.value,\n
            strValue = String(value);\n
\n
        if (value !== 0 && value < 0.000001 && value > -0.000001) {\n
            // would be output 1e-6 etc.\n
            strValue = value.toFixed(20).replace(/0+$/, "");\n
        }\n
\n
        if (env && env.compress) {\n
            // Zero values doesn\'t need a unit\n
            if (value === 0 && this.unit.isLength()) {\n
                output.add(strValue);\n
                return;\n
            }\n
\n
            // Float values doesn\'t need a leading zero\n
            if (value > 0 && value < 1) {\n
                strValue = (strValue).substr(1);\n
            }\n
        }\n
\n
        output.add(strValue);\n
        this.unit.genCSS(env, output);\n
    },\n
    toCSS: tree.toCSS,\n
\n
    // In an operation between two Dimensions,\n
    // we default to the first Dimension\'s unit,\n
    // so `1px + 2` will yield `3px`.\n
    operate: function (env, op, other) {\n
        /*jshint noempty:false */\n
        var value = tree.operate(env, op, this.value, other.value),\n
            unit = this.unit.clone();\n
\n
        if (op === \'+\' || op === \'-\') {\n
            if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n
                unit.numerator = other.unit.numerator.slice(0);\n
                unit.denominator = other.unit.denominator.slice(0);\n
            } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n
                // do nothing\n
            } else {\n
                other = other.convertTo(this.unit.usedUnits());\n
\n
                if(env.strictUnits && other.unit.toString() !== unit.toString()) {\n
                  throw new Error("Incompatible units. Change the units or use the unit function. Bad units: \'" + unit.toString() +\n
                    "\' and \'" + other.unit.toString() + "\'.");\n
                }\n
\n
                value = tree.operate(env, op, this.value, other.value);\n
            }\n
        } else if (op === \'*\') {\n
            unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n
            unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n
            unit.cancel();\n
        } else if (op === \'/\') {\n
            unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n
            unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n
            unit.cancel();\n
        }\n
        return new(tree.Dimension)(value, unit);\n
    },\n
\n
    compare: function (other) {\n
        if (other instanceof tree.Dimension) {\n
            var a = this.unify(), b = other.unify(),\n
                aValue = a.value, bValue = b.value;\n
\n
            if (bValue > aValue) {\n
                return -1;\n
            } else if (bValue < aValue) {\n
                return 1;\n
            } else {\n
                if (!b.unit.isEmpty() && a.unit.compare(b.unit) !== 0) {\n
                    return -1;\n
                }\n
                return 0;\n
            }\n
        } else {\n
            return -1;\n
        }\n
    },\n
\n
    unify: function () {\n
        return this.convertTo({ length: \'m\', duration: \'s\', angle: \'rad\' });\n
    },\n
\n
    convertTo: function (conversions) {\n
        var value = this.value, unit = this.unit.clone(),\n
            i, groupName, group, targetUnit, derivedConversions = {}, applyUnit;\n
\n
        if (typeof conversions === \'string\') {\n
            for(i in tree.UnitConversions) {\n
                if (tree.UnitConversions[i].hasOwnProperty(conversions)) {\n
                    derivedConversions = {};\n
                    derivedConversions[i] = conversions;\n
                }\n
            }\n
            conversions = derivedConversions;\n
        }\n
        applyUnit = function (atomicUnit, denominator) {\n
          /*jshint loopfunc:true */\n
            if (group.hasOwnProperty(atomicUnit)) {\n
                if (denominator) {\n
                    value = value / (group[atomicUnit] / group[targetUnit]);\n
                } else {\n
                    value = value * (group[atomicUnit] / group[targetUnit]);\n
                }\n
\n
                return targetUnit;\n
            }\n
\n
            return atomicUnit;\n
        };\n
\n
        for (groupName in conversions) {\n
            if (conversions.hasOwnProperty(groupName)) {\n
                targetUnit = conversions[groupName];\n
                group = tree.UnitConversions[groupName];\n
\n
                unit.map(applyUnit);\n
            }\n
        }\n
\n
        unit.cancel();\n
\n
        return new(tree.Dimension)(value, unit);\n
    }\n
};\n
\n
// http://www.w3.org/TR/css3-values/#absolute-lengths\n
tree.UnitConversions = {\n
    length: {\n
         \'m\': 1,\n
        \'cm\': 0.01,\n
        \'mm\': 0.001,\n
        \'in\': 0.0254,\n
        \'pt\': 0.0254 / 72,\n
        \'pc\': 0.0254 / 72 * 12\n
    },\n
    duration: {\n
        \'s\': 1,\n
        \'ms\': 0.001\n
    },\n
    angle: {\n
        \'rad\': 1/(2*Math.PI),\n
        \'deg\': 1/360,\n
        \'grad\': 1/400,\n
        \'turn\': 1\n
    }\n
};\n
\n
tree.Unit = function (numerator, denominator, backupUnit) {\n
    this.numerator = numerator ? numerator.slice(0).sort() : [];\n
    this.denominator = denominator ? denominator.slice(0).sort() : [];\n
    this.backupUnit = backupUnit;\n
};\n
\n
tree.Unit.prototype = {\n
    type: "Unit",\n
    clone: function () {\n
    

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAM=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="3" aka="AAAAAAAAAAM=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

    return new tree.Unit(this.numerator.slice(0), this.denominator.slice(0), this.backupUnit);\n
    },\n
    genCSS: function (env, output) {\n
        if (this.numerator.length >= 1) {\n
            output.add(this.numerator[0]);\n
        } else\n
        if (this.denominator.length >= 1) {\n
            output.add(this.denominator[0]);\n
        } else\n
        if ((!env || !env.strictUnits) && this.backupUnit) {\n
            output.add(this.backupUnit);\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
\n
    toString: function () {\n
      var i, returnStr = this.numerator.join("*");\n
      for (i = 0; i < this.denominator.length; i++) {\n
          returnStr += "/" + this.denominator[i];\n
      }\n
      return returnStr;\n
    },\n
\n
    compare: function (other) {\n
        return this.is(other.toString()) ? 0 : -1;\n
    },\n
\n
    is: function (unitString) {\n
        return this.toString() === unitString;\n
    },\n
\n
    isLength: function () {\n
        return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/));\n
    },\n
\n
    isEmpty: function () {\n
        return this.numerator.length === 0 && this.denominator.length === 0;\n
    },\n
\n
    isSingular: function() {\n
        return this.numerator.length <= 1 && this.denominator.length === 0;\n
    },\n
\n
    map: function(callback) {\n
        var i;\n
\n
        for (i = 0; i < this.numerator.length; i++) {\n
            this.numerator[i] = callback(this.numerator[i], false);\n
        }\n
\n
        for (i = 0; i < this.denominator.length; i++) {\n
            this.denominator[i] = callback(this.denominator[i], true);\n
        }\n
    },\n
\n
    usedUnits: function() {\n
        var group, result = {}, mapUnit;\n
\n
        mapUnit = function (atomicUnit) {\n
        /*jshint loopfunc:true */\n
            if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n
                result[groupName] = atomicUnit;\n
            }\n
\n
            return atomicUnit;\n
        };\n
\n
        for (var groupName in tree.UnitConversions) {\n
            if (tree.UnitConversions.hasOwnProperty(groupName)) {\n
                group = tree.UnitConversions[groupName];\n
\n
                this.map(mapUnit);\n
            }\n
        }\n
\n
        return result;\n
    },\n
\n
    cancel: function () {\n
        var counter = {}, atomicUnit, i, backup;\n
\n
        for (i = 0; i < this.numerator.length; i++) {\n
            atomicUnit = this.numerator[i];\n
            if (!backup) {\n
                backup = atomicUnit;\n
            }\n
            counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n
        }\n
\n
        for (i = 0; i < this.denominator.length; i++) {\n
            atomicUnit = this.denominator[i];\n
            if (!backup) {\n
                backup = atomicUnit;\n
            }\n
            counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n
        }\n
\n
        this.numerator = [];\n
        this.denominator = [];\n
\n
        for (atomicUnit in counter) {\n
            if (counter.hasOwnProperty(atomicUnit)) {\n
                var count = counter[atomicUnit];\n
\n
                if (count > 0) {\n
                    for (i = 0; i < count; i++) {\n
                        this.numerator.push(atomicUnit);\n
                    }\n
                } else if (count < 0) {\n
                    for (i = 0; i < -count; i++) {\n
                        this.denominator.push(atomicUnit);\n
                    }\n
                }\n
            }\n
        }\n
\n
        if (this.numerator.length === 0 && this.denominator.length === 0 && backup) {\n
            this.backupUnit = backup;\n
        }\n
\n
        this.numerator.sort();\n
        this.denominator.sort();\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Directive = function (name, value, index, currentFileInfo) {\n
    this.name = name;\n
\n
    if (Array.isArray(value)) {\n
        this.rules = [new(tree.Ruleset)([], value)];\n
        this.rules[0].allowImports = true;\n
    } else {\n
        this.value = value;\n
    }\n
    this.currentFileInfo = currentFileInfo;\n
\n
};\n
tree.Directive.prototype = {\n
    type: "Directive",\n
    accept: function (visitor) {\n
        this.rules = visitor.visit(this.rules);\n
        this.value = visitor.visit(this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.name, this.currentFileInfo, this.index);\n
        if (this.rules) {\n
            tree.outputRuleset(env, output, this.rules);\n
        } else {\n
            output.add(\' \');\n
            this.value.genCSS(env, output);\n
            output.add(\';\');\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        var evaldDirective = this;\n
        if (this.rules) {\n
            env.frames.unshift(this);\n
            evaldDirective = new(tree.Directive)(this.name, null, this.index, this.currentFileInfo);\n
            evaldDirective.rules = [this.rules[0].eval(env)];\n
            evaldDirective.rules[0].root = true;\n
            env.frames.shift();\n
        }\n
        return evaldDirective;\n
    },\n
    variable: function (name) { return tree.Ruleset.prototype.variable.call(this.rules[0], name); },\n
    find: function () { return tree.Ruleset.prototype.find.apply(this.rules[0], arguments); },\n
    rulesets: function () { return tree.Ruleset.prototype.rulesets.apply(this.rules[0]); },\n
    markReferenced: function () {\n
        var i, rules;\n
        this.isReferenced = true;\n
        if (this.rules) {\n
            rules = this.rules[0].rules;\n
            for (i = 0; i < rules.length; i++) {\n
                if (rules[i].markReferenced) {\n
                    rules[i].markReferenced();\n
                }\n
            }\n
        }\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Element = function (combinator, value, index, currentFileInfo) {\n
    this.combinator = combinator instanceof tree.Combinator ?\n
                      combinator : new(tree.Combinator)(combinator);\n
\n
    if (typeof(value) === \'string\') {\n
        this.value = value.trim();\n
    } else if (value) {\n
        this.value = value;\n
    } else {\n
        this.value = "";\n
    }\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Element.prototype = {\n
    type: "Element",\n
    accept: function (visitor) {\n
        this.combinator = visitor.visit(this.combinator);\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        return new(tree.Element)(this.combinator,\n
                                 this.value.eval ? this.value.eval(env) : this.value,\n
                                 this.index,\n
                                 this.currentFileInfo);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.toCSS(env), this.currentFileInfo, this.index);\n
    },\n
    toCSS: function (env) {\n
        var value = (this.value.toCSS ? this.value.toCSS(env) : this.value);\n
        if (value === \'\' && this.combinator.value.charAt(0) === \'&\') {\n
            return \'\';\n
        } else {\n
            return this.combinator.toCSS(env || {}) + value;\n
        }\n
    }\n
};\n
\n
tree.Attribute = function (key, op, value) {\n
    this.key = key;\n
    this.op = op;\n
    this.value = value;\n
};\n
tree.Attribute.prototype = {\n
    type: "Attribute",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        return new(tree.Attribute)(this.key.eval ? this.key.eval(env) : this.key,\n
            this.op, (this.value && this.value.eval) ? this.value.eval(env) : this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.toCSS(env));\n
    },\n
    toCSS: function (env) {\n
        var value = this.key.toCSS ? this.key.toCSS(env) : this.key;\n
\n
        if (this.op) {\n
            value += this.op;\n
            value += (this.value.toCSS ? this.value.toCSS(env) : this.value);\n
        }\n
\n
        return \'[\' + value + \']\';\n
    }\n
};\n
\n
tree.Combinator = function (value) {\n
    if (value === \' \') {\n
        this.value = \' \';\n
    } else {\n
        this.value = value ? value.trim() : "";\n
    }\n
};\n
tree.Combinator.prototype = {\n
    type: "Combinator",\n
    _outputMap: {\n
        \'\'  : \'\',\n
        \' \' : \' \',\n
        \':\' : \' :\',\n
        \'+\' : \' + \',\n
        \'~\' : \' ~ \',\n
        \'>\' : \' > \',\n
        \'|\' : \'|\'\n
    },\n
    _outputMapCompressed: {\n
        \'\'  : \'\',\n
        \' \' : \' \',\n
        \':\' : \' :\',\n
        \'+\' : \'+\',\n
        \'~\' : \'~\',\n
        \'>\' : \'>\',\n
        \'|\' : \'|\'\n
    },\n
    genCSS: function (env, output) {\n
        output.add((env.compress ? this._outputMapCompressed : this._outputMap)[this.value]);\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Expression = function (value) { this.value = value; };\n
tree.Expression.prototype = {\n
    type: "Expression",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        var returnValue,\n
            inParenthesis = this.parens && !this.parensInOp,\n
            doubleParen = false;\n
        if (inParenthesis) {\n
            env.inParenthesis();\n
        }\n
        if (this.value.length > 1) {\n
            returnValue = new(tree.Expression)(this.value.map(function (e) {\n
                return e.eval(env);\n
            }));\n
        } else if (this.value.length === 1) {\n
            if (this.value[0].parens && !this.value[0].parensInOp) {\n
                doubleParen = true;\n
            }\n
            returnValue = this.value[0].eval(env);\n
        } else {\n
            returnValue = this;\n
        }\n
        if (inParenthesis) {\n
            env.outOfParenthesis();\n
        }\n
        if (this.parens && this.parensInOp && !(env.isMathOn()) && !doubleParen) {\n
            returnValue = new(tree.Paren)(returnValue);\n
        }\n
        return returnValue;\n
    },\n
    genCSS: function (env, output) {\n
        for(var i = 0; i < this.value.length; i++) {\n
            this.value[i].genCSS(env, output);\n
            if (i + 1 < this.value.length) {\n
                output.add(" ");\n
            }\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
    throwAwayComments: function () {\n
        this.value = this.value.filter(function(v) {\n
            return !(v instanceof tree.Comment);\n
        });\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Extend = function Extend(selector, option, index) {\n
    this.selector = selector;\n
    this.option = option;\n
    this.index = index;\n
\n
    switch(option) {\n
        case "all":\n
            this.allowBefore = true;\n
            this.allowAfter = true;\n
        break;\n
        default:\n
            this.allowBefore = false;\n
            this.allowAfter = false;\n
        break;\n
    }\n
};\n
\n
tree.Extend.prototype = {\n
    type: "Extend",\n
    accept: function (visitor) {\n
        this.selector = visitor.visit(this.selector);\n
    },\n
    eval: function (env) {\n
        return new(tree.Extend)(this.selector.eval(env), this.option, this.index);\n
    },\n
    clone: function (env) {\n
        return new(tree.Extend)(this.selector, this.option, this.index);\n
    },\n
    findSelfSelectors: function (selectors) {\n
        var selfElements = [],\n
            i,\n
            selectorElements;\n
\n
        for(i = 0; i < selectors.length; i++) {\n
            selectorElements = selectors[i].elements;\n
            // duplicate the logic in genCSS function inside the selector node.\n
            // future TODO - move both logics into the selector joiner visitor\n
            if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === "") {\n
                selectorElements[0].combinator.value = \' \';\n
            }\n
            selfElements = selfElements.concat(selectors[i].elements);\n
        }\n
\n
        this.selfSelectors = [{ elements: selfElements }];\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
//\n
// CSS @import node\n
//\n
// The general strategy here is that we don\'t want to wait\n
// for the parsing to be completed, before we start importing\n
// the file. That\'s because in the context of a browser,\n
// most of the time will be spent waiting for the server to respond.\n
//\n
// On creation, we push the import path to our import queue, though\n
// `import,push`, we also pass it a callback, which it\'ll call once\n
// the file has been fetched, and parsed.\n
//\n
tree.Import = function (path, features, options, index, currentFileInfo) {\n
    this.options = options;\n
    this.index = index;\n
    this.path = path;\n
    this.features = features;\n
    this.currentFileInfo = currentFileInfo;\n
\n
    if (this.options.less !== undefined || this.options.inline) {\n
        this.css = !this.options.less || this.options.inline;\n
    } else {\n
        var pathValue = this.getPath();\n
        if (pathValue && /css([\\?;].*)?$/.test(pathValue)) {\n
            this.css = true;\n
        }\n
    }\n
};\n
\n
//\n
// The actual import node doesn\'t return anything, when converted to CSS.\n
// The reason is that it\'s used at the evaluation stage, so that the rules\n
// it imports can be treated like any other rules.\n
//\n
// In `eval`, we make sure all Import nodes get evaluated, recursively, so\n
// we end up with a flat structure, which can easily be imported in the parent\n
// ruleset.\n
//\n
tree.Import.prototype = {\n
    type: "Import",\n
    accept: function (visitor) {\n
        this.features = visitor.visit(this.features);\n
        this.path = visitor.visit(this.path);\n
        if (!this.options.inline) {\n
            this.root = visitor.visit(this.root);\n
        }\n
    },\n
    genCSS: function (env, output) {\n
        if (this.css) {\n
            output.add("@import ", this.currentFileInfo, this.index);\n
            this.path.genCSS(env, output);\n
            if (this.features) {\n
                output.add(" ");\n
                this.features.genCSS(env, output);\n
            }\n
            output.add(\';\');\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
    getPath: function () {\n
        if (this.path instanceof tree.Quoted) {\n
            var path = this.path.value;\n
            return (this.css !== undefined || /(\\.[a-z]*$)|([\\?;].*)$/.test(path)) ? path : path + \'.less\';\n
        } else if (this.path instanceof tree.URL) {\n
            return this.path.value.value;\n
        }\n
        return null;\n
    },\n
    evalForImport: function (env) {\n
        return new(tree.Import)(this.path.eval(env), this.features, this.options, this.index, this.currentFileInfo);\n
    },\n
    evalPath: function (env) {\n
        var path = this.path.eval(env);\n
        var rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;\n
\n
        if (!(path instanceof tree.URL)) {\n
            if (rootpath) {\n
                var pathValue = path.value;\n
                // Add the base path if the import is relative\n
                if (pathValue && env.isPathRelative(pathValue)) {\n
                    path.value = rootpath + pathValue;\n
                }\n
            }\n
            path.value = env.normalizePath(path.value);\n
        }\n
\n
        return path;\n
    },\n
    eval: function (env) {\n
        var ruleset, features = this.features && this.features.eval(env);\n
\n
        if (this.skip) { return []; }\n
\n
        if (this.options.inline) {\n
            //todo needs to reference css file not import\n
            var contents = new(tree.Anonymous)(this.root, 0, {filename: this.importedFilename}, true);\n
            return this.features ? new(tree.Media)([contents], this.features.value) : [contents];\n
        } else if (this.css) {\n
            var newImport = new(tree.Import)(this.evalPath(env), features, this.options, this.index);\n
            if (!newImport.css && this.error) {\n
                throw this.error;\n
            }\n
            return newImport;\n
        } else {\n
            ruleset = new(tree.Ruleset)([], this.root.rules.slice(0));\n
\n
            ruleset.evalImports(env);\n
\n
            return this.features ? new(tree.Media)(ruleset.rules, this.features.value) : ruleset.rules;\n
        }\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.JavaScript = function (string, index, escaped) {\n
    this.escaped = escaped;\n
    this.expression = string;\n
    this.index = index;\n
};\n
tree.JavaScript.prototype = {\n
    type: "JavaScript",\n
    eval: function (env) {\n
        var result,\n
            that = this,\n
            context = {};\n
\n
        var expression = this.expression.replace(/@\\{([\\w-]+)\\}/g, function (_, name) {\n
            return tree.jsify(new(tree.Variable)(\'@\' + name, that.index).eval(env));\n
        });\n
\n
        try {\n
            expression = new(Function)(\'return (\' + expression + \')\');\n
        } catch (e) {\n
            throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`" ,\n
                    index: this.index };\n
        }\n
\n
        for (var k in env.frames[0].variables()) {\n
            /*jshint loopfunc:true */\n
            context[k.slice(1)] = {\n
                value: env.frames[0].variables()[k].value,\n
                toJS: function () {\n
                    return this.value.eval(env).toCSS();\n
                }\n
            };\n
        }\n
\n
        try {\n
            result = expression.call(context);\n
        } catch (e) {\n
            throw { message: "JavaScript evaluation error: \'" + e.name + \': \' + e.message + "\'" ,\n
                    index: this.index };\n
        }\n
        if (typeof(result) === \'string\') {\n
            return new(tree.Quoted)(\'"\' + result + \'"\', result, this.escaped, this.index);\n
        } else if (Array.isArray(result)) {\n
            return new(tree.Anonymous)(result.join(\', \'));\n
        } else {\n
            return new(tree.Anonymous)(result);\n
        }\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
\n
(function (tree) {\n
\n
tree.Keyword = function (value) { this.value = value; };\n
tree.Keyword.prototype = {\n
    type: "Keyword",\n
    eval: function () { return this; },\n
    genCSS: function (env, output) {\n
        output.add(this.value);\n
    },\n
    toCSS: tree.toCSS,\n
    compare: function (other) {\n
        if (other instanceof tree.Keyword) {\n
            return other.value === this.value ? 0 : 1;\n
        } else {\n
            return -1;\n
        }\n
    }\n
};\n
\n
tree.True = new(tree.Keyword)(\'true\');\n
tree.False = new(tree.Keyword)(\'false\');\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Media = function (value, features, index, currentFileInfo) {\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
\n
    var selectors = this.emptySelectors();\n
\n
    this.features = new(tree.Value)(features);\n
    this.rules = [new(tree.Ruleset)(selectors, value)];\n
    this.rules[0].allowImports = true;\n
};\n
tree.Media.prototype = {\n
    type: "Media",\n
    accept: function (visitor) {\n
        this.features = visitor.visit(this.features);\n
        this.rules = visitor.visit(this.rules);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(\'@media \', this.currentFileInfo, this.index);\n
        this.features.genCSS(env, output);\n
        tree.outputRuleset(env, output, this.rules);\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        if (!env.mediaBlocks) {\n
            env.mediaBlocks = [];\n
            env.mediaPath = [];\n
        }\n
        \n
        var media = new(tree.Media)([], [], this.index, this.currentFileInfo);\n
        if(this.debugInfo) {\n
            this.rules[0].debugInfo = this.debugInfo;\n
            media.debugInfo = this.debugInfo;\n
        }\n
        var strictMathBypass = false;\n
        if (!env.strictMath) {\n
            strictMathBypass = true;\n
            env.strictMath = true;\n
        }\n
        try {\n
            media.features = this.features.eval(env);\n
        }\n
        finally {\n
            if (strictMathBypass) {\n
                env.strictMath = false;\n
            }\n
        }\n
        \n
        env.mediaPath.push(media);\n
        env.mediaBlocks.push(media);\n
        \n
        env.frames.unshift(this.rules[0]);\n
        media.rules = [this.rules[0].eval(env)];\n
        env.frames.shift();\n
        \n
        env.mediaPath.pop();\n
\n
        return env.mediaPath.length === 0 ? media.evalTop(env) :\n
                    media.evalNested(env);\n
    },\n
    variable: function (name) { return tree.Ruleset.prototype.variable.call(this.rules[0], name); },\n
    find: function () { return tree.Ruleset.prototype.find.apply(this.rules[0], arguments); },\n
    rulesets: function () { return tree.Ruleset.prototype.rulesets.apply(this.rules[0]); },\n
    emptySelectors: function() { \n
        var el = new(tree.Element)(\'\', \'&\', this.index, this.currentFileInfo);\n
        return [new(tree.Selector)([el], null, null, this.index, this.currentFileInfo)];\n
    },\n
    markReferenced: function () {\n
        var i, rules = this.rules[0].rules;\n
        this.isReferenced = true;\n
        for (i = 0; i < rules.length; i++) {\n
            if (rules[i].markReferenced) {\n
                rules[i].markReferenced();\n
            }\n
        }\n
    },\n
\n
    evalTop: function (env) {\n
        var result = this;\n
\n
        // Render all dependent Media blocks.\n
        if (env.mediaBlocks.length > 1) {\n
            var selectors = this.emptySelectors();\n
            result = new(tree.Ruleset)(selectors, env.mediaBlocks);\n
            result.multiMedia = true;\n
        }\n
\n
        delete env.mediaBlocks;\n
        delete env.mediaPath;\n
\n
        return result;\n
    },\n
    evalNested: function (env) {\n
        var i, value,\n
            path = env.mediaPath.concat([this]);\n
\n
        // Extract the media-query conditions separated with `,` (OR).\n
        for (i = 0; i < path.length; i++) {\n
            value = path[i].features instanceof tree.Value ?\n
                        path[i].features.value : path[i].features;\n
            path[i] = Array.isArray(value) ? value : [value];\n
        }\n
\n
        // Trace all permutations to generate the resulting media-query.\n
        //\n
        // (a, b and c) with nested (d, e) ->\n
        //    a and d\n
        //    a and e\n
        //    b and c and d\n
        //    b and c and e\n
        this.features = new(tree.Value)(this.permute(path).map(function (path) {\n
            path = path.map(function (fragment) {\n
                return fragment.toCSS ? fragment : new(tree.Anonymous)(fragment);\n
            });\n
\n
            for(i = path.length - 1; i > 0; i--) {\n
                path.splice(i, 0, new(tree.Anonymous)("and"));\n
            }\n
\n
            return new(tree.Expression)(path);\n
        }));\n
\n
        // Fake a tree-node that doesn\'t output anything.\n
        return new(tree.Ruleset)([], []);\n
    },\n
    permute: function (arr) {\n
      if (arr.length === 0) {\n
          return [];\n
      } else if (arr.length === 1) {\n
          return arr[0];\n
      } else {\n
          var result = [];\n
          var rest = this.permute(arr.slice(1));\n
          for (var i = 0; i < rest.length; i++) {\n
              for (var j = 0; j < arr[0].length; j++) {\n
                  result.push([arr[0][j]].concat(rest[i]));\n
              }\n
          }\n
          return result;\n
      }\n
    },\n
    bubbleSelectors: function (selectors) {\n
      this.rules = [new(tree.Ruleset)(selectors.slice(0), [this.rules[0]])];\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.mixin = {};\n
tree.mixin.Call = function (elements, args, index, currentFileInfo, important) {\n
    this.selector = new(tree.Selector)(elements);\n
    this.arguments = args;\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
    this.important = important;\n
};\n
tree.mixin.Call.prototype = {\n
    type: "MixinCall",\n
    accept: function (visitor) {\n
        this.selector = visitor.visit(this.selector);\n
        this.arguments = visitor.visit(this.arguments);\n
    },\n
    eval: function (env) {\n
        var mixins, mixin, args, rules = [], match = false, i, m, f, isRecursive, isOneFound, rule;\n
\n
        args = this.arguments && this.arguments.map(function (a) {\n
            return { name: a.name, value: a.value.eval(env) };\n
        });\n
\n
        for (i = 0; i < env.frames.length; i++) {\n
            if ((mixins = env.frames[i].find(this.selector)).length > 0) {\n
                isOneFound = true;\n
                for (m = 0; m < mixins.length; m++) {\n
                    mixin = mixins[m];\n
                    isRecursive = false;\n
                    for(f = 0; f < env.frames.length; f++) {\n
                        if ((!(mixin instanceof tree.mixin.Definition)) && mixin === (env.frames[f].originalRuleset || env.frames[f])) {\n
                            isRecursive = true;\n
                            break;\n
                        }\n
                    }\n
                    if (isRecursive) {\n
                        continue;\n
                    }\n
                    if (mixin.matchArgs(args, env)) {\n
                        if (!mixin.matchCondition || mixin.matchCondition(args, env)) {\n
                            try {\n
                                if (!(mixin instanceof tree.mixin.Definition)) {\n
                                    mixin = new tree.mixin.Definition("", [], mixin.rules, null, false);\n
                                    mixin.originalRuleset = mixins[m].originalRuleset || mixins[m];\n
                                }\n
                                //if (this.important) {\n
                                //    isImportant = env.isImportant;\n
                                //    env.isImportant = true;\n
                                //}\n
                                Array.prototype.push.apply(\n
                                      rules, mixin.eval(env, args, this.important).rules);\n
                                //if (this.important) {\n
                                //    env.isImportant = isImportant;\n
                                //}\n
                            } catch (e) {\n
                                throw { message: e.message, index: this.index, filename: this.currentFileInfo.filename, stack: e.stack };\n
                            }\n
                        }\n
                        match = true;\n
                    }\n
                }\n
                if (match) {\n
                    if (!this.currentFileInfo || !this.currentFileInfo.reference) {\n
                        for (i = 0; i < rules.length; i++) {\n
                            rule = rules[i];\n
                            if (rule.markReferenced) {\n
                                rule.markReferenced();\n
                            }\n
                        }\n
                    }\n
                    return rules;\n
                }\n
            }\n
        }\n
        if (isOneFound) {\n
            throw { type:    \'Runtime\',\n
                    message: \'No matching definition was found for `\' +\n
                              this.selector.toCSS().trim() + \'(\'      +\n
                              (args ? args.map(function (a) {\n
                                  var argValue = "";\n
                                  if (a.name) {\n
                                      argValue += a.name + ":";\n
                                  }\n
                                  if (a.value.toCSS) {\n
                                      argValue += a.value.toCSS();\n
                                  } else {\n
                                      argValue += "???";\n
                                  }\n
                                  return argValue;\n
                              }).join(\', \') : "") + ")`",\n
                    index:   this.index, filename: this.currentFileInfo.filename };\n
        } else {\n
            throw { type: \'Name\',\n
                message: this.selector.toCSS().trim() + " is undefined",\n
                index: this.index, filename: this.currentFileInfo.filename };\n
        }\n
    }\n
};\n
\n
tree.mixin.Definition = function (name, params, rules, condition, variadic) {\n
    this.name = name;\n
    this.selectors = [new(tree.Selector)([new(tree.Element)(null, name, this.index, this.currentFileInfo)])];\n
    this.params = params;\n
    this.condition = condition;\n
    this.variadic = variadic;\n
    this.arity = params.length;\n
    this.rules = rules;\n
    this._lookups = {};\n
    this.required = params.reduce(function (count, p) {\n
        if (!p.name || (p.name && !p.value)) { return count + 1; }\n
        else                                 { return count; }\n
    }, 0);\n
    this.parent = tree.Ruleset.prototype;\n
    this.frames = [];\n
};\n
tree.mixin.Definition.prototype = {\n
    type: "MixinDefinition",\n
    accept: function (visitor) {\n
        this.params = visitor.visit(this.params);\n
        this.rules = visitor.visit(this.rules);\n
        this.condition = visitor.visit(this.condition);\n
    },\n
    variable:  function (name) { return this.parent.variable.call(this, name); },\n
    variables: function ()     { return this.parent.variables.call(this); },\n
    find:      function ()     { return this.parent.find.apply(this, arguments); },\n
    rulesets:  function ()     { return this.parent.rulesets.apply(this); },\n
\n
    evalParams: function (env, mixinEnv, args, evaldArguments) {\n
        /*jshint boss:true */\n
        var frame = new(tree.Ruleset)(null, []),\n
            varargs, arg,\n
            params = this.params.slice(0),\n
            i, j, val, name, isNamedFound, argIndex;\n
\n
        mixinEnv = new tree.evalEnv(mixinEnv, [frame].concat(mixinEnv.frames));\n
        \n
        if (args) {\n
            args = args.slice(0);\n
\n
            for(i = 0; i < args.length; i++) {\n
                arg = args[i];\n
                if (name = (arg && arg.name)) {\n
                    isNamedFound = false;\n
                    for(j = 0; j < params.length; j++) {\n
                        if (!evaldArguments[j] && name === params[j].name) {\n
                            evaldArguments[j] = arg.value.eval(env);\n
                            frame.rules.unshift(new(tree.Rule)(name, arg.value.eval(env)));\n
                            isNamedFound = true;\n
                            break;\n
                        }\n
                    }\n
                    if (isNamedFound) {\n
                        args.splice(i, 1);\n
                        i--;\n
                        continue;\n
                    } else {\n
                        throw { type: \'Runtime\', message: "Named argument for " + this.name +\n
                            \' \' + args[i].name + \' not found\' };\n
                    }\n
                }\n
            }\n
        }\n
        argIndex = 0;\n
        for (i = 0; i < params.length; i++) {\n
            if (evaldArguments[i]) { continue; }\n
            \n
            arg = args && args[argIndex];\n
\n
            if (name = params[i].name) {\n
                if (params[i].variadic && args) {\n
                    varargs = [];\n
                    for (j = argIndex; j < args.length; j++) {\n
                        varargs.push(args[j].value.eval(env));\n
                    }\n
                    frame.rules.unshift(new(tree.Rule)(name, new(tree.Expression)(varargs).eval(env)));\n
                } else {\n
                    val = arg && arg.value;\n
                    if (val) {\n
                        val = val.eval(env);\n
                    } else if (params[i].value) {\n
                        val = params[i].value.eval(mixinEnv);\n
                        frame.resetCache();\n
                    } else {\n
                        throw { type: \'Runtime\', message: "wrong number of arguments for " + this.name +\n
                            \' (\' + args.length + \' for \' + this.arity + \')\' };\n
                    }\n
                    \n
                    frame.rules.unshift(new(tree.Rule)(name, val));\n
                    evaldArguments[i] = val;\n
                }\n
            }\n
            \n
            if (params[i].variadic && args) {\n
                for (j = argIndex; j < args.length; j++) {\n
                    evaldArguments[j] = args[j].value.eval(env);\n
                }\n
            }\n
            argIndex++;\n
        }\n
\n
        return frame;\n
    },\n
    eval: function (env, args, important) {\n
        var _arguments = [],\n
            mixinFrames = this.frames.concat(env.frames),\n
            frame = this.evalParams(env, new(tree.evalEnv)(env, mixinFrames), args, _arguments),\n
            rules, ruleset;\n
\n
        frame.rules.unshift(new(tree.Rule)(\'@arguments\', new(tree.Expression)(_arguments).eval(env)));\n
\n
        rules = this.rules.slice(0);\n
\n
        ruleset = new(tree.Ruleset)(null, rules);\n
        ruleset.originalRuleset = this;\n
        ruleset = ruleset.eval(new(tree.evalEnv)(env, [this, frame].concat(mixinFrames)));\n
        if (important) {\n
            ruleset = this.parent.makeImportant.apply(ruleset);\n
        }\n
        return ruleset;\n
    },\n
    matchCondition: function (args, env) {\n
        if (this.condition && !this.condition.eval(\n
            new(tree.evalEnv)(env,\n
                [this.evalParams(env, new(tree.evalEnv)(env, this.frames.concat(env.frames)), args, [])] // the parameter variables\n
                    .concat(this.frames) // the parent namespace/mixin frames\n
                    .concat(env.frames)))) { // the current environment frames\n
            return false;\n
        }\n
        return true;\n
    },\n
    matchArgs: function (args, env) {\n
        var argsLength = (args && args.length) || 0, len;\n
\n
        if (! this.variadic) {\n
            if (argsLength < this.required)                               { return false; }\n
            if (argsLength > this.params.length)                          { return false; }\n
        } else {\n
            if (argsLength < (this.required - 1))                         { return false; }\n
        }\n
\n
        len = Math.min(argsLength, this.arity);\n
\n
        for (var i = 0; i < len; i++) {\n
            if (!this.params[i].name && !this.params[i].variadic) {\n
                if (args[i].value.eval(env).toCSS() != this.params[i].value.eval(env).toCSS()) {\n
                    return false;\n
                }\n
            }\n
        }\n
        return true;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Negative = function (node) {\n
    this.value = node;\n
};\n
tree.Negative.prototype = {\n
    type: "Negative",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(\'-\');\n
        this.value.genCSS(env, output);\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        if (env.isMathOn()) {\n
            return (new(tree.Operation)(\'*\', [new(tree.Dimension)(-1), this.value])).eval(env);\n
        }\n
        return new(tree.Negative)(this.value.eval(env));\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Operation = function (op, operands, isSpaced) {\n
    this.op = op.trim();\n
    this.operands = operands;\n
    this.isSpaced = isSpaced;\n
};\n
tree.Operation.prototype = {\n
    type: "Operation",\n
    accept: function (visitor) {\n
        this.operands = visitor.visit(this.operands);\n
    },\n
    eval: function (env) {\n
        var a = this.operands[0].eval(env),\n
            b = this.operands[1].eval(env),\n
            temp;\n
\n
        if (env.isMathOn()) {\n
            if (a instanceof tree.Dimension && b instanceof tree.Color) {\n
                if (this.op === \'*\' || this.op === \'+\') {\n
                    temp = b, b = a, a = temp;\n
                } else {\n
                    throw { type: "Operation",\n
                            message: "Can\'t substract or divide a color from a number" };\n
                }\n
            }\n
            if (!a.operate) {\n
                throw { type: "Operation",\n
                        message: "Operation on an invalid type" };\n
            }\n
\n
            return a.operate(env, this.op, b);\n
        } else {\n
            return new(tree.Operation)(this.op, [a, b], this.isSpaced);\n
        }\n
    },\n
    genCSS: function (env, output) {\n
        this.operands[0].genCSS(env, output);\n
        if (this.isSpaced) {\n
            output.add(" ");\n
        }\n
        output.add(this.op);\n
        if (this.isSpaced) {\n
            output.add(" ");\n
        }\n
        this.operands[1].genCSS(env, output);\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
tree.operate = function (env, op, a, b) {\n
    switch (op) {\n
        case \'+\': return a + b;\n
        case \'-\': return a - b;\n
        case \'*\': return a * b;\n
        case \'/\': return a / b;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
\n
(function (tree) {\n
\n
tree.Paren = function (node) {\n
    this.value = node;\n
};\n
tree.Paren.prototype = {\n
    type: "Paren",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(\'(\');\n
        this.value.genCSS(env, output);\n
        output.add(\')\');\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        return new(tree.Paren)(this.value.eval(env));\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Quoted = function (str, content, escaped, index, currentFileInfo) {\n
    this.escaped = escaped;\n
    this.value = content || \'\';\n
    this.quote = str.charAt(0);\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Quoted.prototype = {\n
    type: "Quoted",\n
    genCSS: function (env, output) {\n
        if (!this.escaped) {\n
            output.add(this.quote, this.currentFileInfo, this.index);\n
        }\n
        output.add(this.value);\n
        if (!this.escaped) {\n
            output.add(this.quote);\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        var that = this;\n
        var value = this.value.replace(/`([^`]+)`/g, function (_, exp) {\n
            return new(tree.JavaScript)(exp, that.index, true).eval(env).value;\n
        }).replace(/@\\{([\\w-]+)\\}/g, function (_, name) {\n
            var v = new(tree.Variable)(\'@\' + name, that.index, that.currentFileInfo).eval(env, true);\n
            return (v instanceof tree.Quoted) ? v.value : v.toCSS();\n
        });\n
        return new(tree.Quoted)(this.quote + value + this.quote, value, this.escaped, this.index, this.currentFileInfo);\n
    },\n
    compare: function (x) {\n
        if (!x.toCSS) {\n
            return -1;\n
        }\n
        \n
        var left = this.toCSS(),\n
            right = x.toCSS();\n
        \n
        if (left === right) {\n
            return 0;\n
        }\n
        \n
        return left < right ? -1 : 1;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Rule = function (name, value, important, merge, index, currentFileInfo, inline) {\n
    this.name = name;\n
    this.value = (value instanceof tree.Value) ? value : new(tree.Value)([value]);\n
    this.important = important ? \' \' + important.trim() : \'\';\n
    this.merge = merge;\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
    this.inline = inline || false;\n
    this.variable = (name.charAt(0) === \'@\');\n
};\n
\n
tree.Rule.prototype = {\n
    type: "Rule",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add(this.name + (env.compress ? \':\' : \': \'), this.currentFileInfo, this.index);\n
        try {\n
            this.value.genCSS(env, output);\n
        }\n
        catch(e) {\n
            e.index = this.index;\n
            e.filename = this.currentFileInfo.filename;\n
            throw e;\n
        }\n
        output.add(this.important + ((this.inline || (env.lastRule && env.compress)) ? "" : ";"), this.currentFileInfo, this.index);\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (env) {\n
        var strictMathBypass = false;\n
        if (this.name === "font" && !env.strictMath) {\n
            strictMathBypass = true;\n
            env.strictMath = true;\n
        }\n
        try {\n
            return new(tree.Rule)(this.name,\n
                              this.value.eval(env),\n
                              this.important,\n
                              this.merge,\n
                              this.index, this.currentFileInfo, this.inline);\n
        }\n
        finally {\n
            if (strictMathBypass) {\n
                env.strictMath = false;\n
            }\n
        }\n
    },\n
    makeImportant: function () {\n
        return new(tree.Rule)(this.name,\n
                              this.value,\n
                              "!important",\n
                              this.merge,\n
                              this.index, this.currentFileInfo, this.inline);\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Ruleset = function (selectors, rules, strictImports) {\n
    this.selectors = selectors;\n
    this.rules = rules;\n
    this._lookups = {};\n
    this.strictImports = strictImports;\n
};\n
tree.Ruleset.prototype = {\n
    type: "Ruleset",\n
    accept: function (visitor) {\n
        if (this.paths) {\n
            for(var i = 0; i < this.paths.length; i++) {\n
                this.paths[i] = visitor.visit(this.paths[i]);\n
            }\n
        } else {\n
            this.selectors = visitor.visit(this.selectors);\n
        }\n
        this.rules = visitor.visit(this.rules);\n
    },\n
    eval: function (env) {\n
        var selectors = this.selectors && this.selectors.map(function (s) { return s.eval(env); });\n
        var ruleset = new(tree.Ruleset)(selectors, this.rules.slice(0), this.strictImports);\n
        var rules;\n
        var rule;\n
        var i;\n
        \n
        ruleset.originalRuleset = this;\n
        ruleset.root = this.root;\n
        ruleset.firstRoot = this.firstRoot;\n
        ruleset.allowImports = this.allowImports;\n
\n
        if(this.debugInfo) {\n
            ruleset.debugInfo = this.debugInfo;\n
        }\n
\n
        // push the current ruleset to the frames stack\n
        env.frames.unshift(ruleset);\n
\n
        // currrent selectors\n
        if (!env.selectors) {\n
            env.selectors = [];\n
        }\n
        env.selectors.unshift(this.selectors);\n
\n
        // Evaluate imports\n
        if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n
            ruleset.evalImports(env);\n
        }\n
\n
        // Store the frames around mixin definitions,\n
        // so they can be evaluated like closures when the time comes.\n
        for (i = 0; i < ruleset.rules.length; i++) {\n
            if (ruleset.rules[i] instanceof tree.mixin.Definition) {\n
                ruleset.rules[i].frames = env.frames.slice(0);\n
            }\n
        }\n
        \n
        var mediaBlockCount = (env.mediaBlocks && env.mediaBlocks.length) || 0;\n
\n
        // Evaluate mixin calls.\n
        for (i = 0; i < ruleset.rules.length; i++) {\n
            if (ruleset.rules[i] instanceof tree.mixin.Call) {\n
                /*jshint loopfunc:true */\n
                rules = ruleset.rules[i].eval(env).filter(function(r) {\n
                    if ((r instanceof tree.Rule) && r.variable) {\n
                        // do not pollute the scope if the variable is\n
                        // already there. consider returning false here\n
                        // but we need a way to "return" variable from mixins\n
                        return !(ruleset.variable(r.name));\n
                    }\n
                    return true;\n
                });\n
                ruleset.rules.splice.apply(ruleset.rules, [i, 1].concat(rules));\n
                i += rules.length-1;\n
                ruleset.resetCache();\n
            }\n
        }\n
        \n
        // Evaluate everything else\n
        for (i = 0; i < ruleset.rules.length; i++) {\n
            rule = ruleset.rules[i];\n
\n
            if (! (rule instanceof tree.mixin.Definition)) {\n
                ruleset.rules[i] = rule.eval ? rule.eval(env) : rule;\n
            }\n
        }\n
\n
        // Pop the stack\n
        env.frames.shift();\n
        env.selectors.shift();\n
        \n
        if (env.mediaBlocks) {\n
            for (i = mediaBlockCount; i < env.mediaBlocks.length; i++) {\n
                env.mediaBlocks[i].bubbleSelectors(selectors);\n
            }\n
        }\n
\n
        return ruleset;\n
    },\n
    evalImports: function(env) {\n
        var i, rules;\n
        for (i = 0; i < this.rules.length; i++) {\n
            if (this.rules[i] instanceof tree.Import) {\n
                rules = this.rules[i].eval(env);\n
                if (typeof rules.length === "number") {\n
                    this.rules.splice.apply(this.rules, [i, 1].concat(rules));\n
                    i+= rules.length-1;\n
                } else {\n
                    this.rules.splice(i, 1, rules);\n
                }\n
                this.resetCache();\n
            }\n
        }\n
    },\n
    makeImportant: function() {\n
        return new tree.Ruleset(this.selectors, this.rules.map(function (r) {\n
                    if (r.makeImportant) {\n
                        return r.makeImportant();\n
                    } else {\n
                        return r;\n
                    }\n
                }), this.strictImports);\n
    },\n
    matchArgs: function (args) {\n
        return !args || args.length === 0;\n
    },\n
    matchCondition: function (args, env) {\n
        var lastSelector = this.selectors[this.selectors.length-1];\n
        if (lastSelector.condition &&\n
            !lastSelector.condition.eval(\n
                new(tree.evalEnv)(env,\n
                    env.frames))) {\n
            return false;\n
        }\n
        return true;\n
    },\n
    resetCache: function () {\n
        this._rulesets = null;\n
        this._variables = null;\n
        this._lookups = {};\n
    },\n
    variables: function () {\n
        if (this._variables) { return this._variables; }\n
        else {\n
            return this._variables = this.rules.reduce(function (hash, r) {\n
                if (r instanceof tree.Rule && r.variable === true) {\n
                    hash[r.name] = r;\n
                }\n
                return hash;\n
            }, {});\n
        }\n
    },\n
    variable: function (name) {\n
        return this.variables()[name];\n
    },\n
    rulesets: function () {\n
        return this.rules.filter(function (r) {\n
            return (r instanceof tree.Ruleset) || (r instanceof tree.mixin.Definition);\n
        });\n
    },\n
    find: function (selector, self) {\n
        self = self || this;\n
        var rules = [], match,\n
            key = selector.toCSS();\n
\n
        if (key in this._lookups) { return this._lookups[key]; }\n
\n
        this.rulesets().forEach(function (rule) {\n
            if (rule !== self) {\n
                for (var j = 0; j < rule.selectors.length; j++) {\n
                    if (match = selector.match(rule.selectors[j])) {\n
                        if (selector.elements.length > match) {\n
                            Array.prototype.push.apply(rules, rule.find(\n
                                new(tree.Selector)(selector.elements.slice(match)), self));\n
                        } else {\n
                            rules.push(rule);\n
                        }\n
                        break;\n
                    }\n
                }\n
            }\n
        });\n
        return this._lookups[key] = rules;\n
    },\n
    genCSS: function (env, output) {\n
        var i, j,\n
            ruleNodes = [],\n
            rulesetNodes = [],\n
            debugInfo,     // Line number debugging\n
            rule,\n
            firstRuleset = true,\n
            path;\n
\n
        env.tabLevel = (env.tabLevel || 0);\n
\n
        if (!this.root) {\n
            env.tabLevel++;\n
        }\n
\n
        var tabRuleStr = env.compress ? \'\' : Array(env.tabLevel + 1).join("  "),\n
            tabSetStr = env.compress ? \'\' : Array(env.tabLevel).join("  ");\n
\n
        for (i = 0; i < this.rules.length; i++) {\n
            rule = this.rules[i];\n
            if (rule.rules || (rule instanceof tree.Media) || rule instanceof tree.Directive || (this.root && rule instanceof tree.Comment)) {\n
                rulesetNodes.push(rule);\n
            } else {\n
                ruleNodes.push(rule);\n
            }\n
        }\n
\n
        // If this is the root node, we don\'t render\n
        // a selector, or {}.\n
        if (!this.root) {\n
            debugInfo = tree.debugInfo(env, this, tabSetStr);\n
\n
            if (debugInfo) {\n
                output.add(debugInfo);\n
                output.add(tabSetStr);\n
            }\n
\n
            for(i = 0; i < this.paths.length; i++) {\n
                path = this.paths[i];\n
                env.firstSelector = true;\n
                for(j = 0; j < path.length; j++) {\n
                    path[j].genCSS(env, output);\n
                    env.firstSelector = false;\n
                }\n
                if (i + 1 < this.paths.length) {\n
                    output.add(env.compress ? \',\' : (\',\\n\' + tabSetStr));\n
                }\n
            }\n
\n
            output.add((env.compress ? \'{\' : \' {\\n\') + tabRuleStr);\n
        }\n
\n
        // Compile rules and rulesets\n
        for (i = 0; i < ruleNodes.length; i++) {\n
            rule = ruleNodes[i];\n
\n
            // @page{ directive ends up with root elements inside it, a mix of rules and rulesets\n
            // In this instance we do not know whether it is the last property\n
            if (i + 1 === ruleNodes.length && (!this.root || rulesetNodes.length === 0 || this.firstRoot)) {\n
                env.lastRule = true;\n
            }\n
\n
            if (rule.genCSS) {\n
                rule.genCSS(env, output);\n
            } else if (rule.value) {\n
                output.add(rule.value.toString());\n
            }\n
\n
            if (!env.lastRule) {\n
                output.add(env.compress ? \'\' : (\'\\n\' + tabRuleStr));\n
            } else {\n
                env.lastRule = false;\n
            }\n
        }\n
\n
        if (!this.root) {\n
            output.add((env.compress ? \'}\' : \'\\n\' + tabSetStr + \'}\'));\n
            env.tabLevel--;\n
        }\n
\n
        for (i = 0; i < rulesetNodes.length; i++) {\n
            if (ruleNodes.length && firstRuleset) {\n
                output.add((env.compress ? "" : "\\n") + (this.root ? tabRuleStr : tabSetStr));\n
            }\n
            if (!firstRuleset) {\n
                output.add((env.compress ? "" : "\\n") + (this.root ? tabRuleStr : tabSetStr));\n
            }\n
            firstRuleset = false;\n
            rulesetNodes[i].genCSS(env, output);\n
        }\n
\n
        if (!output.isEmpty() && !env.compress && this.firstRoot) {\n
            output.add(\'\\n\');\n
        }\n
    },\n
\n
    toCSS: tree.toCSS,\n
\n
    markReferenced: function () {\n
        for (var s = 0; s < this.selectors.length; s++) {\n
            this.selectors[s].markReferenced();\n
        }\n
    },\n
\n
    joinSelectors: function (paths, context, selectors) {\n
        for (var s = 0; s < selectors.length; s++) {\n
            this.joinSelector(paths, context, selectors[s]);\n
        }\n
    },\n
\n
    joinSelector: function (paths, context, selector) {\n
\n
        var i, j, k, \n
            hasParentSelector, newSelectors, el, sel, parentSel, \n
            newSelectorPath, afterParentJoin, newJoinedSelector, \n
            newJoinedSelectorEmpty, lastSelector, currentElements,\n
            selectorsMultiplied;\n
    \n
        for (i = 0; i < selector.elements.length; i++) {\n
            el = selector.elements[i];\n
            if (el.value === \'&\') {\n
                hasParentSelector = true;\n
            }\n
        }\n
    \n
        if (!hasParentSelector) {\n
            if (context.length > 0) {\n
                for (i = 0; i < context.length; i++) {\n
                    paths.push(context[i].concat(selector));\n
                }\n
            }\n
            else {\n
                paths.push([selector]);\n
            }\n
            return;\n
        }\n
\n
        // The paths are [[Selector]]\n
        // The first list is a list of comma seperated selectors\n
        // The inner list is a list of inheritance seperated selectors\n
        // e.g.\n
        // .a, .b {\n
        //   .c {\n
        //   }\n
        // }\n
        // == [[.a] [.c]] [[.b] [.c]]\n
        //\n
\n
        // the elements from the current selector so far\n
        currentElements = [];\n
        // the current list of new selectors to add to the path.\n
        // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors\n
        // by the parents\n
        newSelectors = [[]];\n
\n
        for (i = 0; i < selector.elements.length; i++) {\n
            el = selector.elements[i];\n
            // non parent reference elements just get added\n
            if (el.value !== "&") {\n
                currentElements.push(el);\n
            } else {\n
                // the new list of selectors to add\n
                selectorsMultiplied = [];\n
\n
                // merge the current list of non parent selector elements\n
                // on to the current list of selectors to add\n
                if (currentElements.length > 0) {\n
                    this.mergeElementsOnToSelectors(currentElements, newSelectors);\n
                }\n
\n
                // loop through our current selectors\n
                for (j = 0; j < newSelectors.length; j++) {\n
                    sel = newSelectors[j];\n
                    // if we don\'t have any parent paths, the & might be in a mixin so that it can be used\n
                    // whether there are parents or not\n
                    if (context.length === 0) {\n
                        // the combinator used on el should now be applied to the next element instead so that\n
                        // it is not lost\n
                        if (sel.length > 0) {\n
                            sel[0].elements = sel[0].elements.slice(0);\n
                            sel[0].elements.push(new(tree.Element)(el.combinator, \'\', 0, el.index, el.currentFileInfo));\n
                        }\n
                        selectorsMultiplied.push(sel);\n
                    }\n
                    else {\n
                        // and the parent selectors\n
                        for (k = 0; k < context.length; k++) {\n
                            parentSel = context[k];\n
                            // We need to put the current selectors\n
                            // then join the last selector\'s elements on to the parents selectors\n
\n
                            // our new selector path\n
                            newSelectorPath = [];\n
                            // selectors from the parent after the join\n
                            afterParentJoin = [];\n
                            newJoinedSelectorEmpty = true;\n
\n
                            //construct the joined selector - if & is the first thing this will be empty,\n
                            // if not newJoinedSelector will be the last set of elements in the selector\n
                            if (sel.length > 0) {\n
                                newSelectorPath = sel.slice(0);\n
                                lastSelector = newSelectorPath.pop();\n
                                newJoinedSelector = selector.createDerived(lastSelector.elements.slice(0));\n
                                newJoinedSelectorEmpty = false;\n
                            }\n
                            else {\n
                                newJoinedSelector = selector.createDerived([]);\n
                            }\n
\n
                            //put together the parent selectors after the join\n
                            if (parentSel.length > 1) {\n
                                afterParentJoin = afterParentJoin.concat(parentSel.slice(1));\n
                            }\n
\n
                            if (parentSel.length > 0) {\n
                                newJoinedSelectorEmpty = false;\n
\n
                                // join the elements so far with the first part of the parent\n
                                newJoinedSelector.elements.push(new(tree.Element)(el.combinator, parentSel[0].elements[0].value, el.index, el.currentFileInfo));\n
                                newJoinedSelector.elements = newJoinedSelector.elements.concat(parentSel[0].elements.slice(1));\n
                            }\n
\n
                            if (!newJoinedSelectorEmpty) {\n
                                // now add the joined selector\n
                                newSelectorPath.push(newJoinedSelector);\n
                            }\n
\n
                            // and the rest of the parent\n
                            newSelectorPath = newSelectorPath.concat(afterParentJoin);\n
\n
                            // add that to our new set of selectors\n
                            selectorsMultiplied.push(newSelectorPath);\n
                        }\n
                    }\n
                }\n
\n
                // our new selectors has been multiplied, so reset the state\n
                newSelectors = selectorsMultiplied;\n
                currentElements = [];\n
            }\n
        }\n
\n
        // if we have any elements left over (e.g. .a& .b == .b)\n
        // add them on to all the current selectors\n
        if (currentElements.length > 0) {\n
            this.mergeElementsOnToSelectors(currentElements, newSelectors);\n
        }\n
\n
        for (i = 0; i < newSelectors.length; i++) {\n
            if (newSelectors[i].length > 0) {\n
                paths.push(newSelectors[i]);\n
            }\n
        }\n
    },\n
    \n
    mergeElementsOnToSelectors: function(elements, selectors) {\n
        var i, sel;\n
\n
        if (selectors.length === 0) {\n
            selectors.push([ new(tree.Selector)(elements) ]);\n
            return;\n
        }\n
\n
        for (i = 0; i < selectors.length; i++) {\n
            sel = selectors[i];\n
\n
            // if the previous thing in sel is a parent this needs to join on to it\n
            if (sel.length > 0) {\n
                sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n
            }\n
            else {\n
                sel.push(new(tree.Selector)(elements));\n
            }\n
        }\n
    }\n
};\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Selector = function (elements, extendList, condition, index, currentFileInfo, isReferenced) {\n
    this.elements = elements;\n
    this.extendList = extendList || [];\n
    this.condition = condition;\n
    this.currentFileInfo = currentFileInfo || {};\n
    this.isReferenced = isReferenced;\n
    if (!condition) {\n
        this.evaldCondition = true;\n
    }\n
};\n
tree.Selector.prototype = {\n
    type: "Selector",\n
    accept: function (visitor) {\n
        this.elements = visitor.visit(this.elements);\n
        this.extendList = visitor.visit(this.extendList);\n
        this.condition = visitor.visit(this.condition);\n
    },\n
    createDerived: function(elements, extendList, evaldCondition) {\n
        /*jshint eqnull:true */\n
        evaldCondition = evaldCondition != null ? evaldCondition : this.evaldCondition;\n
        var newSelector = new(tree.Selector)(elements, extendList || this.extendList, this.condition, this.index, this.currentFileInfo, this.isReferenced);\n
        newSelector.evaldCondition = evaldCondition;\n
        return newSelector;\n
    },\n
    match: function (other) {\n
        var elements = this.elements,\n
            len = elements.length,\n
            oelements, olen, max, i;\n
\n
        oelements = other.elements.slice(\n
            (other.elements.length && other.elements[0].value === "&") ? 1 : 0);\n
        olen = oelements.length;\n
        max = Math.min(len, olen);\n
\n
        if (olen === 0 || len < olen) {\n
            return 0;\n
        } else {\n
            for (i = 0; i < max; i++) {\n
                if (elements[i].value !== oelements[i].value) {\n
                    return 0;\n
                }\n
            }\n
        }\n
        return max; // return number of matched selectors \n
    },\n
    eval: function (env) {\n
        var evaldCondition = this.condition && this.condition.eval(env);\n
\n
        return this.createDerived(this.elements.map(function (e) {\n
            return e.eval(env);\n
        }), this.extendList.map(function(extend) {\n
            return extend.eval(env);\n
        }), evaldCondition);\n
    },\n
    genCSS: function (env, output) {\n
        var i, element;\n
        if ((!env || !env.firstSelector) && this.elements[0].combinator.value === "") {\n
            output.add(\' \', this.currentFileInfo, this.index);\n
        }\n
        if (!this._css) {\n
            //TODO caching? speed comparison?\n
            for(i = 0; i < this.elements.length; i++) {\n
                element = this.elements[i];\n
                element.genCSS(env, output);\n
            }\n
        }\n
    },\n
    toCSS: tree.toCSS,\n
    markReferenced: function () {\n
        this.isReferenced = true;\n
    },\n
    getIsReferenced: function() {\n
        return !this.currentFileInfo.reference || this.isReferenced;\n
    },\n
    getIsOutput: function() {\n
        return this.evaldCondition;\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.UnicodeDescriptor = function (value) {\n
    this.value = value;\n
};\n
tree.UnicodeDescriptor.prototype = {\n
    type: "UnicodeDescriptor",\n
    genCSS: function (env, output) {\n
        output.add(this.value);\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function () { return this; }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.URL = function (val, currentFileInfo) {\n
    this.value = val;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.URL.prototype = {\n
    type: "Url",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    genCSS: function (env, output) {\n
        output.add("url(");\n
        this.value.genCSS(env, output);\n
        output.add(")");\n
    },\n
    toCSS: tree.toCSS,\n
    eval: function (ctx) {\n
        var val = this.value.eval(ctx), rootpath;\n
\n
        // Add the base path if the URL is relative\n
        rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;\n
        if (rootpath && typeof val.value === "string" && ctx.isPathRelative(val.value)) {\n
            if (!val.quote) {\n
                rootpath = rootpath.replace(/[\\(\\)\'"\\s]/g, function(match) { return "\\\\"+match; });\n
            }\n
            val.value = rootpath + val.value;\n
        }\n
\n
        val.value = ctx.normalizePath(val.value);\n
\n
        return new(tree.URL)(val, null);\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Value = function (value) {\n
    this.value = value;\n
};\n
tree.Value.prototype = {\n
    type: "Value",\n
    accept: function (visitor) {\n
        this.value = visitor.visit(this.value);\n
    },\n
    eval: function (env) {\n
        if (this.value.length === 1) {\n
            return this.value[0].eval(env);\n
        } else {\n
            return new(tree.Value)(this.value.map(function (v) {\n
                return v.eval(env);\n
            }));\n
        }\n
    },\n
    genCSS: function (env, output) {\n
        var i;\n
        for(i = 0; i < this.value.length; i++) {\n
            this.value[i].genCSS(env, output);\n
            if (i+1 < this.value.length) {\n
                output.add((env && env.compress) ? \',\' : \', \');\n
            }\n
        }\n
    },\n
    toCSS: tree.toCSS\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
tree.Variable = function (name, index, currentFileInfo) {\n
    this.name = name;\n
    this.index = index;\n
    this.currentFileInfo = currentFileInfo;\n
};\n
tree.Variable.prototype = {\n
    type: "Variable",\n
    eval: function (env) {\n
        var variable, v, name = this.name;\n
\n
        if (name.indexOf(\'@@\') === 0) {\n
            name = \'@\' + new(tree.Variable)(name.slice(1)).eval(env).value;\n
        }\n
        \n
        if (this.evaluating) {\n
            throw { type: \'Name\',\n
                    message: "Recursive variable definition for " + name,\n
                    filename: this.currentFileInfo.file,\n
                    index: this.index };\n
        }\n
        \n
        this.evaluating = true;\n
\n
        if (variable = tree.find(env.frames, function (frame) {\n
            if (v = frame.variable(name)) {\n
                return v.value.eval(env);\n
            }\n
        })) { \n
            this.evaluating = false;\n
            return variable;\n
        }\n
        else {\n
            throw { type: \'Name\',\n
                    message: "variable " + name + " is undefined",\n
                    filename: this.currentFileInfo.filename,\n
                    index: this.index };\n
        }\n
    }\n
};\n
\n
})(require(\'../tree\'));\n
\n
(function (tree) {\n
\n
    var parseCopyProperties = [\n
        \'paths\',            // option - unmodified - paths to search for imports on\n
        \'optimization\',     // option - optimization level (for the chunker)\n
        \'files\',            // list of files that have been imported, used for import-once\n
        \'contents\',         // browser-only, contents of all the files\n
        \'relativeUrls\',     // option - whether to adjust URL\'s to be relative\n
        \'rootpath\',         // option - rootpath to append to URL\'s\n
        \'strictImports\',    // option -\n
        \'insecure\',         // option - whether to allow imports from insecure ssl hosts\n
        \'dumpLineNumbers\',  // option - whether to dump line numbers\n
        \'compress\',         // option - whether to compress\n
        \'processImports\',   // option - whether to process imports. if false then imports will not be imported\n
        \'syncImport\',       // option - whether to import synchronously\n
        \'javascriptEnabled\',// option - whether JavaScript is enabled. if undefined, defaults to true\n
        \'mime\',             // browser only - mime type for sheet import\n
        \'useFileCache\',     // browser only - whether to use the per file session cache\n
        \'currentFileInfo\'   // information about the current file - for error reporting and importing and making urls relative etc.\n
    ];\n
\n
    //currentFileInfo = {\n
    //  \'relativeUrls\' - option - whether to adjust URL\'s to be relative\n
    //  \'filename\' - full resolved filename of current file\n
    //  \'rootpath\' - path to append to normal URLs for this node\n
    //  \'currentDirectory\' - path to the current file, absolute\n
    //  \'rootFilename\' - filename of the base file\n
    //  \'entryPath\' - absolute path to the entry file\n
    //  \'reference\' - whether the file should not be output and only output parts that are referenced\n
\n
    tree.parseEnv = function(options) {\n
        copyFromOriginal(options, this, parseCopyProperties);\n
\n
        if (!this.contents) { this.contents = {}; }\n
        if (!this.files) { this.files = {}; }\n
\n
        if (!this.currentFileInfo) {\n
            var filename = (options && options.filename) || "input";\n
            var entryPath = filename.replace(/[^\\/\\\\]*$/, "");\n
            if (options) {\n
                options.filename = null;\n
            }\n
            this.currentFileInfo = {\n
                filename: filename,\n
                relativeUrls: this.relativeUrls,\n
                rootpath: (options && options.rootpath) || "",\n
                currentDirectory: entryPath,\n
                entryPath: entryPath,\n
                rootFilename: filename\n
            };\n
        }\n
    };\n
\n
    var evalCopyProperties = [\n
        \'silent\',      // whether to swallow errors and warnings\n
        \'verbose\',     // whether to log more activity\n
        \'compr

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAQ=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="4" aka="AAAAAAAAAAQ=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

ess\',    // whether to compress\n
        \'yuicompress\', // whether to compress with the outside tool yui compressor\n
        \'ieCompat\',    // whether to enforce IE compatibility (IE8 data-uri)\n
        \'strictMath\',  // whether math has to be within parenthesis\n
        \'strictUnits\', // whether units need to evaluate correctly\n
        \'cleancss\',    // whether to compress with clean-css\n
        \'sourceMap\',   // whether to output a source map\n
        \'importMultiple\'// whether we are currently importing multiple copies\n
        ];\n
\n
    tree.evalEnv = function(options, frames) {\n
        copyFromOriginal(options, this, evalCopyProperties);\n
\n
        this.frames = frames || [];\n
    };\n
\n
    tree.evalEnv.prototype.inParenthesis = function () {\n
        if (!this.parensStack) {\n
            this.parensStack = [];\n
        }\n
        this.parensStack.push(true);\n
    };\n
\n
    tree.evalEnv.prototype.outOfParenthesis = function () {\n
        this.parensStack.pop();\n
    };\n
\n
    tree.evalEnv.prototype.isMathOn = function () {\n
        return this.strictMath ? (this.parensStack && this.parensStack.length) : true;\n
    };\n
\n
    tree.evalEnv.prototype.isPathRelative = function (path) {\n
        return !/^(?:[a-z-]+:|\\/)/.test(path);\n
    };\n
\n
    tree.evalEnv.prototype.normalizePath = function( path ) {\n
        var\n
          segments = path.split("/").reverse(),\n
          segment;\n
\n
        path = [];\n
        while (segments.length !== 0 ) {\n
            segment = segments.pop();\n
            switch( segment ) {\n
                case ".":\n
                    break;\n
                case "..":\n
                    if ((path.length === 0) || (path[path.length - 1] === "..")) {\n
                        path.push( segment );\n
                    } else {\n
                        path.pop();\n
                    }\n
                    break;\n
                default:\n
                    path.push( segment );\n
                    break;\n
            }\n
        }\n
\n
        return path.join("/");\n
    };\n
\n
    //todo - do the same for the toCSS env\n
    //tree.toCSSEnv = function (options) {\n
    //};\n
\n
    var copyFromOriginal = function(original, destination, propertiesToCopy) {\n
        if (!original) { return; }\n
\n
        for(var i = 0; i < propertiesToCopy.length; i++) {\n
            if (original.hasOwnProperty(propertiesToCopy[i])) {\n
                destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n
            }\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
\n
(function (tree) {\n
\n
    tree.visitor = function(implementation) {\n
        this._implementation = implementation;\n
    };\n
\n
    tree.visitor.prototype = {\n
        visit: function(node) {\n
\n
            if (node instanceof Array) {\n
                return this.visitArray(node);\n
            }\n
\n
            if (!node || !node.type) {\n
                return node;\n
            }\n
\n
            var funcName = "visit" + node.type,\n
                func = this._implementation[funcName],\n
                visitArgs, newNode;\n
            if (func) {\n
                visitArgs = {visitDeeper: true};\n
                newNode = func.call(this._implementation, node, visitArgs);\n
                if (this._implementation.isReplacing) {\n
                    node = newNode;\n
                }\n
            }\n
            if ((!visitArgs || visitArgs.visitDeeper) && node && node.accept) {\n
                node.accept(this);\n
            }\n
            funcName = funcName + "Out";\n
            if (this._implementation[funcName]) {\n
                this._implementation[funcName](node);\n
            }\n
            return node;\n
        },\n
        visitArray: function(nodes) {\n
            var i, newNodes = [];\n
            for(i = 0; i < nodes.length; i++) {\n
                var evald = this.visit(nodes[i]);\n
                if (evald instanceof Array) {\n
                    evald = this.flatten(evald);\n
                    newNodes = newNodes.concat(evald);\n
                } else {\n
                    newNodes.push(evald);\n
                }\n
            }\n
            if (this._implementation.isReplacing) {\n
                return newNodes;\n
            }\n
            return nodes;\n
        },\n
        doAccept: function (node) {\n
            node.accept(this);\n
        },\n
        flatten: function(arr, master) {\n
            return arr.reduce(this.flattenReduce.bind(this), master || []);\n
        },\n
        flattenReduce: function(sum, element) {\n
            if (element instanceof Array) {\n
                sum = this.flatten(element, sum);\n
            } else {\n
                sum.push(element);\n
            }\n
            return sum;\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
(function (tree) {\n
    tree.importVisitor = function(importer, finish, evalEnv) {\n
        this._visitor = new tree.visitor(this);\n
        this._importer = importer;\n
        this._finish = finish;\n
        this.env = evalEnv || new tree.evalEnv();\n
        this.importCount = 0;\n
    };\n
\n
    tree.importVisitor.prototype = {\n
        isReplacing: true,\n
        run: function (root) {\n
            var error;\n
            try {\n
                // process the contents\n
                this._visitor.visit(root);\n
            }\n
            catch(e) {\n
                error = e;\n
            }\n
\n
            this.isFinished = true;\n
\n
            if (this.importCount === 0) {\n
                this._finish(error);\n
            }\n
        },\n
        visitImport: function (importNode, visitArgs) {\n
            var importVisitor = this,\n
                evaldImportNode,\n
                inlineCSS = importNode.options.inline;\n
\n
            if (!importNode.css || inlineCSS) {\n
\n
                try {\n
                    evaldImportNode = importNode.evalForImport(this.env);\n
                } catch(e){\n
                    if (!e.filename) { e.index = importNode.index; e.filename = importNode.currentFileInfo.filename; }\n
                    // attempt to eval properly and treat as css\n
                    importNode.css = true;\n
                    // if that fails, this error will be thrown\n
                    importNode.error = e;\n
                }\n
\n
                if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n
                    importNode = evaldImportNode;\n
                    this.importCount++;\n
                    var env = new tree.evalEnv(this.env, this.env.frames.slice(0));\n
\n
                    if (importNode.options.multiple) {\n
                        env.importMultiple = true;\n
                    }\n
\n
                    this._importer.push(importNode.getPath(), importNode.currentFileInfo, importNode.options, function (e, root, imported, fullPath) {\n
                        if (e && !e.filename) { e.index = importNode.index; e.filename = importNode.currentFileInfo.filename; }\n
\n
                        if (imported && !env.importMultiple) { importNode.skip = imported; }\n
\n
                        var subFinish = function(e) {\n
                            importVisitor.importCount--;\n
\n
                            if (importVisitor.importCount === 0 && importVisitor.isFinished) {\n
                                importVisitor._finish(e);\n
                            }\n
                        };\n
\n
                        if (root) {\n
                            importNode.root = root;\n
                            importNode.importedFilename = fullPath;\n
                            if (!inlineCSS && !importNode.skip) {\n
                                new(tree.importVisitor)(importVisitor._importer, subFinish, env)\n
                                    .run(root);\n
                                return;\n
                            }\n
                        }\n
\n
                        subFinish();\n
                    });\n
                }\n
            }\n
            visitArgs.visitDeeper = false;\n
            return importNode;\n
        },\n
        visitRule: function (ruleNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
            return ruleNode;\n
        },\n
        visitDirective: function (directiveNode, visitArgs) {\n
            this.env.frames.unshift(directiveNode);\n
            return directiveNode;\n
        },\n
        visitDirectiveOut: function (directiveNode) {\n
            this.env.frames.shift();\n
        },\n
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n
            this.env.frames.unshift(mixinDefinitionNode);\n
            return mixinDefinitionNode;\n
        },\n
        visitMixinDefinitionOut: function (mixinDefinitionNode) {\n
            this.env.frames.shift();\n
        },\n
        visitRuleset: function (rulesetNode, visitArgs) {\n
            this.env.frames.unshift(rulesetNode);\n
            return rulesetNode;\n
        },\n
        visitRulesetOut: function (rulesetNode) {\n
            this.env.frames.shift();\n
        },\n
        visitMedia: function (mediaNode, visitArgs) {\n
            this.env.frames.unshift(mediaNode.ruleset);\n
            return mediaNode;\n
        },\n
        visitMediaOut: function (mediaNode) {\n
            this.env.frames.shift();\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
(function (tree) {\n
    tree.joinSelectorVisitor = function() {\n
        this.contexts = [[]];\n
        this._visitor = new tree.visitor(this);\n
    };\n
\n
    tree.joinSelectorVisitor.prototype = {\n
        run: function (root) {\n
            return this._visitor.visit(root);\n
        },\n
        visitRule: function (ruleNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
\n
        visitRuleset: function (rulesetNode, visitArgs) {\n
            var context = this.contexts[this.contexts.length - 1];\n
            var paths = [];\n
            this.contexts.push(paths);\n
\n
            if (! rulesetNode.root) {\n
                rulesetNode.selectors = rulesetNode.selectors.filter(function(selector) { return selector.getIsOutput(); });\n
                if (rulesetNode.selectors.length === 0) {\n
                    rulesetNode.rules.length = 0;\n
                }\n
                rulesetNode.joinSelectors(paths, context, rulesetNode.selectors);\n
                rulesetNode.paths = paths;\n
            }\n
        },\n
        visitRulesetOut: function (rulesetNode) {\n
            this.contexts.length = this.contexts.length - 1;\n
        },\n
        visitMedia: function (mediaNode, visitArgs) {\n
            var context = this.contexts[this.contexts.length - 1];\n
            mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
(function (tree) {\n
    tree.toCSSVisitor = function(env) {\n
        this._visitor = new tree.visitor(this);\n
        this._env = env;\n
    };\n
\n
    tree.toCSSVisitor.prototype = {\n
        isReplacing: true,\n
        run: function (root) {\n
            return this._visitor.visit(root);\n
        },\n
\n
        visitRule: function (ruleNode, visitArgs) {\n
            if (ruleNode.variable) {\n
                return [];\n
            }\n
            return ruleNode;\n
        },\n
\n
        visitMixinDefinition: function (mixinNode, visitArgs) {\n
            return [];\n
        },\n
\n
        visitExtend: function (extendNode, visitArgs) {\n
            return [];\n
        },\n
\n
        visitComment: function (commentNode, visitArgs) {\n
            if (commentNode.isSilent(this._env)) {\n
                return [];\n
            }\n
            return commentNode;\n
        },\n
\n
        visitMedia: function(mediaNode, visitArgs) {\n
            mediaNode.accept(this._visitor);\n
            visitArgs.visitDeeper = false;\n
\n
            if (!mediaNode.rules.length) {\n
                return [];\n
            }\n
            return mediaNode;\n
        },\n
\n
        visitDirective: function(directiveNode, visitArgs) {\n
            if (directiveNode.currentFileInfo.reference && !directiveNode.isReferenced) {\n
                return [];\n
            }\n
            if (directiveNode.name === "@charset") {\n
                // Only output the debug info together with subsequent @charset definitions\n
                // a comment (or @media statement) before the actual @charset directive would\n
                // be considered illegal css as it has to be on the first line\n
                if (this.charset) {\n
                    if (directiveNode.debugInfo) {\n
                        var comment = new tree.Comment("/* " + directiveNode.toCSS(this._env).replace(/\\n/g, "")+" */\\n");\n
                        comment.debugInfo = directiveNode.debugInfo;\n
                        return this._visitor.visit(comment);\n
                    }\n
                    return [];\n
                }\n
                this.charset = true;\n
            }\n
            return directiveNode;\n
        },\n
\n
        checkPropertiesInRoot: function(rules) {\n
            var ruleNode;\n
            for(var i = 0; i < rules.length; i++) {\n
                ruleNode = rules[i];\n
                if (ruleNode instanceof tree.Rule && !ruleNode.variable) {\n
                    throw { message: "properties must be inside selector blocks, they cannot be in the root.",\n
                        index: ruleNode.index, filename: ruleNode.currentFileInfo ? ruleNode.currentFileInfo.filename : null};\n
                }\n
            }\n
        },\n
\n
        visitRuleset: function (rulesetNode, visitArgs) {\n
            var rule, rulesets = [];\n
            if (rulesetNode.firstRoot) {\n
                this.checkPropertiesInRoot(rulesetNode.rules);\n
            }\n
            if (! rulesetNode.root) {\n
\n
                rulesetNode.paths = rulesetNode.paths\n
                    .filter(function(p) {\n
                        var i;\n
                        if (p[0].elements[0].combinator.value === \' \') {\n
                            p[0].elements[0].combinator = new(tree.Combinator)(\'\');\n
                        }\n
                        for(i = 0; i < p.length; i++) {\n
                            if (p[i].getIsReferenced() && p[i].getIsOutput()) {\n
                                return true;\n
                            }\n
                            return false;\n
                        }\n
                    });\n
\n
                // Compile rules and rulesets\n
                for (var i = 0; i < rulesetNode.rules.length; i++) {\n
                    rule = rulesetNode.rules[i];\n
\n
                    if (rule.rules) {\n
                        // visit because we are moving them out from being a child\n
                        rulesets.push(this._visitor.visit(rule));\n
                        rulesetNode.rules.splice(i, 1);\n
                        i--;\n
                        continue;\n
                    }\n
                }\n
                // accept the visitor to remove rules and refactor itself\n
                // then we can decide now whether we want it or not\n
                if (rulesetNode.rules.length > 0) {\n
                    rulesetNode.accept(this._visitor);\n
                }\n
                visitArgs.visitDeeper = false;\n
\n
                this._mergeRules(rulesetNode.rules);\n
                this._removeDuplicateRules(rulesetNode.rules);\n
\n
                // now decide whether we keep the ruleset\n
                if (rulesetNode.rules.length > 0 && rulesetNode.paths.length > 0) {\n
                    rulesets.splice(0, 0, rulesetNode);\n
                }\n
            } else {\n
                rulesetNode.accept(this._visitor);\n
                visitArgs.visitDeeper = false;\n
                if (rulesetNode.firstRoot || rulesetNode.rules.length > 0) {\n
                    rulesets.splice(0, 0, rulesetNode);\n
                }\n
            }\n
            if (rulesets.length === 1) {\n
                return rulesets[0];\n
            }\n
            return rulesets;\n
        },\n
\n
        _removeDuplicateRules: function(rules) {\n
            // remove duplicates\n
            var ruleCache = {},\n
                ruleList, rule, i;\n
            for(i = rules.length - 1; i >= 0 ; i--) {\n
                rule = rules[i];\n
                if (rule instanceof tree.Rule) {\n
                    if (!ruleCache[rule.name]) {\n
                        ruleCache[rule.name] = rule;\n
                    } else {\n
                        ruleList = ruleCache[rule.name];\n
                        if (ruleList instanceof tree.Rule) {\n
                            ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._env)];\n
                        }\n
                        var ruleCSS = rule.toCSS(this._env);\n
                        if (ruleList.indexOf(ruleCSS) !== -1) {\n
                            rules.splice(i, 1);\n
                        } else {\n
                            ruleList.push(ruleCSS);\n
                        }\n
                    }\n
                }\n
            }\n
        },\n
\n
        _mergeRules: function (rules) {\n
            var groups = {},\n
                parts,\n
                rule,\n
                key;\n
\n
            for (var i = 0; i < rules.length; i++) {\n
                rule = rules[i];\n
\n
                if ((rule instanceof tree.Rule) && rule.merge) {\n
                    key = [rule.name,\n
                        rule.important ? "!" : ""].join(",");\n
\n
                    if (!groups[key]) {\n
                        parts = groups[key] = [];\n
                    } else {\n
                        rules.splice(i--, 1);\n
                    }\n
\n
                    parts.push(rule);\n
                }\n
            }\n
\n
            Object.keys(groups).map(function (k) {\n
                parts = groups[k];\n
\n
                if (parts.length > 1) {\n
                    rule = parts[0];\n
\n
                    rule.value = new (tree.Value)(parts.map(function (p) {\n
                        return p.value;\n
                    }));\n
                }\n
            });\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
(function (tree) {\n
    /*jshint loopfunc:true */\n
\n
    tree.extendFinderVisitor = function() {\n
        this._visitor = new tree.visitor(this);\n
        this.contexts = [];\n
        this.allExtendsStack = [[]];\n
    };\n
\n
    tree.extendFinderVisitor.prototype = {\n
        run: function (root) {\n
            root = this._visitor.visit(root);\n
            root.allExtends = this.allExtendsStack[0];\n
            return root;\n
        },\n
        visitRule: function (ruleNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitRuleset: function (rulesetNode, visitArgs) {\n
\n
            if (rulesetNode.root) {\n
                return;\n
            }\n
\n
            var i, j, extend, allSelectorsExtendList = [], extendList;\n
\n
            // get &:extend(.a); rules which apply to all selectors in this ruleset\n
            for(i = 0; i < rulesetNode.rules.length; i++) {\n
                if (rulesetNode.rules[i] instanceof tree.Extend) {\n
                    allSelectorsExtendList.push(rulesetNode.rules[i]);\n
                    rulesetNode.extendOnEveryPath = true;\n
                }\n
            }\n
\n
            // now find every selector and apply the extends that apply to all extends\n
            // and the ones which apply to an individual extend\n
            for(i = 0; i < rulesetNode.paths.length; i++) {\n
                var selectorPath = rulesetNode.paths[i],\n
                    selector = selectorPath[selectorPath.length-1];\n
                extendList = selector.extendList.slice(0).concat(allSelectorsExtendList).map(function(allSelectorsExtend) {\n
                    return allSelectorsExtend.clone();\n
                });\n
                for(j = 0; j < extendList.length; j++) {\n
                    this.foundExtends = true;\n
                    extend = extendList[j];\n
                    extend.findSelfSelectors(selectorPath);\n
                    extend.ruleset = rulesetNode;\n
                    if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }\n
                    this.allExtendsStack[this.allExtendsStack.length-1].push(extend);\n
                }\n
            }\n
\n
            this.contexts.push(rulesetNode.selectors);\n
        },\n
        visitRulesetOut: function (rulesetNode) {\n
            if (!rulesetNode.root) {\n
                this.contexts.length = this.contexts.length - 1;\n
            }\n
        },\n
        visitMedia: function (mediaNode, visitArgs) {\n
            mediaNode.allExtends = [];\n
            this.allExtendsStack.push(mediaNode.allExtends);\n
        },\n
        visitMediaOut: function (mediaNode) {\n
            this.allExtendsStack.length = this.allExtendsStack.length - 1;\n
        },\n
        visitDirective: function (directiveNode, visitArgs) {\n
            directiveNode.allExtends = [];\n
            this.allExtendsStack.push(directiveNode.allExtends);\n
        },\n
        visitDirectiveOut: function (directiveNode) {\n
            this.allExtendsStack.length = this.allExtendsStack.length - 1;\n
        }\n
    };\n
\n
    tree.processExtendsVisitor = function() {\n
        this._visitor = new tree.visitor(this);\n
    };\n
\n
    tree.processExtendsVisitor.prototype = {\n
        run: function(root) {\n
            var extendFinder = new tree.extendFinderVisitor();\n
            extendFinder.run(root);\n
            if (!extendFinder.foundExtends) { return root; }\n
            root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));\n
            this.allExtendsStack = [root.allExtends];\n
            return this._visitor.visit(root);\n
        },\n
        doExtendChaining: function (extendsList, extendsListTarget, iterationCount) {\n
            //\n
            // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering and pasting\n
            // the selector we would do normally, but we are also adding an extend with the same target selector\n
            // this means this new extend can then go and alter other extends\n
            //\n
            // this method deals with all the chaining work - without it, extend is flat and doesn\'t work on other extend selectors\n
            // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already processed if\n
            // we look at each selector at a time, as is done in visitRuleset\n
\n
            var extendIndex, targetExtendIndex, matches, extendsToAdd = [], newSelector, extendVisitor = this, selectorPath, extend, targetExtend, newExtend;\n
\n
            iterationCount = iterationCount || 0;\n
\n
            //loop through comparing every extend with every target extend.\n
            // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n
            // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n
            // and the second is the target.\n
            // the seperation into two lists allows us to process a subset of chains with a bigger set, as is the\n
            // case when processing media queries\n
            for(extendIndex = 0; extendIndex < extendsList.length; extendIndex++){\n
                for(targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++){\n
\n
                    extend = extendsList[extendIndex];\n
                    targetExtend = extendsListTarget[targetExtendIndex];\n
\n
                    // look for circular references\n
                    if (this.inInheritanceChain(targetExtend, extend)) { continue; }\n
\n
                    // find a match in the target extends self selector (the bit before :extend)\n
                    selectorPath = [targetExtend.selfSelectors[0]];\n
                    matches = extendVisitor.findMatch(extend, selectorPath);\n
\n
                    if (matches.length) {\n
\n
                        // we found a match, so for each self selector..\n
                        extend.selfSelectors.forEach(function(selfSelector) {\n
\n
                            // process the extend as usual\n
                            newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector);\n
\n
                            // but now we create a new extend from it\n
                            newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0);\n
                            newExtend.selfSelectors = newSelector;\n
\n
                            // add the extend onto the list of extends for that selector\n
                            newSelector[newSelector.length-1].extendList = [newExtend];\n
\n
                            // record that we need to add it.\n
                            extendsToAdd.push(newExtend);\n
                            newExtend.ruleset = targetExtend.ruleset;\n
\n
                            //remember its parents for circular references\n
                            newExtend.parents = [targetExtend, extend];\n
\n
                            // only process the selector once.. if we have :extend(.a,.b) then multiple\n
                            // extends will look at the same selector path, so when extending\n
                            // we know that any others will be duplicates in terms of what is added to the css\n
                            if (targetExtend.firstExtendOnThisSelectorPath) {\n
                                newExtend.firstExtendOnThisSelectorPath = true;\n
                                targetExtend.ruleset.paths.push(newSelector);\n
                            }\n
                        });\n
                    }\n
                }\n
            }\n
\n
            if (extendsToAdd.length) {\n
                // try to detect circular references to stop a stack overflow.\n
                // may no longer be needed.\n
                this.extendChainCount++;\n
                if (iterationCount > 100) {\n
                    var selectorOne = "{unable to calculate}";\n
                    var selectorTwo = "{unable to calculate}";\n
                    try\n
                    {\n
                        selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();\n
                        selectorTwo = extendsToAdd[0].selector.toCSS();\n
                    }\n
                    catch(e) {}\n
                    throw {message: "extend circular reference detected. One of the circular extends is currently:"+selectorOne+":extend(" + selectorTwo+")"};\n
                }\n
\n
                // now process the new extends on the existing rules so that we can handle a extending b extending c ectending d extending e...\n
                return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount+1));\n
            } else {\n
                return extendsToAdd;\n
            }\n
        },\n
        inInheritanceChain: function (possibleParent, possibleChild) {\n
            if (possibleParent === possibleChild) {\n
                return true;\n
            }\n
            if (possibleChild.parents) {\n
                if (this.inInheritanceChain(possibleParent, possibleChild.parents[0])) {\n
                    return true;\n
                }\n
                if (this.inInheritanceChain(possibleParent, possibleChild.parents[1])) {\n
                    return true;\n
                }\n
            }\n
            return false;\n
        },\n
        visitRule: function (ruleNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitSelector: function (selectorNode, visitArgs) {\n
            visitArgs.visitDeeper = false;\n
        },\n
        visitRuleset: function (rulesetNode, visitArgs) {\n
            if (rulesetNode.root) {\n
                return;\n
            }\n
            var matches, pathIndex, extendIndex, allExtends = this.allExtendsStack[this.allExtendsStack.length-1], selectorsToAdd = [], extendVisitor = this, selectorPath;\n
\n
            // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n
\n
            for(extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n
                for(pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n
\n
                    selectorPath = rulesetNode.paths[pathIndex];\n
\n
                    // extending extends happens initially, before the main pass\n
                    if (rulesetNode.extendOnEveryPath || selectorPath[selectorPath.length-1].extendList.length) { continue; }\n
\n
                    matches = this.findMatch(allExtends[extendIndex], selectorPath);\n
\n
                    if (matches.length) {\n
\n
                        allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {\n
                            selectorsToAdd.push(extendVisitor.extendSelector(matches, selectorPath, selfSelector));\n
                        });\n
                    }\n
                }\n
            }\n
            rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);\n
        },\n
        findMatch: function (extend, haystackSelectorPath) {\n
            //\n
            // look through the haystack selector path to try and find the needle - extend.selector\n
            // returns an array of selector matches that can then be replaced\n
            //\n
            var haystackSelectorIndex, hackstackSelector, hackstackElementIndex, haystackElement,\n
                targetCombinator, i,\n
                extendVisitor = this,\n
                needleElements = extend.selector.elements,\n
                potentialMatches = [], potentialMatch, matches = [];\n
\n
            // loop through the haystack elements\n
            for(haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {\n
                hackstackSelector = haystackSelectorPath[haystackSelectorIndex];\n
\n
                for(hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {\n
\n
                    haystackElement = hackstackSelector.elements[hackstackElementIndex];\n
\n
                    // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n
                    if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {\n
                        potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0, initialCombinator: haystackElement.combinator});\n
                    }\n
\n
                    for(i = 0; i < potentialMatches.length; i++) {\n
                        potentialMatch = potentialMatches[i];\n
\n
                        // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don\'t\n
                        // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to work out\n
                        // what the resulting combinator will be\n
                        targetCombinator = haystackElement.combinator.value;\n
                        if (targetCombinator === \'\' && hackstackElementIndex === 0) {\n
                            targetCombinator = \' \';\n
                        }\n
\n
                        // if we don\'t match, null our match to indicate failure\n
                        if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||\n
                            (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {\n
                            potentialMatch = null;\n
                        } else {\n
                            potentialMatch.matched++;\n
                        }\n
\n
                        // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n
                        if (potentialMatch) {\n
                            potentialMatch.finished = potentialMatch.matched === needleElements.length;\n
                            if (potentialMatch.finished &&\n
                                (!extend.allowAfter && (hackstackElementIndex+1 < hackstackSelector.elements.length || haystackSelectorIndex+1 < haystackSelectorPath.length))) {\n
                                potentialMatch = null;\n
                            }\n
                        }\n
                        // if null we remove, if not, we are still valid, so either push as a valid match or continue\n
                        if (potentialMatch) {\n
                            if (potentialMatch.finished) {\n
                                potentialMatch.length = needleElements.length;\n
                                potentialMatch.endPathIndex = haystackSelectorIndex;\n
                                potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match\n
                                potentialMatches.length = 0; // we don\'t allow matches to overlap, so start matching again\n
                                matches.push(potentialMatch);\n
                            }\n
                        } else {\n
                            potentialMatches.splice(i, 1);\n
                            i--;\n
                        }\n
                    }\n
                }\n
            }\n
            return matches;\n
        },\n
        isElementValuesEqual: function(elementValue1, elementValue2) {\n
            if (typeof elementValue1 === "string" || typeof elementValue2 === "string") {\n
                return elementValue1 === elementValue2;\n
            }\n
            if (elementValue1 instanceof tree.Attribute) {\n
                if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {\n
                    return false;\n
                }\n
                if (!elementValue1.value || !elementValue2.value) {\n
                    if (elementValue1.value || elementValue2.value) {\n
                        return false;\n
                    }\n
                    return true;\n
                }\n
                elementValue1 = elementValue1.value.value || elementValue1.value;\n
                elementValue2 = elementValue2.value.value || elementValue2.value;\n
                return elementValue1 === elementValue2;\n
            }\n
            elementValue1 = elementValue1.value;\n
            elementValue2 = elementValue2.value;\n
            if (elementValue1 instanceof tree.Selector) {\n
                if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {\n
                    return false;\n
                }\n
                for(var i = 0; i <elementValue1.elements.length; i++) {\n
                    if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {\n
                        if (i !== 0 || (elementValue1.elements[i].combinator.value || \' \') !== (elementValue2.elements[i].combinator.value || \' \')) {\n
                            return false;\n
                        }\n
                    }\n
                    if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {\n
                        return false;\n
                    }\n
                }\n
                return true;\n
            }\n
            return false;\n
        },\n
        extendSelector:function (matches, selectorPath, replacementSelector) {\n
\n
            //for a set of matches, replace each match with the replacement selector\n
\n
            var currentSelectorPathIndex = 0,\n
                currentSelectorPathElementIndex = 0,\n
                path = [],\n
                matchIndex,\n
                selector,\n
                firstElement,\n
                match,\n
                newElements;\n
\n
            for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n
                match = matches[matchIndex];\n
                selector = selectorPath[match.pathIndex];\n
                firstElement = new tree.Element(\n
                    match.initialCombinator,\n
                    replacementSelector.elements[0].value,\n
                    replacementSelector.elements[0].index,\n
                    replacementSelector.elements[0].currentFileInfo\n
                );\n
\n
                if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {\n
                    path[path.length - 1].elements = path[path.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n
                    currentSelectorPathElementIndex = 0;\n
                    currentSelectorPathIndex++;\n
                }\n
\n
                newElements = selector.elements\n
                    .slice(currentSelectorPathElementIndex, match.index)\n
                    .concat([firstElement])\n
                    .concat(replacementSelector.elements.slice(1));\n
\n
                if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n
                    path[path.length - 1].elements =\n
                        path[path.length - 1].elements.concat(newElements);\n
                } else {\n
                    path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));\n
\n
                    path.push(new tree.Selector(\n
                        newElements\n
                    ));\n
                }\n
                currentSelectorPathIndex = match.endPathIndex;\n
                currentSelectorPathElementIndex = match.endPathElementIndex;\n
                if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {\n
                    currentSelectorPathElementIndex = 0;\n
                    currentSelectorPathIndex++;\n
                }\n
            }\n
\n
            if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {\n
                path[path.length - 1].elements = path[path.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n
                currentSelectorPathIndex++;\n
            }\n
\n
            path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));\n
\n
            return path;\n
        },\n
        visitRulesetOut: function (rulesetNode) {\n
        },\n
        visitMedia: function (mediaNode, visitArgs) {\n
            var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length-1]);\n
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));\n
            this.allExtendsStack.push(newAllExtends);\n
        },\n
        visitMediaOut: function (mediaNode) {\n
            this.allExtendsStack.length = this.allExtendsStack.length - 1;\n
        },\n
        visitDirective: function (directiveNode, visitArgs) {\n
            var newAllExtends = directiveNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length-1]);\n
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, directiveNode.allExtends));\n
            this.allExtendsStack.push(newAllExtends);\n
        },\n
        visitDirectiveOut: function (directiveNode) {\n
            this.allExtendsStack.length = this.allExtendsStack.length - 1;\n
        }\n
    };\n
\n
})(require(\'./tree\'));\n
\n
(function (tree) {\n
\n
    tree.sourceMapOutput = function (options) {\n
        this._css = [];\n
        this._rootNode = options.rootNode;\n
        this._writeSourceMap = options.writeSourceMap;\n
        this._contentsMap = options.contentsMap;\n
        this._sourceMapFilename = options.sourceMapFilename;\n
        this._outputFilename = options.outputFilename;\n
        this._sourceMapURL = options.sourceMapURL;\n
        this._sourceMapBasepath = options.sourceMapBasepath;\n
        this._sourceMapRootpath = options.sourceMapRootpath;\n
        this._outputSourceFiles = options.outputSourceFiles;\n
        this._sourceMapGeneratorConstructor = options.sourceMapGenerator || require("source-map").SourceMapGenerator;\n
\n
        if (this._sourceMapRootpath && this._sourceMapRootpath.charAt(this._sourceMapRootpath.length-1) !== \'/\') {\n
            this._sourceMapRootpath += \'/\';\n
        }\n
\n
        this._lineNumber = 0;\n
        this._column = 0;\n
    };\n
\n
    tree.sourceMapOutput.prototype.normalizeFilename = function(filename) {\n
        if (this._sourceMapBasepath && filename.indexOf(this._sourceMapBasepath) === 0) {\n
             filename = filename.substring(this._sourceMapBasepath.length);\n
             if (filename.charAt(0) === \'\\\\\' || filename.charAt(0) === \'/\') {\n
                filename = filename.substring(1);\n
             }\n
        }\n
        return (this._sourceMapRootpath || "") + filename.replace(/\\\\/g, \'/\');\n
    };\n
\n
    tree.sourceMapOutput.prototype.add = function(chunk, fileInfo, index, mapLines) {\n
\n
        //ignore adding empty strings\n
        if (!chunk) {\n
            return;\n
        }\n
\n
        var lines,\n
            sourceLines,\n
            columns,\n
            sourceColumns,\n
            i;\n
\n
        if (fileInfo) {\n
            var inputSource = this._contentsMap[fileInfo.filename].substring(0, index);\n
            sourceLines = inputSource.split("\\n");\n
            sourceColumns = sourceLines[sourceLines.length-1];\n
        }\n
\n
        lines = chunk.split("\\n");\n
        columns = lines[lines.length-1];\n
\n
        if (fileInfo) {\n
            if (!mapLines) {\n
                this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},\n
                    original: { line: sourceLines.length, column: sourceColumns.length},\n
                    source: this.normalizeFilename(fileInfo.filename)});\n
            } else {\n
                for(i = 0; i < lines.length; i++) {\n
                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},\n
                        original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},\n
                        source: this.normalizeFilename(fileInfo.filename)});\n
                }\n
            }\n
        }\n
\n
        if (lines.length === 1) {\n
            this._column += columns.length;\n
        } else {\n
            this._lineNumber += lines.length - 1;\n
            this._column = columns.length;\n
        }\n
\n
        this._css.push(chunk);\n
    };\n
\n
    tree.sourceMapOutput.prototype.isEmpty = function() {\n
        return this._css.length === 0;\n
    };\n
\n
    tree.sourceMapOutput.prototype.toCSS = function(env) {\n
        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n
\n
        if (this._outputSourceFiles) {\n
            for(var filename in this._contentsMap) {\n
                this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), this._contentsMap[filename]);\n
            }\n
        }\n
\n
        this._rootNode.genCSS(env, this);\n
\n
        if (this._css.length > 0) {\n
            var sourceMapURL,\n
                sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n
\n
            if (this._sourceMapURL) {\n
                sourceMapURL = this._sourceMapURL;\n
            } else if (this._sourceMapFilename) {\n
                sourceMapURL = this.normalizeFilename(this._sourceMapFilename);\n
            }\n
\n
            if (this._writeSourceMap) {\n
                this._writeSourceMap(sourceMapContent);\n
            } else {\n
                sourceMapURL = "data:application/json," + encodeURIComponent(sourceMapContent);\n
            }\n
\n
            if (sourceMapURL) {\n
                this._css.push("/*# sourceMappingURL=" + sourceMapURL + " */");\n
            }\n
        }\n
\n
        return this._css.join(\'\');\n
    };\n
\n
})(require(\'./tree\'));\n
\n
//\n
// browser.js - client-side engine\n
//\n
/*global less, window, document, XMLHttpRequest, location */\n
\n
var isFileProtocol = /^(file|chrome(-extension)?|resource|qrc|app):/.test(location.protocol);\n
\n
less.env = less.env || (location.hostname == \'127.0.0.1\' ||\n
                        location.hostname == \'0.0.0.0\'   ||\n
                        location.hostname == \'localhost\' ||\n
                        (location.port &&\n
                          location.port.length > 0)      ||\n
                        isFileProtocol                   ? \'development\'\n
                                                         : \'production\');\n
\n
var logLevel = {\n
    info: 2,\n
    errors: 1,\n
    none: 0\n
};\n
\n
// The amount of logging in the javascript console.\n
// 2 - Information and errors\n
// 1 - Errors\n
// 0 - None\n
// Defaults to 2\n
less.logLevel = typeof(less.logLevel) != \'undefined\' ? less.logLevel : logLevel.info;\n
\n
// Load styles asynchronously (default: false)\n
//\n
// This is set to `false` by default, so that the body\n
// doesn\'t start loading before the stylesheets are parsed.\n
// Setting this to `true` can result in flickering.\n
//\n
less.async = less.async || false;\n
less.fileAsync = less.fileAsync || false;\n
\n
// Interval between watch polls\n
less.poll = less.poll || (isFileProtocol ? 1000 : 1500);\n
\n
//Setup user functions\n
if (less.functions) {\n
    for(var func in less.functions) {\n
        less.tree.functions[func] = less.functions[func];\n
   }\n
}\n
\n
var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(location.hash);\n
if (dumpLineNumbers) {\n
    less.dumpLineNumbers = dumpLineNumbers[1];\n
}\n
\n
var typePattern = /^text\\/(x-)?less$/;\n
var cache = null;\n
var fileCache = {};\n
var varsPre = "";\n
\n
function log(str, level) {\n
    if (less.env == \'development\' && typeof(console) !== \'undefined\' && less.logLevel >= level) {\n
        console.log(\'less: \' + str);\n
    }\n
}\n
\n
function extractId(href) {\n
    return href.replace(/^[a-z-]+:\\/+?[^\\/]+/, \'\' )  // Remove protocol & domain\n
        .replace(/^\\//,                 \'\' )  // Remove root /\n
        .replace(/\\.[a-zA-Z]+$/,        \'\' )  // Remove simple extension\n
        .replace(/[^\\.\\w-]+/g,          \'-\')  // Replace illegal characters\n
        .replace(/\\./g,                 \':\'); // Replace dots with colons(for valid id)\n
}\n
\n
function errorConsole(e, rootHref) {\n
    var template = \'{line} {content}\';\n
    var filename = e.filename || rootHref;\n
    var errors = [];\n
    var content = (e.type || "Syntax") + "Error: " + (e.message || \'There is an error in your .less file\') +\n
        " in " + filename + " ";\n
\n
    var errorline = function (e, i, classname) {\n
        if (e.extract[i] !== undefined) {\n
            errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n
                .replace(/\\{class\\}/, classname)\n
                .replace(/\\{content\\}/, e.extract[i]));\n
        }\n
    };\n
\n
    if (e.extract) {\n
        errorline(e, 0, \'\');\n
        errorline(e, 1, \'line\');\n
        errorline(e, 2, \'\');\n
        content += \'on line \' + e.line + \', column \' + (e.column + 1) + \':\\n\' +\n
            errors.join(\'\\n\');\n
    } else if (e.stack) {\n
        content += e.stack;\n
    }\n
    log(content, logLevel.errors);\n
}\n
\n
function createCSS(styles, sheet, lastModified) {\n
    // Strip the query-string\n
    var href = sheet.href || \'\';\n
\n
    // If there is no title set, use the filename, minus the extension\n
    var id = \'less:\' + (sheet.title || extractId(href));\n
\n
    // If this has already been inserted into the DOM, we may need to replace it\n
    var oldCss = document.getElementById(id);\n
    var keepOldCss = false;\n
\n
    // Create a new stylesheet node for insertion or (if necessary) replacement\n
    var css = document.createElement(\'style\');\n
    css.setAttribute(\'type\', \'text/css\');\n
    if (sheet.media) {\n
        css.setAttribute(\'media\', sheet.media);\n
    }\n
    css.id = id;\n
\n
    if (css.styleSheet) { // IE\n
        try {\n
            css.styleSheet.cssText = styles;\n
        } catch (e) {\n
            throw new(Error)("Couldn\'t reassign styleSheet.cssText.");\n
        }\n
    } else {\n
        css.appendChild(document.createTextNode(styles));\n
\n
        // If new contents match contents of oldCss, don\'t replace oldCss\n
        keepOldCss = (oldCss !== null && oldCss.childNodes.length > 0 && css.childNodes.length > 0 &&\n
            oldCss.firstChild.nodeValue === css.firstChild.nodeValue);\n
    }\n
\n
    var head = document.getElementsByTagName(\'head\')[0];\n
\n
    // If there is no oldCss, just append; otherwise, only append if we need\n
    // to replace oldCss with an updated stylesheet\n
    if (oldCss === null || keepOldCss === false) {\n
        var nextEl = sheet && sheet.nextSibling || null;\n
        if (nextEl) {\n
            nextEl.parentNode.insertBefore(css, nextEl);\n
        } else {\n
            head.appendChild(css);\n
        }\n
    }\n
    if (oldCss && keepOldCss === false) {\n
        oldCss.parentNode.removeChild(oldCss);\n
    }\n
\n
    // Don\'t update the local store if the file wasn\'t modified\n
    if (lastModified && cache) {\n
        log(\'saving \' + href + \' to cache.\', logLevel.info);\n
        try {\n
            cache.setItem(href, styles);\n
            cache.setItem(href + \':timestamp\', lastModified);\n
        } catch(e) {\n
            //TODO - could do with adding more robust error handling\n
            log(\'failed to save\', logLevel.errors);\n
        }\n
    }\n
}\n
\n
function errorHTML(e, rootHref) {\n
    var id = \'less-error-message:\' + extractId(rootHref || "");\n
    var template = \'<li><label>{line}</label><pre class="{class}">{content}</pre></li>\';\n
    var elem = document.createElement(\'div\'), timer, content, errors = [];\n
    var filename = e.filename || rootHref;\n
    var filenameNoPath = filename.match(/([^\\/]+(\\?.*)?)$/)[1];\n
\n
    elem.id        = id;\n
    elem.className = "less-error-message";\n
\n
    content = \'<h3>\'  + (e.type || "Syntax") + "Error: " + (e.message || \'There is an error in your .less file\') +\n
        \'</h3>\' + \'<p>in <a href="\' + filename   + \'">\' + filenameNoPath + "</a> ";\n
\n
    var errorline = function (e, i, classname) {\n
        if (e.extract[i] !== undefined) {\n
            errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n
                .replace(/\\{class\\}/, classname)\n
                .replace(/\\{content\\}/, e.extract[i]));\n
        }\n
    };\n
\n
    if (e.extract) {\n
        errorline(e, 0, \'\');\n
        errorline(e, 1, \'line\');\n
        errorline(e, 2, \'\');\n
        content += \'on line \' + e.line + \', column \' + (e.column + 1) + \':</p>\' +\n
            \'<ul>\' + errors.join(\'\') + \'</ul>\';\n
    } else if (e.stack) {\n
        content += \'<br/>\' + e.stack.split(\'\\n\').slice(1).join(\'<br/>\');\n
    }\n
    elem.innerHTML = content;\n
\n
    // CSS for error messages\n
    createCSS([\n
        \'.less-error-message ul, .less-error-message li {\',\n
        \'list-style-type: none;\',\n
        \'margin-right: 15px;\',\n
        \'padding: 4px 0;\',\n
        \'margin: 0;\',\n
        \'}\',\n
        \'.less-error-message label {\',\n
        \'font-size: 12px;\',\n
        \'margin-right: 15px;\',\n
        \'padding: 4px 0;\',\n
        \'color: #cc7777;\',\n
        \'}\',\n
        \'.less-error-message pre {\',\n
        \'color: #dd6666;\',\n
        \'padding: 4px 0;\',\n
        \'margin: 0;\',\n
        \'display: inline-block;\',\n
        \'}\',\n
        \'.less-error-message pre.line {\',\n
        \'color: #ff0000;\',\n
        \'}\',\n
        \'.less-error-message h3 {\',\n
        \'font-size: 20px;\',\n
        \'font-weight: bold;\',\n
        \'padding: 15px 0 5px 0;\',\n
        \'margin: 0;\',\n
        \'}\',\n
        \'.less-error-message a {\',\n
        \'color: #10a\',\n
        \'}\',\n
        \'.less-error-message .error {\',\n
        \'color: red;\',\n
        \'font-weight: bold;\',\n
        \'padding-bottom: 2px;\',\n
        \'border-bottom: 1px dashed red;\',\n
        \'}\'\n
    ].join(\'\\n\'), { title: \'error-message\' });\n
\n
    elem.style.cssText = [\n
        "font-family: Arial, sans-serif",\n
        "border: 1px solid #e00",\n
        "background-color: #eee",\n
        "border-radius: 5px",\n
        "-webkit-border-radius: 5px",\n
        "-moz-border-radius: 5px",\n
        "color: #e00",\n
        "padding: 15px",\n
        "margin-bottom: 15px"\n
    ].join(\';\');\n
\n
    if (less.env == \'development\') {\n
        timer = setInterval(function () {\n
            if (document.body) {\n
                if (document.getElementById(id)) {\n
                    document.body.replaceChild(elem, document.getElementById(id));\n
                } else {\n
                    document.body.insertBefore(elem, document.body.firstChild);\n
                }\n
                clearInterval(timer);\n
            }\n
        }, 10);\n
    }\n
}\n
\n
function error(e, rootHref) {\n
    if (!less.errorReporting || less.errorReporting === "html") {\n
        errorHTML(e, rootHref);\n
    } else if (less.errorReporting === "console") {\n
        errorConsole(e, rootHref);\n
    } else if (typeof less.errorReporting === \'function\') {\n
        less.errorReporting("add", e, rootHref);\n
    }\n
}\n
\n
function removeErrorHTML(path) {\n
    var node = document.getElementById(\'less-error-message:\' + extractId(path));\n
    if (node) {\n
        node.parentNode.removeChild(node);\n
    }\n
}\n
\n
function removeErrorConsole(path) {\n
    //no action\n
}\n
\n
function removeError(path) {\n
    if (!less.errorReporting || less.errorReporting === "html") {\n
        removeErrorHTML(path);\n
    } else if (less.errorReporting === "console") {\n
        removeErrorConsole(path);\n
    } else if (typeof less.errorReporting === \'function\') {\n
        less.errorReporting("remove", path);\n
    }\n
}\n
\n
function loadStyles(newVars) {\n
    var styles = document.getElementsByTagName(\'style\'),\n
        style;\n
    for (var i = 0; i < styles.length; i++) {\n
        style = styles[i];\n
        if (style.type.match(typePattern)) {\n
            var env = new less.tree.parseEnv(less),\n
                lessText = style.innerHTML || \'\';\n
            env.filename = document.location.href.replace(/#.*$/, \'\');\n
\n
            if (newVars || varsPre) {\n
                env.useFileCache = true;\n
\n
                lessText = varsPre + lessText;\n
\n
                if (newVars) {\n
                    lessText += "\\n" + newVars;\n
                }\n
            }\n
\n
            /*jshint loopfunc:true */\n
            // use closure to store current value of i\n
            var callback = (function(style) {\n
                return function (e, cssAST) {\n
                    if (e) {\n
                        return error(e, "inline");\n
                    }\n
                    var css = cssAST.toCSS(less);\n
                    style.type = \'text/css\';\n
                    if (style.styleSheet) {\n
                        style.styleSheet.cssText = css;\n
                    } else {\n
                        style.innerHTML = css;\n
                    }\n
                };\n
            })(style);\n
            new(less.Parser)(env).parse(lessText, callback);\n
        }\n
    }\n
}\n
\n
function extractUrlParts(url, baseUrl) {\n
    // urlParts[1] = protocol&hostname || /\n
    // urlParts[2] = / if path relative to host base\n
    // urlParts[3] = directories\n
    // urlParts[4] = filename\n
    // urlParts[5] = parameters\n
\n
    var urlPartsRegex = /^((?:[a-z-]+:)?\\/+?(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i,\n
        urlParts = url.match(urlPartsRegex),\n
        returner = {}, directories = [], i, baseUrlParts;\n
\n
    if (!urlParts) {\n
        throw new Error("Could not parse sheet href - \'"+url+"\'");\n
    }\n
\n
    // Stylesheets in IE don\'t always return the full path\n
    if (!urlParts[1] || urlParts[2]) {\n
        baseUrlParts = baseUrl.match(urlPartsRegex);\n
        if (!baseUrlParts) {\n
            throw new Error("Could not parse page url - \'"+baseUrl+"\'");\n
        }\n
        urlParts[1] = urlParts[1] || baseUrlParts[1] || "";\n
        if (!urlParts[2]) {\n
            urlParts[3] = baseUrlParts[3] + urlParts[3];\n
        }\n
    }\n
\n
    if (urlParts[3]) {\n
        directories = urlParts[3].replace(/\\\\/g, "/").split("/");\n
\n
        // extract out . before .. so .. doesn\'t absorb a non-directory\n
        for(i = 0; i < directories.length; i++) {\n
            if (directories[i] === ".") {\n
                directories.splice(i, 1);\n
                i -= 1;\n
            }\n
        }\n
\n
        for(i = 0; i < directories.length; i++) {\n
            if (directories[i] === ".." && i > 0) {\n
                directories.splice(i-1, 2);\n
                i -= 2;\n
            }\n
        }\n
    }\n
\n
    returner.hostPart = urlParts[1];\n
    returner.directories = directories;\n
    returner.path = urlParts[1] + directories.join("/");\n
    returner.fileUrl = returner.path + (urlParts[4] || "");\n
    returner.url = returner.fileUrl + (urlParts[5] || "");\n
    return returner;\n
}\n
\n
function pathDiff(url, baseUrl) {\n
    // diff between two paths to create a relative path\n
\n
    var urlParts = extractUrlParts(url),\n
        baseUrlParts = extractUrlParts(baseUrl),\n
        i, max, urlDirectories, baseUrlDirectories, diff = "";\n
    if (urlParts.hostPart !== baseUrlParts.hostPart) {\n
        return "";\n
    }\n
    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n
    for(i = 0; i < max; i++) {\n
        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }\n
    }\n
    baseUrlDirectories = baseUrlParts.directories.slice(i);\n
    urlDirectories = urlParts.directories.slice(i);\n
    for(i = 0; i < baseUrlDirectories.length-1; i++) {\n
        diff += "../";\n
    }\n
    for(i = 0; i < urlDirectories.length-1; i++) {\n
        diff += urlDirectories[i] + "/";\n
    }\n
    return diff;\n
}\n
\n
function getXMLHttpRequest() {\n
    if (window.XMLHttpRequest) {\n
        return new XMLHttpRequest();\n
    } else {\n
        try {\n
            /*global ActiveXObject */\n
            return new ActiveXObject("MSXML2.XMLHTTP.3.0");\n
        } catch (e) {\n
            log("browser doesn\'t support AJAX.", logLevel.errors);\n
            return null;\n
        }\n
    }\n
}\n
\n
function doXHR(url, type, callback, errback) {\n
    var xhr = getXMLHttpRequest();\n
    var async = isFileProtocol ? less.fileAsync : less.async;\n
\n
    if (typeof(xhr.overrideMimeType) === \'function\') {\n
        xhr.overrideMimeType(\'text/css\');\n
    }\n
    log("XHR: Getting \'" + url + "\'", logLevel.info);\n
    xhr.open(\'GET\', url, async);\n
    xhr.setRequestHeader(\'Accept\', type || \'text/x-less, text/css; q=0.9, */*; q=0.5\');\n
    xhr.send(null);\n
\n
    function handleResponse(xhr, callback, errback) {\n
        if (xhr.status >= 200 && xhr.status < 300) {\n
            callback(xhr.responseText,\n
                xhr.getResponseHeader("Last-Modified"));\n
        } else if (typeof(errback) === \'function\') {\n
            errback(xhr.status, url);\n
        }\n
    }\n
\n
    if (isFileProtocol && !less.fileAsync) {\n
        if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {\n
            callback(xhr.responseText);\n
        } else {\n
            errback(xhr.status, url);\n
        }\n
    } else if (async) {\n
        xhr.onreadystatechange = function () {\n
            if (xhr.readyState == 4) {\n
                handleResponse(xhr, callback, errback);\n
            }\n
        };\n
    } else {\n
        handleResponse(xhr, callback, errback);\n
    }\n
}\n
\n
function loadFile(originalHref, currentFileInfo, callback, env, newVars) {\n
\n
    if (currentFileInfo && currentFileInfo.currentDirectory && !/^([a-z-]+:)?\\//.test(originalHref)) {\n
        originalHref = currentFileInfo.currentDirectory + originalHref;\n
    }\n
\n
    // sheet may be set to the stylesheet for the initial load or a collection of properties including\n
    // some env variables for imports\n
    var hrefParts = extractUrlParts(originalHref, window.location.href);\n
    var href      = hrefParts.url;\n
    var newFileInfo = {\n
        currentDirectory: hrefParts.path,\n
        filename: href\n
    };\n
\n
    if (currentFileInfo) {\n
        newFileInfo.entryPath = currentFileInfo.entryPath;\n
        newFileInfo.rootpath = currentFileInfo.rootpath;\n
        newFileInfo.rootFilename = currentFileInfo.rootFilename;\n
        newFileInfo.relativeUrls = currentFileInfo.relativeUrls;\n
    } else {\n
        newFileInfo.entryPath = hrefParts.path;\n
        newFileInfo.rootpath = less.rootpath || hrefParts.path;\n
        newFileInfo.rootFilename = href;\n
        newFileInfo.relativeUrls = env.relativeUrls;\n
    }\n
\n
    if (newFileInfo.relativeUrls) {\n
        if (env.rootpath) {\n
            newFileInfo.rootpath = extractUrlParts(env.rootpath + pathDiff(hrefParts.path, newFileInfo.entryPath)).path;\n
        } else {\n
            newFileInfo.rootpath = hrefParts.path;\n
        }\n
    }\n
\n
    if (env.useFileCache && fileCache[href]) {\n
        try {\n
            var lessText = fileCache[href];\n
            if (newVars) {\n
                lessText += "\\n" + newVars;\n
            }\n
            callback(null, lessText, href, newFileInfo, { lastModified: new Date() });\n
        } catch (e) {\n
            callback(e, null, href);\n
        }\n
        return;\n
    }\n
\n
    doXHR(href, env.mime, function (data, lastModified) {\n
        data = varsPre + data;\n
\n
        // per file cache\n
        fileCache[href] = data;\n
\n
        // Use remote copy (re-parse)\n
        try {\n
            callback(null, data, href, newFileInfo, { lastModified: lastModified });\n
        } catch (e) {\n
            callback(e, null, href);\n
        }\n
    }, function (status, url) {\n
        callback({ type: \'File\', message: "\'" + url + "\' wasn\'t found (" + status + ")" }, null, href);\n
    });\n
}\n
\n
function loadStyleSheet(sheet, callback, reload, remaining, newVars) {\n
\n
    var env = new less.tree.parseEnv(less);\n
    env.mime = sheet.type;\n
\n
    if (newVars || varsPre) {\n
        env.useFileCache = true;\n
    }\n
\n
    loadFile(sheet.href, null, function(e, data, path, newFileInfo, webInfo) {\n
\n
        if (webInfo) {\n
            webInfo.remaining = remaining;\n
\n
            var css       = cache && cache.getItem(path),\n
                timestamp = cache && cache.getItem(path + \':timestamp\');\n
\n
            if (!reload && timestamp && webInfo.lastModified &&\n
                (new(Date)(webInfo.lastModified).valueOf() ===\n
                    new(Date)(timestamp).valueOf())) {\n
                // Use local copy\n
                createCSS(css, sheet);\n
                webInfo.local = true;\n
                callback(null, null, data, sheet, webInfo, path);\n
                return;\n
            }\n
        }\n
\n
        //TODO add tests around how this behaves when reloading\n
        removeError(path);\n
\n
        if (data) {\n
            env.currentFileInfo = newFileInfo;\n
            new(less.Parser)(env).parse(data, function (e, root) {\n
                if (e) { return callback(e, null, null, sheet); }\n
                try {\n
                    callback(e, root, data, sheet, webInfo, path);\n
                } catch (e) {\n
                    callback(e, null, null, sheet);\n
                }\n
            });\n
        } else {\n
            callback(e, null, null, sheet, webInfo, path);\n
        }\n
    }, env, newVars);\n
}\n
\n
function loadStyleSheets(callback, reload, newVars) {\n
    for (var i = 0; i < less.sheets.length; i++) {\n
        loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), newVars);\n
    }\n
}\n
\n
function initRunningMode(){\n
    if (less.env === \'development\') {\n
        less.optimization = 0;\n
        less.watchTimer = setInterval(function () {\n
            if (less.watchMode) {\n
                loadStyleSheets(function (e, root, _, sheet, env) {\n
                    if (e) {\n
                        error(e, sheet.href);\n
                    } else if (root) {\n
                        createCSS(root.toCSS(less), sheet, env.lastModified);\n
                    }\n
                });\n
            }\n
        }, less.poll);\n
    } else {\n
        less.optimization = 3;\n
    }\n
}\n
\n
function serializeVars(vars) {\n
    var s = "";\n
\n
    for (var name in vars) {\n
        s += ((name.slice(0,1) === \'@\')? \'\' : \'@\') + name +\': \'+\n
                ((vars[name].slice(-1) === \';\')? vars[name] : vars[name] +\';\');\n
    }\n
\n
    return s;\n
}\n
\n
\n
//\n
// Watch mode\n
//\n
less.watch   = function () {\n
    if (!less.watchMode ){\n
        less.env = \'development\';\n
         initRunningMode();\n
    }\n
    return this.watchMode = true;\n
};\n
\n
less.unwatch = function () {clearInterval(less.watchTimer); return this.watchMode = false; };\n
\n
if (/!watch/.test(location.hash)) {\n
    less.watch();\n
}\n
\n
if (less.env != \'development\') {\n
    try {\n
        cache = (typeof(window.localStorage) === \'undefined\') ? null : window.localStorage;\n
    } catch (_) {}\n
}\n
\n
//\n
// Get all <link> tags with the \'rel\' attribute set to "stylesheet/less"\n
//\n
var links = document.getElementsByTagName(\'link\');\n
\n
less.sheets = [];\n
\n
for (var i = 0; i < links.length; i++) {\n
    if (links[i].rel === \'stylesheet/less\' || (links[i].rel.match(/stylesheet/) &&\n
       (links[i].type.match(typePattern)))) {\n
        less.sheets.push(links[i]);\n
    }\n
}\n
\n
//\n
// With this function, it\'s possible to alter variables and re-render\n
// CSS without reloading less-files\n
//\n
less.modifyVars = function(record) {\n
    less.refresh(false, serializeVars(record));\n
};\n
\n
less.refresh = function (reload, newVars) {\n
    var startTime, endTime;\n
    startTime = endTime = new Date();\n
\n
    loadStyleSheets(function (e, root, _, sheet, env) {\n
        if (e) {\n
            return error(e, sheet.href);\n
        }\n
        if (env.local) {\n
            log("loading " + sheet.href + " from cache.", logLevel.info);\n
        } else {\n
            log("parsed " + sheet.href + " successfully.", logLevel.info);\n
            createCSS(root.toCSS(less), sheet, env.lastModified);\n
\n
            console.groupCollapsed("Runtime css");\n
            console.log(root.toCSS(less));\n
            console.groupEnd();\n
\n
        }\n
        log("css for " + sheet.href + " generated in " + (new Date() - endTime) + \'ms\', logLevel.info);\n
        if (env.remaining === 0) {\n
            log("css generated in " + (new Date() - startTime) + \'ms\', logLevel.info);\n
        }\n
        endTime = new Date();\n
    }, reload, newVars);\n
\n
    loadStyles(newVars);\n
};\n
\n
if (less.globalVars) {\n
    varsPre = serializeVars(less.globalVars) + "\\n";\n
}\n
\n
less.refreshStyles = loadStyles;\n
\n
less.Parser.fileLoader = loadFile;\n
\n
less.refresh(less.env === \'development\');\n
\n
// amd.js\n
//\n
// Define Less as an AMD module.\n
if (typeof define === "function" && define.amd) {\n
    define(function () { return less; } );\n
}\n
\n
})(window);

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <none/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
